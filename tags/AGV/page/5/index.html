<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: AGV - GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags/">Tags</a></li><li class="is-active"><a href="#" aria-current="page">AGV</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-16T19:36:21.000Z" title="16/11/2024, 20:36:21">2024-11-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.413Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">10 minutes read (About 1558 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-4/">AGV 3.4 -- Closure Properties of the Büchi-recognizable languages (Concatenations)</a></p><div class="content"><p>Previous chapter: <a href="../agv3-3/">Closure Properties of the Büchi-recognizable languages (Intersection and Union)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>In this section, we continue the proof of the <strong>closure properties</strong> of the Büchi-recognizable languages.</p>
<h2 id="Concatenation-of-regular-Langauge-and-Buchi-recognizable-Language"><a href="#Concatenation-of-regular-Langauge-and-Buchi-recognizable-Language" class="headerlink" title="Concatenation of regular Langauge and Büchi-recognizable Language"></a>Concatenation of regular Langauge and Büchi-recognizable Language</h2><blockquote>
<p>$\textbf{Construction 3.3. } \text{Let }\mathcal{A}_1&#x3D;(\Sigma,Q_1,I_1,T_1,F_1)\text{ be an automaton over finite words that}\newline\text{recognizes the languge }L_1\text{, and let }\mathcal{A}_2 &#x3D; (\Sigma,Q_2,I_2,T_2,\small\text{BÜCHI}\normalsize (F_2))\text{ be a Büchi automaton}\newline\text{over the same alphabet that recognizes }L_2.\text{ We construct a Büchi autotmaton }\newline\mathcal{A’}&#x3D;(\Sigma,Q’,I’,T’,\small\text{BÜCHI}\normalsize (F_2))\text{ with }\mathcal{L}(\mathcal{A’})&#x3D;L_1\cdot L_2\text{ as follows:}$<br>$\begin{array}{lrll}<br>\hspace{1cm} \cdot &amp;Q’&amp;&#x3D;&amp;Q_1\cup Q_2 \hspace{0.7cm}(\text{w.l.o.g we assume }Q_1\cap Q_2&#x3D;\varnothing)\newline<br>\hspace{1cm} \cdot &amp;I’&amp;&#x3D;&amp;\biggl\lbrace \begin{array}{ll}I_1 &amp; \ \text{if }I_1\cap F_1&#x3D;\varnothing\newline<br>I_1\cup I_2 &amp; \ \text{otherwise}\end{array} \newline<br>\hspace{1cm} \cdot &amp;T’&amp;&#x3D;&amp;T_1\cup T_2\cup\lbrace (q,\sigma,q’)\mid(q,\sigma,f)\in T_1,f\in F_1,q’\in I_2\rbrace \newline<br>\end{array}$</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Notation</th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$Q’$</td>
<td align="left">Same as Union, we include both automata for concatenation</td>
</tr>
<tr>
<td align="left">$I’$</td>
<td align="left">We normaly start the the automaton from $I_1$ If $I_1$ is non-empty, otherwise we start at $I_2$</td>
</tr>
<tr>
<td align="left">$T’$</td>
<td align="left">For any states that can reach the accepting states of $T_1$ with one transition, we create a new transitions that reach the initial states of $T_2$ $(I_2)$</td>
</tr>
</tbody></table>
<p>The correctness of this construction is proven by the following theorem.</p>
<blockquote>
<p>$\textbf{Theorem 3.4. }\newline\textit{If $L_1$ is a regular language and $L_2$ is Büchi-recognizable, then $L_1\cdot L_2$ is Büchi-recognizable.}$</p>
</blockquote>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>If $I_1$ is non-empty, then we can have a run that starts from $I_1$ to $r(n)$, that is one transition before $\mathcal{A_1}$’s accepting states of $f$. Then for next transition we either move to $f$, or we move on to $\mathcal{A_2}$ starting from $r(n+1)$.</p>
<p>If $I_1$ is empty, then any word accepted by $\mathcal{A‘}$ is accepted by $\mathcal{A_2}$</p>
<p>On the other way, we can always construct a word $w\alpha$. If $w$ is accepted by $\mathcal{A_1}$ and $\alpha$ is accepted by $\mathcal{A_2}$, then $w\alpha$ is always accepted by $\mathcal{A’}$</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>We prove that the Büchi automaton $\mathcal{A’}$ built from the automaton on finite words $\mathcal{A}_1$ and the Büchi automaton $\mathcal{A}_2$ indeed recognizes the concatenation of the languages of the two automata.</p>
<p>$\mathcal{L}(\mathcal{A’})\subseteq\mathcal{L}(\mathcal{A}_1)\cdot\mathcal{L}(\mathcal{A}_2):$</p>
<p>For $\alpha\in\mathcal{L}(\mathcal{A’})$, we have an accepting run $r&#x3D;r(0)r(1)r(2)\dots$ of $\mathcal{A’}$ on $\alpha$.<br>If $r(0)\in I_1$, then there is an $n\in\mathbb{N}$ such that $(r(n),\alpha(n),r(n+1))\in Q_1\times\Sigma\times I_2$ and therefore, there is a final state $f\in F_1$ such that $r(0)r(1)r(2)\dots r(n)f$ is an accepting run of $\mathcal{A_1}$ on $\alpha(0)\alpha(1)\alpha(2)\dots \alpha(n)$ and $r(n+1)r(n+2)\dots$ is an accepting run of $\mathcal{A_2}$ on $\alpha(n+1)\alpha(n+2)\dots$<br>If $r(0)\in I_2$ then $I_1\cup F_1 \neq\varnothing$ and therefore, $\varepsilon\in\mathcal{L}(\mathcal{A_1}),\alpha\in\mathcal{L}(\mathcal{A_2})$</p>
<p>$\mathcal{L}(\mathcal{A’})\supseteq\mathcal{L}(\mathcal{A}_1)\cdot\mathcal{L}(\mathcal{A}_2):$</p>
<p>For $w\in\mathcal{A_1}$, let $r&#x3D;r(0)r(1)\dots r(n)$ be an accepting run $\mathcal{A_1}$ on $w$.<br>For $\alpha\in\mathcal{A_2}$, let $s&#x3D;s(0)s(1)\dots$ be an accepting run of $\mathcal{A_2}$ on $\alpha$.<br>Then, $r(n)\in F_1$ and, by construction, $r(0)r(1)\dots r(n-1)s(0)s(1)\dots$ is an accepting run of $\mathcal{A’}$ on $w\alpha$.</p>
<h2 id="Infinite-concatenation-of-Regular-language"><a href="#Infinite-concatenation-of-Regular-language" class="headerlink" title="Infinite concatenation of Regular language"></a>Infinite concatenation of Regular language</h2><p>Finally, we show that the infinite concatenation of words of a regular language forms a Büchi-recognizable language. We construct a Büchi automaton for this language from an automaton over finite words in two steps.</p>
<h3 id="From-automaton-over-finite-words-to-a-single-initial-state"><a href="#From-automaton-over-finite-words-to-a-single-initial-state" class="headerlink" title="From automaton over finite words to a single initial state"></a>From automaton over finite words to a single initial state</h3><p>Firstly, we modify a given automaton over finite words into an equivalent automaton with one <strong>single initial state</strong> that has <strong>no incoming transitions</strong>.</p>
<p>We do this by create a new fresh state as the new initial state, with all transitions identical as the original. And the original initial state now has no incoming transitions.</p>
<blockquote>
<p>$\textbf{Construction 3.4. } \text{Let }\mathcal{A}_1&#x3D;(\Sigma,Q_1,I_1,T_1,F_1)\text{ be an automaton over finite words. We assume}\newline\text{that }\varepsilon\notin\mathcal{L}(\mathcal{A})\text{. We construct an automaton }\mathcal{A’} &#x3D; (\Sigma,Q’,I’,T’,F)\text{ over finite words such that }\newline\mathcal{L}(\mathcal{A})&#x3D;\mathcal{L}(\mathcal{A’})\text{ and }\mathcal{A’}\text{ has a single initial state that has no incoming transitions.}$<br>$\begin{array}{lrll}<br>\hspace{1cm} \cdot &amp;Q’&amp;&#x3D;&amp;Q_1\cup\lbrace q_f\rbrace \text{where }q_f\text{ is a fresh state}\newline<br>\hspace{1cm} \cdot &amp;I’&amp;&#x3D;&amp;\lbrace q_f\rbrace\newline<br>\hspace{1cm} \cdot &amp;T’&amp;&#x3D;&amp;T\cup\lbrace (q_f,\sigma,q’)\mid(q,\sigma,q’)\in T \text{ for some }q\in I\rbrace\newline<br>\end{array}$</p>
</blockquote>
<p>The second construction builds the Büchi automaton that recognizes the infinite concatenations of words from the regular language by <strong>adding a loop</strong> to the modified automaton.</p>
<blockquote>
<p>$\textbf{Construction 3.5. } \text{Let }\mathcal{A}\text{ be an automaton over finite words. We assume that }\varepsilon\notin\mathcal{L}(\mathcal{A}).\newline\text{We construct a Büchi automaton }\mathcal{A’’}&#x3D;(\Sigma,Q’’,I’’,T’’,\small\text{BÜCHI}\normalsize (F’’))\text{ such that }\mathcal{L}(\mathcal{A’’})&#x3D;\mathcal{L}(\mathcal{A})^\omega.\newline\text{Let }\mathcal{A’}&#x3D;(\Sigma,Q’,I’,T’,F’)\text{ be the automaton of Construction 3.4. Then }A’’\text{ is defined as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ Q’’&#x3D;Q’ \hspace{1cm} \cdot \ I’’&#x3D;I’ \hspace{1cm} \cdot \ F’’&#x3D;I’\newline<br>\hspace{1cm} \cdot \ T’’&#x3D;T’\cup\lbrace (q,\sigma,q_f)\mid(q,\sigma,q’)\in T’ \text{ and }q’\in F’\rbrace\newline<br>\end{array}$</p>
</blockquote>
<p>This construction change the final state into the initial state, with adding new transition from final state to initial state. Therefore the automaton becomes a loop.</p>
<p>The correctness of this construction is proven by the following theorem.</p>
<blockquote>
<p>$\textbf{Theorem 3.5. }\textit{If $L$ is a regular language such that $\varepsilon\notin L$, then $L^\omega$ is Büchi-recognizable}$</p>
</blockquote>
<h3 id="Explained-in-Human-language-1"><a href="#Explained-in-Human-language-1" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>If there is accepting run for $\mathcal{L}(\mathcal{A’’})$, it reaches the accepting state infinitely often.<br>We can split the word in every accepting states and it will be an accepting run for $\mathcal{L}(\mathcal{A’})$, since the transition to accepting state $F’’$ and $F’$ are identical.</p>
<p>If there is accepting run(s) for $\mathcal{L}(\mathcal{A’})$, we can infinitely repeat them so that is also accepted for $\mathcal{L}(\mathcal{A’’})$.</p>
<h3 id="Formal-Proof-1"><a href="#Formal-Proof-1" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>Construction 3.4 does not affect the language of $\mathcal{A}$. We show that the Büchi automaton $\mathcal{A’’}$ built in Construction 3.5 from the resulting automaton $\mathcal{A’}$ on finite words indeed recognizes $\mathcal{L}(\mathcal{A’})^\omega$.</p>
<p>$\mathcal{L}(\mathcal{A’’})\subseteq\mathcal{L}(\mathcal{A’})^\omega:$</p>
<p>Assume that $\alpha\in\mathcal{L}(\mathcal{A’’})$ and that $r(0)r(1)r(2)\dots$ is an accpeting run of $\mathcal{A’’}$ on $\alpha$. Hence, we have that $r(i)&#x3D;q_f\in F’’&#x3D;I’$ for inifinitely many indices $i:i_0,i_1,i_2,\dots$. This provides a sequence of runs of $\mathcal{A’}$:</p>
<ul>
<li>run $r(0)r(1)\dots r(i_0-1)q$ on $w_0&#x3D; \alpha(0)\alpha(1)\dots\alpha(i_0-1)$ for some $q\in F’$</li>
<li>run $r(i_0)r(i_0+1)\dots r(i_i-1)q$ on $w_1&#x3D; \alpha(i_0)\alpha(i_1)\dots\alpha(i_1-1)$ for some $q\in F’$</li>
<li>and so forth.</li>
</ul>
<p>We thus have that $w_k\in\mathcal{L}(\mathcal{A’})$ for every $k\geq 0$. Hence, $\alpha\in\mathcal{L}(\mathcal{A’})^\omega$.</p>
<p>$\mathcal{L}(\mathcal{A’’})\supseteq\mathcal{L}(\mathcal{A’})^\omega:$</p>
<p>Assume that $\alpha &#x3D;w_0w_1w_2\dots\in\Sigma^\omega$ such that $w_k\in\mathcal{L}(\mathcal{A’})$ for all $k\geq 0$. For each $k$, we choose an accepting run $r_k(0)r_k(1)r_k(2)\dots r_k(n_k)$ of $\mathcal{A’}$ on $w_k$. Hence, $r_k(0)\in I’$ and $r_k(n_k)\in F’$ for all $k&gt;1$. Thus,</p>
<p>$$r_0(0)\dots r_0(n_0-1)r_1(0)\dots r_1(n_1-1)r_2(0)\dots r_2(n_2-1)\dots$$</p>
<p>is an accepting run of $\mathcal{A’’}$ on $\alpha$. Hence, $\alpha\in\mathcal{L}(\mathcal{A’’})$.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Now we proved the closure property holds for <strong>Union</strong> $(W_1\cup W_2)$, <strong>Intersection</strong> $(W_1\cap W_2)$, <strong>Concatenation of regular Langauge and Büchi-recognizable Language</strong> $(E+W)$, and <strong>Infinite concatenation of Regular language</strong> $(E^\omega)$.</p>
<p>In the next section we can start to prove <strong>Büchi’s Characterization Theorem</strong>.</p>
<hr>
<p>Next chapter: <a href="../agv3-5/">Büchi’s Characterization Theorem</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Closure_(mathematics)">Closure (mathematics)</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concatenation">Concatenation</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Absolute_infinite">Absolute infinite</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-15T00:31:57.000Z" title="15/11/2024, 01:31:57">2024-11-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.425Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 963 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-3/">AGV 3.3 -- Closure Properties of the Büchi-recognizable languages (Intersection and Union)</a></p><div class="content"><p>Previous chapter: <a href="../agv3-2/">$\omega$-regular language</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>In the following we refer the languages recognized by Büchi automata simply as <strong>Büchi-recognizable languages</strong>. <strong>Büchi’s characterization theorem</strong> states that the $\omega$-regular languages are exactly <strong>Büchi-recognizable languages</strong>. To prepare for the proof of Büchi’s theorem, we establish several <strong>closure properties</strong> of the Büchi-recognizable languages.</p>
<h2 id="Closure-Properties-of-Language-Union"><a href="#Closure-Properties-of-Language-Union" class="headerlink" title="Closure Properties of Language Union"></a>Closure Properties of Language Union</h2><blockquote>
<p>$\textbf{Construction 3.1. } \text{Let }L_1\text{ and }L_2\text{ be }\omega\text{-languages recognized by the Büchi automata}\newline\mathcal{A}_1&#x3D;(\Sigma,Q_1,I_1,T_1,\small\text{BÜCHI}\normalsize (F_1))\text{ and }\mathcal{A}_2 &#x3D; (\Sigma,Q_2,I_2,T_2,\small\text{BÜCHI}\normalsize (F_2))\text{, respectively.}\newline\text{We construct}\mathcal{A}_\cup&#x3D;(\Sigma,Q_\cup,I_\cup,T_\cup,\small\text{BÜCHI}\normalsize (F_\cup))\text{ with }\mathcal{L}(\mathcal{A}_\cup)&#x3D;L_1\cup L_2\text{ as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ Q_\cup&#x3D;Q_1\cup Q_2 \hspace{1cm}(\text{w.l.o.g we assume }Q_1\cap Q_2&#x3D;\varnothing)\newline<br>\hspace{1cm} \cdot \ I_\cup&#x3D;I_1\cup I_2 \ \hspace{1cm} \cdot \ T_\cup&#x3D;T_1\cup T_2 \ \hspace{1cm} \cdot \ F_\cup&#x3D;F_1\cup F_2 \newline<br>\end{array}$</p>
</blockquote>
<p>The correctness of this construction is proven by the following theorem.</p>
<blockquote>
<p>$\textbf{Theorem 3.2. } \textit{If $L_1$ and $L_2$ are Büchi-recognizable, then so is $L_1\cup L_2$.}$</p>
</blockquote>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>We prove that the Büchi automaton $\mathcal{A}_\cup$ built by $\mathcal{A}_1$ and $\mathcal{A}_2$ indeed recognizes the union of the languages of the two automata.</p>
<p>$\mathcal{L}(\mathcal{A}_\cup)\subseteq\mathcal{L}(\mathcal{A}_1)\cup\mathcal{L}(\mathcal{A}_2):$</p>
<p>For $\alpha\in\mathcal{L}(\mathcal{A}_\cup)$, we have an accepting run $r&#x3D;r(0)r(1)r(2)\dots$ of $\mathcal{A}_\cup$ on $\alpha$.<br>If $r(0)\in I_1$, then $r$ is an accepting run of $\mathcal{A}_1$, otherwise $r(0)\in I_2$ and $r$ is an accepting run of $\mathcal{A}_2$.</p>
<p>$\mathcal{L}(\mathcal{A}_\cup)\supseteq\mathcal{L}(\mathcal{A}_1)\cup\mathcal{L}(\mathcal{A}_2):$</p>
<p>For $i\in\lbrace 1,2\rbrace$ and $\alpha\in\mathcal{L}(\mathcal{A}_i)$, there is an accepting run $r$ of $\mathcal{A}_i$. The run $r$ is also an accepting run of $\mathcal{A}_\cup$.</p>
<h2 id="Closure-Properties-of-Language-Intersection"><a href="#Closure-Properties-of-Language-Intersection" class="headerlink" title="Closure Properties of Language Intersection"></a>Closure Properties of Language Intersection</h2><p>As we will see later, the Büchi-recognizable languages are closed under <code>complement</code>.<br>The closure under <code>complement</code> and <code>union</code> implies the closure under <code>intersection</code> $(\mathcal{A}_\cap &#x3D; (\mathcal{A’_1}\cup \mathcal{A’_2})’)$</p>
<p>Below, the automaton for the intersection is essentially the product of the two automata.</p>
<blockquote>
<p>$\textbf{Construction 3.2. } \text{Let }L_1\text{ and }L_2\text{ be }\omega\text{-languages recognized by the Büchi automata}\newline\mathcal{A}_1&#x3D;(\Sigma,Q_1,I_1,T_1,\small\text{BÜCHI}\normalsize(F_1))\text{ and }\mathcal{A}_2 &#x3D; (\Sigma,Q_2,I_2,T_2,\small\text{BÜCHI}\normalsize (F_2))\text{, respectively.}\newline\text{We construct}\mathcal{A}_\cap&#x3D;(\Sigma,Q_\cap,I_\cap,T_\cap,\small\text{BÜCHI}\normalsize (F_\cap))\text{ with }\mathcal{L}(\mathcal{A}_\cap)&#x3D;L_1\cap L_2\text{ as follows:}$<br>$\begin{array}{rll}<br>\hspace{1cm} \cdot \ Q_\cap&amp;&#x3D;&amp;Q_1\times Q_2\times\lbrace 1,2\rbrace\newline<br>\hspace{1cm} \cdot \ I_\cap&amp;&#x3D;&amp;I_1\times I_2\times\lbrace 1\rbrace\newline<br>\hspace{1cm} \cdot \ T_\cap&amp;&#x3D;&amp;\lbrace (q_1,q_2,i),\sigma ,(q’_1,q’_2,j)\mid (q_1,\sigma,q’_1)\in T_1,(q_2,\sigma,q’_2)\in T_2,i,j\in\lbrace 1,2\rbrace,\newline<br>\hspace{1cm} \ &amp;&amp;\hspace{5.3cm}q_i \notin F_i\rightarrow i&#x3D;j \wedge q_i\in F_i\wedge i\neq j\rbrace\newline<br>\hspace{1cm} \cdot \ F_\cap&amp;&#x3D;&amp;\lbrace (q_1,q_2,2)\mid q_1\in F_1, q_2\in F_2\rbrace\newline<br>\end{array}$</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$Q_\cap$</td>
<td align="left">States in the new automaton is <strong>tuples</strong> that contain the states of two automata plus the third component that used to <strong>combine acceptance conditions</strong>, e.g. $(q_1,q_2,1)$ is a state.</td>
</tr>
<tr>
<td align="left">$I_\cap$</td>
<td align="left">New automaton is constructed with only <strong>one initial state</strong>, so we assign the value to the acceptance condition <code>&#123;1&#125;</code> for simplicity</td>
</tr>
<tr>
<td align="left">$T_\cap$</td>
<td align="left">The switch from $\lbrace 0\rbrace$ and $\lbrace 1\rbrace$ happens nondeterministically. And once you enter the second copy $\lbrace 1\rbrace$, it stays forever.</td>
</tr>
<tr>
<td align="left">$F_\cap$</td>
<td align="left">For each transition, it has to be possible by both automata and if such transition reach the one of the automata’s accepting state, the acceptance condition changed. This creates an alternation between the accepting state of the 1st and 2nd automaton.</td>
</tr>
</tbody></table>
<p>Since we start our acceptance condition as <code>&#123;1&#125;</code>, our accepting states of the new automaton will be the <strong>accepting states of the 2nd automaton when acceptance condition becomes <code>&#123;2&#125;</code></strong>. i.e. Whenever the run reach to the accepting states of the 2nd automaton, it always has to first reach the accepting states of the 1st automaton.</p>
<blockquote>
<p>$\textbf{Theorem 3.3. } \textit{If $L_1$ and $L_2$ are Büchi-recognizable, then so is $L_1\cap L_2$.}$</p>
</blockquote>
<h3 id="Formal-Proof-1"><a href="#Formal-Proof-1" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>The run $r’$ is accepting iff $r_1$ is accepting and $r_2$ is accepting.</p>
<p>i.e. $r’&#x3D;(q_1^0,q_2^0,t^0)(q_1^1,q_2^1,t^1)\dots$ is a run of $\mathcal{A}_\cap$ on an input word $\alpha$,<br>iff $r_1 &#x3D; q^0_1 q^1_1\dots$ is a run of $\mathcal{A}_1$ on $\alpha$ and $r_1 &#x3D; q^0_2 q^1_2\dots$ is a run of $\mathcal{A}_2$ on $\alpha$</p>
<p>Therefore, an accepting run will be: <strong>(1)</strong> go to states with <code>&#123;1&#125;</code> → <strong>(2)</strong> reach accepting state of 1st automaton → <strong>(3)</strong> go to states with <code>&#123;2&#125;</code> → <strong>(4)</strong> reach accepting state of 2nd automaton → goes back to <strong>(1)</strong>…</p>
<hr>
<p>Next chapter: <a href="../agv3-4/">Closure Properties of the Büchi-recognizable languages (Concatenations)</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Closure_(mathematics)">Closure (mathematics)</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intersection_(set_theory)">Intersection (set theory)</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_(set_theory)">Union (set theory)</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-14T11:40:04.000Z" title="14/11/2024, 12:40:04">2024-11-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.411Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 381 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-2/">AGV 3.2 -- $\omega$-regular language</a></p><div class="content"><p>Previous chapter: <a href="../agv/">Kleene’s Theorem</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><em>$\omega$-regular expression</em> denotes languages over <strong>infinite</strong> words.<br>In addition to language union on languages over infinite words, we have 2 operations that convert languages over finite words into languages over infinite words.</p>
<h2 id="omega-regular-expression"><a href="#omega-regular-expression" class="headerlink" title="$\omega$-regular expression"></a>$\omega$-regular expression</h2><p>The collection of $\omega$-regular languages over an alphabet $\Sigma^\omega$ is $\mathcal{L}(W)$, where $W$ is a $\omega$-regular expression.<br>$\omega$-regular expression can be defined as $W :&#x3D; E^\omega \mid E\cdot W\mid W_1+W_2 $, where:</p>
<ul>
<li><strong>infinite concatenation</strong> of a <strong>non-empty</strong> regular language $E^\omega$,</li>
<li><strong>union</strong> of $\omega$-regular languages, $W_1+W_2$, and</li>
<li><strong>concatenation</strong> of regular languages and $\omega$-regular language $E\cdot W$</li>
</ul>
<blockquote>
<p>$\textbf{Definition 3.3. } \textit{$\omega$-Regular expressions } \text{are defined as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ \text{If $E$ is a regular expression where $\varepsilon\notin\mathcal{L}(E)$, then $E^\omega$ is an $\omega$-regular expression.}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E^\omega) &#x3D; \mathcal{L}(E)^\omega\newline<br>\hspace{1cm} \ \ \text{where } L^\omega &#x3D;\lbrace \omega_0\omega_1\dots\mid\omega_i\in L,|\omega_i|&gt;0\rbrace \text{ for } L\subseteq\Sigma^* \newline<br>\hspace{1cm} \cdot \ \text{If $E$ is a regular expression and $W$ is an $\omega$-regular expression,}\newline<br>\hspace{1cm} \ \ \text{then $E\cdot W$ is an $\omega$-regular expression:}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E\cdot W) &#x3D; \mathcal{L}(E)\cdot\mathcal{L}(W)\newline<br>\hspace{1cm} \ \ \text{where } L_1 \cdot L_2&#x3D;\lbrace \omega\alpha\mid\omega\in L_1,\alpha\in L_2\rbrace \text{ for } L_1 \subseteq\Sigma^*, L_2 \subseteq\Sigma^\omega\newline<br>\hspace{1cm} \cdot \ \text{If $W_1$ and $W_2$ are $\omega$-regular expressions, then $W_1+W_2$ is an $\omega$-regular expression:}\newline<br>\hspace{1cm} \ \ \mathcal{L}(W_1+W_2) &#x3D; \mathcal{L}(W_1)\cup\mathcal{L}(W_2) .\newline<br>\end{array}$</p>
</blockquote>
<p>A language over infinite words is $\omega$-regular if it is definable by a $\omega$-regular expression.</p>
<hr>
<p>Next chapter: <a href="../agv3-3/">Closure Properties of the Büchi-recognizable languages (Intersection and Union)</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Omega_language">Omega language</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Omega-regular_language">Omega Regular language</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-13T12:36:30.000Z" title="13/11/2024, 13:36:30">2024-11-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.411Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 750 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-1/">AGV 3.1 -- Kleene&#039;s Theorem</a></p><div class="content"><p>Previous chapter: <a href="../agv2-3/">The Büchi Acceptance Condition</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><em>Kleene’s theorem</em> states that the <em>set of languages over finite words</em> that can be defined by <strong>regular expressions</strong> is exactly the set of languages that can be recognized by <strong>automata over finite words</strong>.</p>
<p>Based on this, we define $\omega$-regular expressions, and finally prove the corresponding theorem for $\omega$-regular languages: <strong>Büchi’s characterization theorem</strong>.</p>
<h2 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h2><p>Regular expression consist of <strong>constants</strong> that denote languages of <em>finite words</em>, and<br>consist of <strong>operator symbols</strong> that denote <em>operations over these languages</em>.</p>
<p>The collection of regular languages over an alphabet $\Sigma$ is $\mathcal{L}(E)$, where $E$ is a regular expression.<br>Regular expression can be defined as $E :&#x3D; \varepsilon\mid\varnothing\mid a\in\Sigma\mid E+F\mid E\cdot F\mid E^* $, where:</p>
<ul>
<li><strong>empty language</strong>: $\varepsilon$,</li>
<li><strong>empty string language</strong>: $\varnothing$,</li>
<li><strong>singleton language</strong>: (single letter from alphabet) $a\in\Sigma$,</li>
<li><strong>union</strong> of regular languages: $E+F$,</li>
<li><strong>concatenation</strong> of regular languages: $E\cdot F$, and</li>
<li>language with <strong>kleene star</strong>: $E^*$.</li>
</ul>
<blockquote>
<p>$\textbf{Definition 3.1. } \textit{Regular expressions } \text{are defined as follows:}$<br>$\begin{array}{l}\hspace{1cm} \cdot \ \text{The constants }\varepsilon\text{ and }\varnothing\text{ are regular expressions.}\newline<br>\hspace{1cm} \ \ \mathcal{L}(\varepsilon) &#x3D; \lbrace\varepsilon\rbrace ,\mathcal{L}(\varnothing)&#x3D;\varnothing.\newline<br>\hspace{1cm} \cdot \ \text{If }a\in\Sigma\text{ is a symbol, then }a\text{ is a regular expressions.}\newline<br>\hspace{1cm} \ \ \mathcal{L}(a) &#x3D; \lbrace a\rbrace .\newline<br>\hspace{1cm} \cdot \ \text{If }E\text{ and }F\text{ are regular expressions, then }E+F\text{ is a regular expression:}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E+F) &#x3D; \mathcal{L}(E)\cup\mathcal{L}(F) .\newline<br>\hspace{1cm} \cdot \ \text{If }E\text{ and }F\text{ are regular expressions, then }E\cdot F\text{ is a regular expression:}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E\cdot F) &#x3D; \lbrace uv\mid u\in\mathcal{L}(E),v\in\mathcal{L}(F)\rbrace.\newline<br>\hspace{1cm} \cdot \ \text{If }E\text{ is a regular expression, then }E^*\text{ is a regular expression.}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E^{\ast}) &#x3D; \lbrace u_1u_2\dots u_n\mid n\in\mathbb{N},u_i\in\mathcal{L}(E)\text{ for all }0\leq i\leq n\rbrace.\end{array}$</p>
</blockquote>
<h2 id="Kleene’s-Theorem"><a href="#Kleene’s-Theorem" class="headerlink" title="Kleene’s Theorem"></a>Kleene’s Theorem</h2><p><em>A language over finite words</em> is <strong>regular</strong> if it is definable by a <em>regular expression</em>, or<br>if it is recognized by <em>automata over finite words</em>.</p>
<blockquote>
<p>$\textbf{Definition 3.2. } \text{An }\textit{automaton on finite words } \mathcal{A}\text{ is a tuple } (\Sigma,Q,I,T,F), \text{ where }\Sigma\text{ is an input} \newline \text{alphabet, }Q\text{ is a nonempty finite set of states, }I\in Q\text{ is a set of initial states, }\Delta\subseteq Q\times\Sigma\times Q\text{ is}\newline\text{a set of transitions, and }F\subseteq Q\text{ are a set of finite states.}$</p>
</blockquote>
<h3 id="Mathematical-Definition"><a href="#Mathematical-Definition" class="headerlink" title="Mathematical Definition"></a>Mathematical Definition</h3><p>An automaton $\mathcal{A}$ accepts a finite word $w \in\Sigma^*$ if there is a finite sequence of states $q(0)q(1) . . . q(|w|)$ such that $q(0)\in I$ and $(q(i),w(i), q(i + 1))\in\Delta$ for all $i &lt; |w|$ and with $q(|w|)\in F$</p>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>In a nutshell, a finite word $w$ is <strong>accepted</strong> by an automaton $\mathcal{A} &#x3D; (\Sigma,Q,I,T,F)$ if:</p>
<table>
<thead>
<tr>
<th align="left">Notation</th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$\Sigma$</td>
<td align="left">$w$ is a finite word in $\Sigma$</td>
</tr>
<tr>
<td align="left">$Q$</td>
<td align="left">There exists a finite sequence of states $q(0)q(1) . . . q(|w|)$</td>
</tr>
<tr>
<td align="left">$I$</td>
<td align="left">In such sequence, $q(0)$ is one of the initial state $I$</td>
</tr>
<tr>
<td align="left">$T$</td>
<td align="left">In such sequence, there is transition from $q(i)$ to $q(i+1)$ for each letter $w(i)$, where $i&lt;|w|$</td>
</tr>
<tr>
<td align="left">$F$</td>
<td align="left">In such sequence, $q(|w|)$ is one of the final state $F$, and it will be the last state of the run since there is no more letters</td>
</tr>
</tbody></table>
<h3 id="From-accepted-word-to-accepted-language"><a href="#From-accepted-word-to-accepted-language" class="headerlink" title="From accepted word to accepted language"></a>From accepted word to accepted language</h3><p>The set of all words accepted by $\mathcal{A}$ is called the <strong>language</strong> of $\mathcal{A}$, denoted by $\mathcal{L}(\mathcal{A})$.</p>
<blockquote>
<p>$\textbf{Theorem 3.1. } \text{(Kleene’s Theorem)}\newline\textit{A language is regular iff it is recognized by some finite word automaton.}$</p>
</blockquote>
<hr>
<p>Next post: <a href="../agv3-2/">$\omega$-regular language</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Regular_expression">Regular expression</a>,<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Regular_language">Regular language</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kleene_star#:~:text=The%20Kleene%20star%20is%20defined,x%E2%8B%85y%20%E2%88%88%20S*.">Kleene star</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-12T04:56:26.000Z" title="12/11/2024, 05:56:26">2024-11-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.426Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 723 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv2-3/">AGV 2.3 -- The Büchi Acceptance Condition</a></p><div class="content"><p>Previous chapter: <a href="../agv2-2/">Automata over Infinite Words</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="2-3-The-Buchi-Acceptance-Condition"><a href="#2-3-The-Buchi-Acceptance-Condition" class="headerlink" title="2.3 The Büchi Acceptance Condition"></a>2.3 The Büchi Acceptance Condition</h2><p>The Büchi Acceptance Condition is given as a set of <strong>accepting states</strong> $F$.<br>A run of a Büchi automaton is accepting if <strong>some state from this set occurs infinitely often</strong>.</p>
<p><a name="inf"></a></p>
<h3 id="Infinite-word"><a href="#Infinite-word" class="headerlink" title="Infinite word"></a>Infinite word</h3><p>For an infinite word $\alpha$ over $\Sigma$, an <strong>Infinity Set</strong> of $\alpha$ is denoted as:<br>$$\text{Inf}(\alpha) &#x3D; \lbrace\sigma\in\Sigma\mid\forall m\in\mathbb{N}.\exists n\in\mathbb{N}.n\geq m \text{ and } \alpha(n)&#x3D;\sigma\rbrace$$</p>
<p>Meaning that $\text{Inf}(\alpha)$ is a set of all letters $\sigma$ from the alphabet $\Sigma$, so that<br>for all $m$, you can always find $\sigma$ as the n-th letter of $\alpha$ when there exists an $n$ where $n\geq m$.</p>
<p>This denotes the set of all letters of $\Sigma$ that occur <strong>infinitely often</strong> in $\alpha$.</p>
<h3 id="Buchi-Condition"><a href="#Buchi-Condition" class="headerlink" title="Büchi Condition"></a>Büchi Condition</h3><p>To express the meaning of “some state from the set of <em>accepting states</em> is reached <strong>infinitely often</strong>“, we can rewrite our accpeing condition $Acc$ into Büchi Condition $\small\text{BÜCHI} \normalsize(F)$. Here, $\small\text{BÜCHI} \normalsize(F)$ is a set of <em>infinite word</em>:</p>
<blockquote>
<p>$\textbf{Definition 2.4. } \text{ The } \textit{Büchi Condition } \small\text{BÜCHI} \normalsize(F)\text{ on a set of states }F\subseteq Q\text{ is the set}$</p>
<p>$$\small\text{BÜCHI} \normalsize(F) &#x3D; \lbrace\alpha\in Q^\omega \mid \text{Inf}(\alpha) \cap F \neq \varnothing\rbrace$$</p>
<p>$\text{An automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,Acc)\text{ with }Acc&#x3D;\small\text{BÜCHI} \normalsize(F)\text{ is called a }\textit{Büchi automaton.}\newline \text{The set }F\text{ is called the }\textit{set of accepting states.}$</p>
</blockquote>
<h2 id="Constrcution-of-Complete-Buchi-Automaton"><a href="#Constrcution-of-Complete-Buchi-Automaton" class="headerlink" title="Constrcution of Complete Büchi Automaton"></a>Constrcution of Complete Büchi Automaton</h2><blockquote>
<p>$\textbf{Theorem 2.1. } \textit{For every Büchi Automaton }\mathcal{A},\text{ there is a complete Büchi Automaton }\mathcal{A}’ \newline \textit{such that }\mathcal{L}(\mathcal{A}) &#x3D; \mathcal{L}(\mathcal{A}’)$</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Let $\mathcal{A}$ be the automaton from <a href="../agv2-2/#eg1">Example 2.1</a> with Büchi acceptance condition $\small\text{BÜCHI}\normalsize (\lbrace D\rbrace)$. The language of the automaton consists of a single word:<br>$$\mathcal{L}(\mathcal{A})&#x3D;\lbrace aabbaabbaabb\dots\rbrace$$</p>
<p>For a Büchi Automaton $\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))$,<br>we define the <strong>complete</strong> Büchi Automaton $\mathcal{A’} &#x3D; (\Sigma,Q’,I’,T’,\small\text{BÜCHI} \normalsize (F’))$ using:</p>
<ul>
<li>$Q’$ &#x3D; $Q \cup \lbrace q_f\rbrace$ where $q_f$ is a fresh state</li>
<li>$I’$ &#x3D; $I$</li>
<li>$T’$ &#x3D; $T \cup \lbrace (q,\sigma,q_f) \mid \nexists q’ . (q,\sigma,q’)\in T\rbrace\cup\lbrace (q_f,\sigma,q_f)\mid\sigma\in\Sigma\rbrace$</li>
<li>$F’$ &#x3D; $F$</li>
</ul>
<p><img src="/images/notes/uds/agv/2_3_eg.png"></p>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>First, we add a <strong>fresh state</strong> $q_f$ the <em>set of state</em> $Q$ without changing the <em>initial</em> and <em>accepting</em> states.</p>
<p>A <em>complete Büchi Automaton</em> requires every states must have transitions for every letters in the alphabet.<br>So for each states orginally in $Q$, we construct new transitions that the letters are not yet used by the state.<br>(which is $\nexists q’ . (q,\sigma,q’)\in T$)</p>
<p>Finally, for all transitions from the fresh state are self transitioning, and they include all letters.<br>(which is $(q_f,\sigma,q_f)\mid\sigma\in\Sigma$)</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><ul>
<li><p>The runs of $\mathcal{A’}$ are a <strong>superset</strong> of those of $\mathcal{A}$.</p>
<ul>
<li>During the construction of $\mathcal{A’}$, we have not removed any original transitions, but adding new fresh states.</li>
</ul>
</li>
<li><p>Furthermore, on <strong>any infinite input word</strong>, the accepting runs of $\mathcal{A}$ and $\mathcal{A’}$ are the same.</p>
<ul>
<li>If $\mathcal{A}$ accepts, $\mathcal{A’}$ also accepts because $\mathcal{A’}$ is a superset.</li>
<li>If a run reaches new fresh states $q_f$ stays in $q_f$ forever, and</li>
<li>since $q_f\notin F’$, such a run is not accepting.</li>
</ul>
</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>A <em>complete deterministic automaton</em> may be viewed as a <strong>total function</strong> from $\Sigma^\omega$ to $Q^\omega$.<br>A <em>complete (possibly nondeterministic) automaton</em> produces <strong>at least one run for every input word</strong>.</p>
<hr>
<p>Next chapter: <a href="../agv3-1/">Kleene’s Theorem</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Omega_language">Omega language</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-11T03:24:02.000Z" title="11/11/2024, 04:24:02">2024-11-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.411Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">4 minutes read (About 634 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv2-2/">AGV 2.2 -- Automata over Infinite Words</a></p><div class="content"><p>Previous chapter: <a href="../agv2-1/">Büchi automata (Preliminaries)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="2-2-Automata-over-Infinite-Words"><a href="#2-2-Automata-over-Infinite-Words" class="headerlink" title="2.2 Automata over Infinite Words"></a>2.2 Automata over Infinite Words</h2><p>The operational behavior of an automaton over infinite words is very similar to automaton over finite words:</p>
<ol>
<li>Start with an <em>initial state</em></li>
<li>Automaton constructs a <strong>run</strong> by reading one letter of the input alphabet at a time, and<br>transitioning to a successor <em>state</em> permitted by its <em>transitions</em>.</li>
</ol>
<p>The major difference between automata over finite and infinite words is the <strong>acceptance condition</strong>.</p>
<blockquote>
<p>$\textbf{Definition 2.1. } \text{ An } \textit{automaton over infinite words } \text{is a tuple }\mathcal{A} &#x3D; (\Sigma,Q,I,T,Acc)\text{, where}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ \Sigma \text{ is a finite } \textit{alphabet} \newline<br>\hspace{1cm} \cdot \ Q \text{ is a finite set of } \textit{states} \newline<br>\hspace{1cm} \cdot \ I \subseteq Q \text{ is a subset of } \textit{initial states} \newline<br>\hspace{1cm} \cdot \ T \subseteq Q \times \Sigma \times Q \text{ is a set of } \textit{transitions} \text{, and} \newline<br>\hspace{1cm} \cdot \ Acc \subseteq Q^\omega \text{ is the } \textit{accepting condition}<br>\end{array}$</p>
</blockquote>
<p>In the following, we refer an automaton over infinite words simply as an automaton.</p>
<h3 id="Runs-of-Buchi-automata"><a href="#Runs-of-Buchi-automata" class="headerlink" title="Runs of Büchi automata"></a>Runs of Büchi automata</h3><p>A run in a Büchi automaton has to transition infinitely many times, and starts with the initial state.</p>
<blockquote>
<p>$\textbf{Definition 2.2. }\text{ An }\textit{run }\text{of an automaton }\mathcal{A}\text{ on an infinite input word }\alpha\text{ is an }\newline\text{infinite sequence of states }r&#x3D;r(0)r(1)r(2)\dots\text{ such that the following hold:}\newline\begin{array}{l}\hspace{1cm} \cdot \ r(0)\in I\newline\hspace{1cm} \cdot \ \text{for all }i\in\mathbb{N},(r(i),\alpha(i),r(i+1))\in T\end{array}$</p>
</blockquote>
<p><a name="eg1"></a></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Below is a graphical representation of an automation over:</p>
<ul>
<li>alphabet $\Sigma &#x3D; \lbrace a,b\rbrace$, and with</li>
<li>set of states $Q &#x3D;\lbrace A,B,C,D\rbrace$,</li>
<li>initial set of states $I &#x3D;\lbrace A\rbrace$, and</li>
<li>set of transitions $T &#x3D;\lbrace (A,a,B),(B,a,C),(C,b,D),(D,b,A)\rbrace$</li>
</ul>
<p><img src="/images/notes/uds/agv/2_1_eg.png"></p>
<p>On the infinite input word $aabbaabb\dots$, the (only) run of the automaton is $ABCDABCDABCD\dots$</p>
<h2 id="Deterministic-and-Complete-Automaton"><a href="#Deterministic-and-Complete-Automaton" class="headerlink" title="Deterministic and Complete Automaton"></a>Deterministic and Complete Automaton</h2><p>An automaton is <strong>deterministic</strong> if $|I|\leq 1$ and $\mid\lbrace (q,\sigma,q’)\in T \mid q’\in Q\rbrace|\leq 1$ for every $q\in Q$ and $\sigma\in\Sigma$.<br>Meaning that the automaton has <strong>exactly 1</strong> <em>initial state</em>, and <strong>exactly 1</strong> <em>transition</em> from $q$ to $q’$</p>
<p>An automaton is <strong>complete</strong> if $\mid\lbrace (q,\sigma,q’)\in T \mid q’\in Q\rbrace|\geq 1$ for every $q\in Q$.<br>Meaning that any two states $(q,q’)$ in the automaton should have <strong>at least 1</strong> transitions from $q$ to $q’$.</p>
<p>Therefore, the automaton in the example above is deterministic but not complete.</p>
<p>The transitions of an <em>deterministic and complete automata</em> are usually given as a function $\delta:Q \times\Sigma\rightarrow Q$.<br>Meaning that the set of all transitions $\delta$ contains <strong>any states</strong> with <strong>any letter</strong>.</p>
<h2 id="Accepted-Run"><a href="#Accepted-Run" class="headerlink" title="Accepted Run"></a>Accepted Run</h2><blockquote>
<p>$\textbf{Definition 2.3. } \text{ An automaton } \mathcal{A} \textit{ accepts}\text{ an infinite word }\alpha\text{ if: }$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ \text{there is a run }r\text{ of }\mathcal{A}\text{ on }\alpha\text{, and}\newline<br>\hspace{1cm} \cdot \ r \text{ is } \textit{accepting}:r\in Acc\end{array}\newline<br>\text{The } \textit{language recognized }\text{by }\mathcal{A}\text{ is defined as follows: }<br>\mathcal{L}(\mathcal{A}) &#x3D; \lbrace \alpha\in\Sigma^\omega\mid\mathcal{A}\text{ accepts }\alpha\rbrace$</p>
</blockquote>
<p>We say two automata are <strong>equivalent</strong> if they have the same language.</p>
<hr>
<p>Next chapter: <a href="../agv2-3/"></a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Omega_language">Omega language</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-10T03:24:02.000Z" title="10/11/2024, 04:24:02">2024-11-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.436Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">2 minutes read (About 238 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv2-1/">AGV 2.1 -- Büchi automata (Preliminaries)</a></p><div class="content"><p>Previous chapter: <a href="../agv1-3/">The Logic-Automata Connection</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="2-1-Preliminaries"><a href="#2-1-Preliminaries" class="headerlink" title="2.1 Preliminaries"></a>2.1 Preliminaries</h2><table>
<thead>
<tr>
<th align="left">Basic math notations</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Natural numbers</td>
<td align="left">$\mathbb{N} &#x3D; \lbrace 0,1,2,3\dots\rbrace$</td>
</tr>
<tr>
<td align="left">Positive Natural numbers</td>
<td align="left">$\mathbb{N}^+ &#x3D; \lbrace 1,2,3\dots\rbrace$</td>
</tr>
<tr>
<td align="left">Numbers from $n$ to $m$</td>
<td align="left">$[n,m] &#x3D; \lbrace n,n+1,\dots,m\rbrace$ For $n,m\in \mathbb{N}$ with $n\leq m$</td>
</tr>
<tr>
<td align="left">Numbers from $0$ to $m$</td>
<td align="left">$[m] &#x3D; \lbrace 0,1,\dots,m\rbrace$</td>
</tr>
</tbody></table>
<p>$$$$</p>
<table>
<thead>
<tr>
<th align="left">Alphabet and Letter</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Alphabet</strong></td>
<td align="left">a nonempty, finite set of symbols, usually denoted by $\Sigma$</td>
</tr>
<tr>
<td align="left"><strong>Letter</strong></td>
<td align="left">elements of an <em>alphabets</em>, denoted by $\sigma$</td>
</tr>
</tbody></table>
<p>$$$$</p>
<table>
<thead>
<tr>
<th align="left">Finite and Infinite Word</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Finite Words</strong></td>
<td align="left">concatenation $w&#x3D;w(0)w(1)\dots w(n-1)$ of <br/> <em>finitely many letters</em> of $\Sigma$</td>
</tr>
<tr>
<td align="left"><strong>Infinite Words</strong></td>
<td align="left">$\alpha$ (will be explained in <a href="../agv2-3/#inf">chapter 2.3</a></td>
</tr>
<tr>
<td align="left"><strong>$n$-th letter</strong> of word $w$</td>
<td align="left">$w(n)$ for each $n\in [|w| - 1]$</td>
</tr>
<tr>
<td align="left"><strong>Length</strong> of words $w$</td>
<td align="left">$|w|$</td>
</tr>
<tr>
<td align="left">set of all <strong>finite words</strong></td>
<td align="left">\Sigma^*$</td>
</tr>
<tr>
<td align="left"><strong>Infinite Words</strong></td>
<td align="left">$\alpha$ (will be explained in <a href="../agv2-3/#inf">chapter 2.3</a></td>
</tr>
<tr>
<td align="left">set of all <strong>non-empty finite words</strong></td>
<td align="left">$\Sigma^+ &#x3D; \Sigma^* \backslash \lbrace \epsilon \rbrace$</td>
</tr>
<tr>
<td align="left">set of all <strong>infinite words</strong></td>
<td align="left">$\Sigma^\omega$</td>
</tr>
</tbody></table>
<p>$$$$</p>
<table>
<thead>
<tr>
<th align="left">Language</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left">language over <strong>finite words</strong> ($\omega$<strong>-language</strong>)</td>
<td align="left">each subset of $\Sigma^*$</td>
</tr>
<tr>
<td align="left">language over <strong>infinite words</strong> ($\omega$<strong>-language</strong>)</td>
<td align="left">each subset of $\Sigma^\omega$</td>
</tr>
</tbody></table>
<hr>
<p>Next chapter: <a href="../agv2-2/">Automata over Infinite Words</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Omega_language">Omega language</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-08T06:04:01.000Z" title="08/11/2024, 07:04:01">2024-11-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.441Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 398 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv1-3/">AGV 1.3 -- The Logic-Automata Connection</a></p><div class="content"><p>Previous chapter: <a href="../agv1-2/">Synthesis</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Verification-or-Synthesis"><a href="#Verification-or-Synthesis" class="headerlink" title="Verification or Synthesis"></a>Verification or Synthesis</h2><p>In applications like <a href="../agv1-1/">verification</a> and <a href="../agv1-2/">synthesis</a>, the automata- and game-theoretic machinery is usually “hidden” behind a logical formulation of the problem.</p>
<p><img src="/images/notes/uds/agv/1_3_logic.png"></p>
<h3 id="Logics-with-corresponding-Automata"><a href="#Logics-with-corresponding-Automata" class="headerlink" title="Logics with corresponding Automata"></a>Logics with corresponding Automata</h3><blockquote>
<p><strong>S1S</strong>‘s expressiveness exceeds that of <strong>LTL</strong>, and<br><strong>S2S</strong>‘s expressiveness exceeds that of <strong>CTL*</strong> (on binary trees)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Logic</th>
<th align="left">Usage</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Linear-time temporal logic (LTL)</strong></td>
<td align="left">sets of infinite <strong>words</strong></td>
<td align="left">$\square \Diamond \ell_1$</td>
</tr>
<tr>
<td align="left"><strong>Computation-tree logic (CTL &#x2F; CTL*)</strong></td>
<td align="left">sets of infinite <strong>trees</strong></td>
<td align="left">$\textsf{EF}\ell_1 \wedge \textsf{EF}m_1$</td>
</tr>
<tr>
<td align="left"><strong>Monadic second-order logic with one successor (S1S)</strong></td>
<td align="left">logic over infinite <strong>words</strong></td>
<td align="left">$\forall x . x \in P \rightarrow S(x) \in P$</td>
</tr>
<tr>
<td align="left"><strong>Monadic second-order logic with two successors (S2S)</strong></td>
<td align="left">logic over infinite <strong>binary trees</strong></td>
<td align="left">$\forall x . x \in P \rightarrow S_1(x) \in P \vee S_2(x) \in P$</td>
</tr>
</tbody></table>
<h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><ul>
<li>$\square \Diamond \ell_1$<br>$P_0$ is infinitely often at location $\ell_1$.</li>
<li>$\textsf{EF}\ell_1 \wedge \textsf{EF}m_1$<br>There exists a computation path in which $P_0$ reaches location $\ell_1$, and<br>there is a (possibly different) computation path in which $P_1$ reaches location $m_1$.</li>
<li>$\forall x . x \in P \rightarrow S(x) \in P$<br>A (given) set of natural numbers $P$ is either empty, or<br>consists of all positions starting from some position of the word.</li>
<li>$\forall x . x \in P \rightarrow S_1(x) \in P \vee S_2(x) \in P$<br>A (given) set of nodes $P$ contains from each node $n \in P$ an entire path starting in $n$.</li>
</ul>
<p>For example, <strong>mutual exclusion</strong> property can be expressed using <strong>linear-time temporal logic (LTL)</strong>:<br>$$\square \neg (\ell_1 \wedge m_1)$$</p>
<h2 id="Satisfiability-problem"><a href="#Satisfiability-problem" class="headerlink" title="Satisfiability problem"></a>Satisfiability problem</h2><p>Other than verification and synthesis, another important application of the connection between logic and automata is to decide the <em>satisfiability</em> problem of the various logics.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>We want to know if there exist two natural numbers $x$ and $y$ such that $x&#x3D;y+1$ and $y&#x3D;x+1$.<br>This can be expressed as the <strong>S1S</strong> formula $x&#x3D;S(y) \wedge y&#x3D;S(x)$, translate each conjunct into an automaton:</p>
<p><img src="/images/notes/uds/agv/1_3_automaton.png"></p>
<p><strong>Alphabet</strong>: subsets of $\lbrace x,y\rbrace$.</p>
<p>There does not exist a word that is accepted by both automaton. Hence, the formula is unsatisfiable.</p>
<hr>
<p>Next chapter: <a href="../agv2-1/">Büchi automata (Preliminaries)</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-07T04:56:37.000Z" title="07/11/2024, 05:56:37">2024-11-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.405Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">2 minutes read (About 315 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv1-2/">AGV 1.2 -- Synthesis</a></p><div class="content"><p>Previous chapter: <a href="../agv1-1/">Model Checking</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Synthesis"><a href="#Synthesis" class="headerlink" title="Synthesis"></a>Synthesis</h2><p>In synthesis, we check automatically if there <em>exists</em> a program that satisfies a given specification.</p>
<p>If the answer is yes, we construct such a program.</p>
<p>We solve it by determine the winner of a <strong>two-player game</strong> between a <em>system player</em> and an <em>environment player</em>.</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Task</th>
<th align="left">Goal</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>System player</strong></td>
<td align="left">choose the <strong>outputs</strong> of the system</td>
<td align="left"><strong>meet</strong> the specification</td>
</tr>
<tr>
<td align="left"><strong>Environment player</strong></td>
<td align="left">choose the <strong>inputs</strong> of the system</td>
<td align="left"><strong>falsify</strong> the specification</td>
</tr>
</tbody></table>
<p>Therefore, the specification is satisfied if the <strong>System player</strong> wins.<br>Such <strong>winning strategy</strong> can be translated into a program that is guaranteed to satisfy the specification.</p>
<h3 id="Example-coffee-machine"><a href="#Example-coffee-machine" class="headerlink" title="Example: coffee machine"></a>Example: coffee machine</h3><p>In this example, we assume there’s a machine that “outputs coffee” whenever users press a button.</p>
<p><strong>Set of</strong> $AP &#x3D; \lbrace bu, co\rbrace$, where input $AP_I &#x3D; \lbrace bu\rbrace$ and output $AP_O &#x3D; \lbrace co\rbrace$.</p>
<p><strong>Specification</strong>: $co$ should hold iff. $bu$ holds in every step.</p>
<p><img src="/images/notes/uds/agv/1_2_coffee.png"></p>
<p>From this automaton, we construct a <em><strong>game arena</strong></em> where in each round,</p>
<ol>
<li>Environment player chooses the input ($bu$ or $\neg bu$)</li>
<li>System player chooses the output ($co$ or $\neg co$)</li>
</ol>
<p>States of the game keep track of the corresponding state of the automaton,<br>then we can determine who is the winner for each possible play.</p>
<p><img src="/images/notes/uds/agv/1_2_game.png"></p>
<p>Here, system player gets to choose the next move with circles, and environment player choose with squares.</p>
<p>System player has a simple winning strategy from starting position $t_0$:</p>
<blockquote>
<p>react input $bu$ with output $co$, and react input $\neg bu$ with output $\neg co$</p>
</blockquote>
<p>In this way, the play visits $t_0$ infinitely often, which proves that it satisfies the specification.</p>
<hr>
<p>Next chapter: <a href="../agv1-3/">The Logic-Automata Connection</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Program_synthesis">Program synthesis</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-06T18:00:13.000Z" title="06/11/2024, 19:00:13">2024-11-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.441Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 477 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv1-1/">AGV 1.1 -- Model Checking</a></p><div class="content"><blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Model-Checking"><a href="#Model-Checking" class="headerlink" title="Model Checking"></a>Model Checking</h2><p>Given a <strong>system model</strong>, we try to check whether it meets its <strong>specification</strong> <em>automatically</em> and <em>exhaustively</em>.<br>To describe&#x2F;represent the <strong>system</strong> and <strong>specification</strong>, we use <strong>Automata over infinite objects</strong>.</p>
<h3 id="Verification-Problem"><a href="#Verification-Problem" class="headerlink" title="Verification Problem"></a>Verification Problem</h3><p>The verification problem can be solved by:</p>
<blockquote>
<p>Constructing the <strong>intersection</strong> of system, with an automaton for the <strong>negation of the specification</strong>,<br>then checking whether the language of the resulting automaton is <strong>empty</strong>.</p>
</blockquote>
<p>$\textbf{Example 1.1. } \text{Consider the concurrent program }\small{\text{TURN}}:$<br>$$\text{local $t$: boolean where initially $t$ &#x3D; $false$}\newline<br>P_0::\left[ \begin{array}{l}\text{loop forever do}\newline<br>\hspace{1cm}\left[ \begin{array}{l}<br>\ell_0: \text{await }\neg t; \newline<br>\ell_1: \text{critical;} \newline<br>\ell_2: t :&#x3D; true; \newline<br>\end{array} \right]\end{array} \right]<br>\mid\mid P_1::\left[ \begin{array}{l}<br>\text{loop forever do}\newline<br>\hspace{1cm}\left[ \begin{array}{l}<br>m_0: \text{await } t; \newline<br>m_1: \text{critical;} \newline<br>m_2: t :&#x3D; false; \newline<br>\end{array} \right]\end{array} \right]$$</p>
<p>The example above is a simple solution to the <strong>mutual exclusion problem</strong>:<br>it ensures that at any given point of time, <strong>at most one</strong> process is in the critical region.</p>
<h3 id="From-Program-to-automaton"><a href="#From-Program-to-automaton" class="headerlink" title="From Program to automaton"></a>From Program to automaton</h3><p>To represent the above program using automaton, we need to define an <strong>alphabet $\Sigma$</strong>.</p>
<p>Firstly, we fix a set of <strong>atomic propositions (AP)</strong>, that is (potentially) relevant to the program states.<br>For the program in $\small{\text{Example 1.1}}$, $AP &#x3D; \lbrace\ell_0,\ell_1,\ell_2,m_0,m_1,m_2,t\rbrace$.<br>i.e. The present program location and the current value of $t$.</p>
<p>Then, we define the <strong>alphabet</strong> as $\Sigma &#x3D; 2^{AP}$, the set of subsets of $AP$.<br>An $AP$ is included in the subset if it is currently $true$.</p>
<p><img src="/images/notes/uds/agv/1_1_turn.png"></p>
<p>This automaton is a <em><strong>safety automaton</strong></em>, it accepts all <strong>infinite repetitons</strong> of the sequence<br>$\lbrace\ell_0,m_0\rbrace \lbrace\ell_1,m_0\rbrace \lbrace\ell_2,m_0\rbrace \lbrace\ell_0,m_0,t\rbrace \lbrace\ell_0,m_2,t\rbrace$</p>
<h2 id="Automata-Verification"><a href="#Automata-Verification" class="headerlink" title="Automata Verification"></a>Automata Verification</h2><p>To verify $\small{\text{TURN}}$ satisfies the <strong>mutual exclusion</strong> property ($P_0$ and $P_1$ are never in $\ell_1$ and $m_1$ at the same time),<br>we build an automaton that <strong>represents the negation</strong> (eventually $P_0$ and $P_1$ are simultaneously in location 01):</p>
<p><img src="/images/notes/uds/agv/1_1_neg.png"></p>
<p>This automaton is a <em><strong>Büchi automaton</strong></em> with accepting state $t_1$.</p>
<p>A <strong>word</strong> is accepted if $t_1$ is visited <strong>infinitely often</strong>.</p>
<p>For every word accepted by the <em>system automaton</em>, this <em>property automaton</em> stays in $t_0$ forever and therefore does not accept the word.<br>This means there does not exist an infinite sequence that <strong>generated by the program</strong>, and<br><strong>accepted by the negation automaton</strong> of the specification. In other words, $\small{\text{TURN}}$ is <strong>correct</strong>.</p>
<hr>
<p>Next post: <a href="../agv1-2/">Synthesis</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/AGV/page/4/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/tags/AGV/page/6/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/AGV/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/tags/AGV/page/4/">4</a></li><li><a class="pagination-link is-current" href="/tags/AGV/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>