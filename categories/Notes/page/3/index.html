<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: Notes - GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li class="is-active"><a href="#" aria-current="page">Notes</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-06T04:42:27.000Z" title="06/12/2024, 05:42:27">2024-12-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1016 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-4/">AGV 8.4 -- Homogenous Inequality Testing is Automatic</a></p><div class="content"><p>Previous chapter: <a href="../agv8-3/">Translation from Linear Arithmetic to Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the previous <a href="../agv8-3/">section</a>, we used $x+y&#x3D;z$ as an example. By extend that into a more general inequality</p>
<p>$$g_1x_1+\dots+g_\ell x_\ell\leq h_1y_1+\dots +h_my_m$$</p>
<p>where $x_1,\dots,x_\ell,y_1,\dots,y_m$ are <strong>free variables</strong>, and $g_1,\dots,g_\ell,h_1,\dots,h_m$ are <strong>positive integer constants</strong>. Such inequality can be described by a Büchi automaton.</p>
<blockquote>
<p>$\textbf{Lemma 8.1. }\textit{Let }\lbrace x_1,\dots,x_\ell,y_1,\dots,y_m\textit{ be a set of free variables, and let }g_1,\dots,g_\ell,h_1,\dots,h_m\newline\textit{be positive integer constants. There exists a Büchi automaton }\mathcal{A}\textit{ such that}$</p>
<p>$$\mathcal{L(A)}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models g_1x_1+\dots+g_\ell g_\ell\leq h_1 y_1+\dots+h_m y_m\rbrace$$</p>
</blockquote>
<p>It is easy to start with constructing an automaton $\mathcal{A}_{\textsf{valid},\ell+m}$ that checks whether the word $\alpha_\sigma$ is <em>well-formed</em>:</p>
<ol>
<li>checks that the separation symbol $({$},\dots,{$})$ occurs <strong>exactly once</strong>, and</li>
<li>the separation symbol does <strong>not</strong> appear at <strong>the beginning of the word</strong>.</li>
</ol>
<h3 id="A-Generalize-Example"><a href="#A-Generalize-Example" class="headerlink" title="A Generalize Example"></a>A Generalize Example</h3><ul>
<li><p>$D:\sum_{i}g_ix_i-\sum_{j}h_jy_j\leq0$, where $G&#x3D;\sum_{i}g_i$, and $H&#x3D;\sum_{j}h_j$. We define the  </p>
</li>
<li><p>$D_t$ &#x3D; <code>integer part</code>, $[D]_t$ &#x3D; <code>fractional part</code>, and observe that for all $t$:</p>
</li>
</ul>
<p>$$D_1&#x3D;-\sum_{i}g_ic_{x_{i},1}-(-\sum_{j}h_jc_{y_{j},1})&#x3D;\sum_{j}h_jc_{y_{j},1}-\sum_{i}g_ic_{x_{i},1},\newline D_{t+1}&#x3D;2D_t+\sum_{i}g_ic_{x_{i},t+1}-\sum_{j}h_jc_{y_{j},t+1},\newline -H\leq[D]_t\leq G.$$</p>
<p>The trichotomy is also completely analogous.</p>
<ul>
<li>If, for some $t$, we have $D_t&gt;H$, we have that $D&gt;0$, and the formula is violated.</li>
<li>If, for some $t$, we have $D_t&lt;−G$, we have that $D&lt;0$, and the formula is satisfied.</li>
<li>If, for all $t$, we have $−G\leq D_t\leq H$ we have that $D&#x3D;0$, and the formula is satisfied.</li>
</ul>
<p>Our automaton construction keeps track of $D_t$ using the recurrence above. Due to the trichotomy, we only need compute $D_t$ precisely as long as it is <strong>at least $−G$ and at most $H$</strong>.</p>
<p>Thus, we have 3 types of states in the automaton:</p>
<ol>
<li><em>initialization</em> state</li>
<li>Precise value states within $−G,\dots,0,\dots,H$ of $D_t$</li>
<li>trap states ($D_t$ has crossed $−G (−\infty)$ or $H (\infty)$)</li>
</ol>
<blockquote>
<p>$\textbf{Construction 8.1. } \text{Let }x_1,\dots,x_\ell,y_1,\dots,y_m\text{ be free variables, and let }g_1,\dots,g_\ell,\text{ and}\newline h_1,\dots,h_m,\text{ be positive integer constants with }\sum_{i}g_i&#x3D;G\text{ and }\sum_{j}h_j&#x3D;H\text{. We construct a}\newline\text{(deterministic) Büchi Automaton}\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize (F))\text{, such that}$</p>
<p>$$\mathcal{L(A)}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models g_1x_1+\dots+g_\ell g_\ell\leq h_1 y_1+\dots+h_m y_m\rbrace \hspace{1cm}\text{ as follows,}$$</p>
<p>$\begin{array}{l}\hspace{1cm} \cdot \ \Sigma&#x3D;\lbrace {$}^{l+m}\cup(\lbrace0,1\rbrace^\ell\times\lbrace0,1\rbrace^m)\rbrace\hspace{1cm}((\ell\text{+m)-fold Cartesian product)}\newline<br>\hspace{1cm} \cdot \ Q&#x3D;\lbrace\textsf{init},-\infty,-G,-G+1,\dots,-1,0,1,\dots,H,\infty\rbrace\newline<br>\hspace{1cm} \cdot \ I&#x3D;\lbrace\textsf{init}\rbrace\newline<br>\hspace{1cm} \cdot \ F&#x3D;\lbrace-\infty,-G,-G+1,\dots,-1,0,1,\dots,H\rbrace\newline<br>\hspace{1cm} \cdot \ T\text{ is defined as follows:}\newline<br>\hspace{1.5cm} 1. \ (\textsf{init},(c_{x_1},\dots,c_{y_m}),q’))\in T\text{ if and only if }q’\in\sum_{j}h_jc_{y_j}-\sum_{i}g_ic_{x_i}\newline<br>\hspace{1.5cm} 2. \ (q,({$}\dots{$}),q)\in T\text{ for all }q\in Q\setminus\lbrace\textsf{init}\rbrace,\newline<br>\hspace{1.5cm} 3. \ (q_\infty,c,q_\infty)\in T\text{ for all }c\in\Sigma,q_\infty\in\lbrace-\infty,\infty\rbrace,\newline<br>\hspace{1.5cm} 4. \ \text{For }q\in\lbrace-G,\dots,0,\dots,H\rbrace,(q,(c_{x_1},\dots,c_{y_m}),q’)\in T\text{ if and only if }q’&#x3D;\textsf{next}\text{, where}\newline<br>\end{array}$<br>$$\textsf{next}&#x3D;\left\lbrace\begin{array}{cll}<br>2q+\sum_{i}g_ic_{x_{i}}-\sum_{j}h_jc_{y_{j}}&amp;\text{if}&amp;-G\leq2q+\sum_{i}g_ic_{x_{i}}-\sum_{j}h_jc_{y_{j}}\leq H \newline<br>\infty&amp;\text{if}&amp;2q+\sum_{i}g_ic_{x_{i}}-\sum_{j}h_jc_{y_{j}}&gt; H \newline<br>-\infty&amp;\text{if}&amp;2q+\sum_{i}g_ic_{x_{i}}-\sum_{j}h_jc_{y_{j}} &lt;-G \end{array}\right.$$</p>
</blockquote>
<h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>All possible transitions are those the criterion we mentioned above (according to the numbering):</p>
<ol>
<li>$D_1&#x3D;\sum_{j}h_jc_{y_{j},1}-\sum_{i}g_ic_{x_{i},1}$</li>
<li>The separation symbol does <strong>not</strong> appear at <strong>the beginning of the word</strong>.</li>
<li>$D_t$ has crossed $−G (−\infty)$ or $H (\infty)$ move to <em>trap states</em> and cannot leave</li>
<li>According to the trichotomy, we only need compute $D_t$ precisely as long as it is $−G\leq D_t\leq H$.</li>
</ol>
<p>This completes the proof of Lemma 8.1. We remark that the same construction also works to check the following:</p>
<ul>
<li><strong>Strict Inequality:</strong> $g_1x_1+\dots+g_\ell x_\ell &lt; h_1y_1+\dots +h_my_m$ (by setting $F&#x3D;\lbrace−\infty\rbrace$),</li>
<li><strong>Equality:</strong> $g_1x_1+\dots+g_\ell x_\ell &#x3D; h_1y_1+\dots +h_my_m$ (by setting $F&#x3D;\lbrace−G,\dots,H\rbrace$),</li>
<li><strong>Reverse Inequality:</strong> $g_1x_1+\dots+g_\ell x_\ell \geq h_1y_1+\dots +h_my_m$ (by setting $F&#x3D;\lbrace−G,\dots,H,\infty\rbrace$),</li>
<li><strong>Reverse Strict Inequality:</strong> $g_1x_1+\dots+g_\ell x_\ell &gt; h_1y_1+\dots +h_my_m$ (by setting $\infty\rbrace$).</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv8-5/">From Linear Arithmetic to Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-05T02:53:30.000Z" title="05/12/2024, 03:53:30">2024-12-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1170 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-3/">AGV 8.3 -- Translation from Linear Arithmetic to Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv8-2/">Encoding real numbers</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>In this section, we will illustrate the key ideas in the translation from <strong>linear arithmetic</strong> to <strong>automata</strong> through a simple example.</p>
<p>Consider the formula $x+y&#x3D;z$ and the following encoding of the valuation $x\mapsto1$, $y\mapsto1$, $z\mapsto2$:</p>
<p>$$\alpha_\sigma&#x3D;\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}{$}\newline {$}\newline {$}\end{bmatrix}\left(\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\right)^\omega &#x3D; \begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D; \begin{bmatrix}1\newline 1\newline 2\end{bmatrix}$$</p>
<h3 id="Homogeneity"><a href="#Homogeneity" class="headerlink" title="Homogeneity"></a>Homogeneity</h3><p>A equation is <em>homogenous</em> if there are <strong>no constant terms</strong>. The key property of <strong>homogeneity</strong> is that we can simply scaling without being <strong>unbounded</strong>. In other words, for a <em>homogenous</em> equation $D$, we have:</p>
<blockquote>
<p>$D∼0$ (where $∼$ is an arbitrary (in)equality) <strong>if and only if</strong>, for all $k\in\mathbb{Z},2^k\cdot D∼0$. (Scaling behaviour)</p>
</blockquote>
<p>As we can see the equation $x+y&#x3D;z$ is <em>homogenous</em>, i.e., $D: x+y−z &#x3D; 0$ and $2^k\cdot x+2^k\cdot y−2^k\cdot z∼0$</p>
<p>We immediately observe that:</p>
<ul>
<li>$2^k\cdot D$ has <strong>constant sign</strong>,</li>
<li>If $D\neq0$, it is <strong>strictly increasing</strong> in $k$, and thus</li>
<li>For any threshold $N$, we will have that $|2^k\cdot D|&gt;N$ for all sufficiently large $k$.</li>
</ul>
<h3 id="Shifting-the-Delimiter"><a href="#Shifting-the-Delimiter" class="headerlink" title="Shifting the ${$}$ Delimiter"></a>Shifting the ${$}$ Delimiter</h3><p>The key observation is that multiplying by a power of $2$ &#x3D; shifting the ${$}$ delimiter in the binary representation.</p>
<p>$$\begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D;<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}{$}\newline{$}\newline{$}\end{bmatrix}<br>\left(\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\right)^\omega&#x3D;<br>\begin{bmatrix}1\newline 1\newline 2\end{bmatrix},\newline<br>\begin{bmatrix}2^2\cdot x\newline 2^2\cdot y\newline 2^2\cdot z\end{bmatrix} &#x3D;<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\begin{bmatrix}{$}\newline{$}\newline{$}\end{bmatrix}<br>\left(\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\right)^\omega&#x3D;<br>\begin{bmatrix}2^2\cdot 1\newline 2^2\cdot 1\newline 2^2\cdot 2\end{bmatrix}&#x3D;<br>\begin{bmatrix}4\newline 4\newline 8\end{bmatrix},<br>$$</p>
<p>For any variable $z$, and $t\geq1$, we denote by $z_t$ the integer encoded by the leftmost $t$ digits of $z$ (the ${$}$ is ignored):</p>
<p>$$\begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D;<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\dots$$</p>
<p>$<br>\begin{array}{lclc}<br>\hspace{1cm}\cdot\ x_5 &#x3D;&amp; -2^4\cdot0+2^3\cdot0+2^2\cdot0+2^1\cdot1+2^0\cdot1&amp;&#x3D;&amp;3\newline<br>\hspace{1cm}\cdot\ y_3 &#x3D;&amp; -2^2\cdot0+2^1\cdot0+2^0\cdot0&amp;&#x3D;&amp;0\newline<br>\hspace{1cm}\cdot\ z_4 &#x3D;&amp; -2^3\cdot0+2^2\cdot1+2^1\cdot0+2^1\cdot0&amp;&#x3D;&amp;4\newline<br>\hspace{1cm}\cdot\ z_5 &#x3D;&amp; -2^4\cdot0+2^3\cdot1+2^1\cdot0+2^2\cdot0+2^0\cdot0&amp;&#x3D;&amp;8\newline<br>\end{array}<br>$</p>
<h3 id="key-linear-recurrence"><a href="#key-linear-recurrence" class="headerlink" title="key linear recurrence"></a>key linear recurrence</h3><p>We can see the above definition is initialized as $z_1&#x3D;−c_{z,1}$, and <strong>key linear recurrence</strong> holds for any variable: $z_{t+1}&#x3D;2z_t+c_{z,t+1}$, where $c_{z,t+1}$ is the $(t+1)$-th digit from the left in the encoding of $z$.</p>
<p>Now, in our example we can define $D_t&#x3D;x_t+y_t−z_t$, and by <strong>linearity</strong>, the same recurrences hold for $D_t$, too:</p>
<p>$$D_1&#x3D;c_{z,1}-c_{x,1}-c_{y,1}\newline D_{t+1}&#x3D;2D_t+c_{z,t}-c_{x,t}-c_{y,t}$$</p>
<p>Thus, we have $D_1&#x3D;0,D_2&#x3D;−1,D_3&#x3D;−2$, and $D_t&#x3D;−2$ for subsequent $t$.</p>
<h3 id="Fractional-part"><a href="#Fractional-part" class="headerlink" title="Fractional part"></a>Fractional part</h3><p>To account for the digits other than the $t$ leftmost digits, we define the fractional part $\lbrack z\rbrack_t &#x3D; \sum_{i&#x3D;1}^{\infty}2^{-i}\cdot c_{z,t+i}$.</p>
<p>$$\begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D;<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\dots$$</p>
<p>$<br>\begin{array}{lclc}<br>\hspace{1cm}\cdot\ [x]_1 &#x3D;&amp; 2^{-1}\cdot0+2^{-2}\cdot0+2^{-3}\cdot1+2^{-4}\cdot1+\dots&amp;&#x3D;&amp;{1\over4}\newline<br>\hspace{1cm}\cdot\ [y]_2 &#x3D;&amp; 2^{-1}\cdot0+2^{-2}\cdot1+2^{-3}\cdot1+2^{-4}\cdot1+\dots&amp;&#x3D;&amp;{1\over2}\newline<br>\hspace{1cm}\cdot\ [z]_1 &#x3D;&amp; 2^{-1}\cdot1+2^{-2}\cdot0+2^{-3}\cdot0+\dots&amp;&#x3D;&amp;{1\over2}\newline<br>\hspace{1cm}\cdot\ [z]_3 &#x3D;&amp; 2^{-1}\cdot0+2^{-2}\cdot0+2^{-3}\cdot0+\dots&amp;&#x3D;&amp;0\newline<br>\end{array}<br>$</p>
<p>Here, we can see $0\leq[z]_t\leq1$, and that $z_t+[z]_t &#x3D; 2^k\cdot z$ for some $k\in\mathbb{Z}$.</p>
<blockquote>
<p>If the $2^k\cdot z$ doesn’t seem intuitive to you, check this out:<br>let say we have $z&#x3D;011{$}0111\dots &#x3D; 3+{1\over2}&#x3D;3.5$, and we set $t&#x3D;7$, so $z_7&#x3D;-2^6\cdot0+2^5\cdot1+2^4\cdot1+2^3\cdot0+2^2\cdot1+2^1\cdot1+2^0\cdot1&#x3D;55$ and $[z]_7&#x3D;{1\over2}+{1\over4}+{1\over8}+\cdots&#x3D;1$. Thus we have $z_7+[z]_7 &#x3D; 56 &#x3D; 2^4\cdot 3.5$.</p>
</blockquote>
<p>We can then extend the definition of fractional part to $D$ in the obvious way: $[D]_t &#x3D; [x]_t+[y]_t−[z]_t$.<br>We thus have that $−1\leq [D]_t\leq 2$, and that $D_t+[D]_t&#x3D;2^k\cdot D$ for some $k$.</p>
<ol>
<li><p>If $D_t&lt;−2$ for some $t$. then $D_t+[D]_t&lt;0$. For the corresponding $k$, we have that $2^k \cdot D&lt;0$. Therefore $x+y-z&lt;0$ and thus we conclude $x+y&lt;z$.</p>
</li>
<li><p>If $D_t&gt;1$ for some $t$, then $D_t+[D]_t&gt;0$. For the corresponding $k$, we have that $2^k \cdot D&gt;0$. Therefore $x+y-z&gt;0$ and thus we conclude $x+y&gt;z$.</p>
</li>
<li><p>If $−2\leq D_t\leq 1$ for all $t$, then $|D_t+[D]_t|\leq 3$. For arbitrarily large $k$, $|2^k\cdot D|\leq3$. This implies that $x+y&#x3D;z$ (only option left)</p>
</li>
</ol>
<h3 id="From-Linear-Arithmetic-to-Automaton"><a href="#From-Linear-Arithmetic-to-Automaton" class="headerlink" title="From Linear Arithmetic to Automaton"></a>From Linear Arithmetic to Automaton</h3><p>From the above deduction, $x+y&#x3D;z$ holds if and only if $−2\leq D_t\leq 1$. To check whether it holds with an automaton, we use the encoding to compute the sequence $D_t$ <em>term by term</em>, and <strong>accept</strong> if and only if each term is at least $−2$ and at most $1$.</p>
<p>Indeed, in our example, the sequence of terms is $0,−1,−2,−2,\dots$, and we accept.</p>
<p>As an example, we could also consider a different encoding of $x\mapsto1$, $y\mapsto1$, $z\mapsto2$:</p>
<p>$$\alpha’_\sigma&#x3D;\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 1\end{bmatrix}<br>\begin{bmatrix}{$}\newline {$}\newline {$}\end{bmatrix}\left(\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}\right)^\omega &#x3D; \begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D; \begin{bmatrix}1\newline 1\newline 2\end{bmatrix}$$</p>
<p>In this example the sequence of $D_t$ is $0, 1, 1, 1,\dots$, which is again bounded, and we accept.</p>
<p>On the other hand, a rejecting example may look like this:</p>
<p>$$\alpha_{\sigma’}&#x3D;\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}{$}\newline {$}\newline {$}\end{bmatrix}\left(\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\right)^\omega &#x3D; \begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D; \begin{bmatrix}1\newline 1\newline -2\end{bmatrix}$$</p>
<p>The sequence of $D_t$ is $1, 4, 8, 15,\dots$, which is out of bounded, and we reject.</p>
<hr>
<p>Next chapter: <a href="../agv8-4/">Homogenous Inequality Testing is Automatic</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-04T17:14:15.000Z" title="04/12/2024, 18:14:15">2024-12-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.419Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">4 minutes read (About 589 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-2/">AGV 8.2 -- Encoding Real Numbers</a></p><div class="content"><p>Previous chapter: <a href="../agv8-1/">Linear Arithmetic (Theory)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In last section, we have seen the definiton of Linera Arithmetic, which is similar to S1S. Let see how we can apply it in math and moreover, the connection between logic and automata.</p>
<h2 id="Encoding-Real-Numbers"><a href="#Encoding-Real-Numbers" class="headerlink" title="Encoding Real Numbers"></a>Encoding Real Numbers</h2><p>We can encode any real number $x\in\mathbb{R}$ into the form $(0+1)(0+1)^\ast{$}(0+1)^\omega$ in two steps:</p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>For a <em>real number</em> $x\in\mathbb{R}$, represent it as a pair $(x_I,x_F)$ so that $x&#x3D;x_I+x_F$.<br><strong>integer part</strong> &#x3D; $x_I\in\mathbb{Z}$, and <strong>fractional part</strong> &#x3D; $x_F\in[0, 1]$, a <em>real number</em> between $0$ and $1$ (both inclusive)</p>
<p>For example, the $1.5 &#x3D; (1, 0.5)$, and $-{2\over 3}&#x3D;(−1, {1\over3})$. Note that <strong>integers</strong> always have two different representations depends on setting the <strong>fractional part</strong> as $0$ or $1$, and <strong>Negative sign</strong> can only be represented using the integer part. For example $3&#x3D;(2,1)$ or $(3,0)$</p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>Then we can further encode $(x_I,x_F)$ as an <strong>infinite word</strong> $w_I{$}\beta_F$,<br>$x_I$ is encoded as $w_I&#x3D;a_na_{n−1}\dots a_0\in\lbrace 0,1\rbrace^\ast$, a <strong>finite nonempty word</strong>, and<br>$x_F$ is encoded as $\beta_F&#x3D;b_1b_2\dots\in\lbrace 0,1\rbrace^\omega$, an <strong>infinite word</strong> such that</p>
<p>$$x_I&#x3D;-a_n\cdot 2^n+  \sum_{i&#x3D;0}^{n-1}a_i\cdot 2^i<br>\hspace{2cm}\text{and}\hspace{2cm}<br>x_F&#x3D; \sum_{i&#x3D;1}^{\infty}b_i\cdot 2^{-i}$$</p>
<p>Note that now every pair has (infinitely) many different encodings because <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=CHbZvyvbu8I&ab_channel=Matt_Parker_2">digits are forever</a>:<br>for example, $(0,{1\over2})$ is encoded by all words in $0^\ast0{$}10^\omega &#x3D; {1\over2}+0+0+\dots$ and $0^\ast0{$}01^\omega&#x3D;0+{1\over4}+{1\over8}+\dots$.</p>
<p>As you may notice, we can always increase the length of the <strong>finite integer part</strong> by ‘padding’ arbitrary finitely long $0$ and $1$ on positive and negative number respectively. This is becasue of the following property of the <strong>geometric-series sum</strong>: for all $a$, $n$, $k$, we have that:</p>
<p>$$-a_n\cdot 2^n&#x3D;-a\cdot 2^{n+k}+  \sum_{j&#x3D;0}^{k}a\cdot 2^{n+j}$$</p>
<p>For example, $110{$}0^\omega&#x3D;-1\ast2^2+1\ast2^1&#x3D;-2$, $11110{$}0^\omega&#x3D;-1\ast2^4+1\ast2^3+1\ast2^2+1\ast2^1&#x3D;-2$,</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><table>
<thead>
<tr>
<th align="left">$x\in\mathbb{R}$</th>
<th align="left">$(x_I,x_F)$</th>
<th align="left">$w_I{$}\beta_F$</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$1$</td>
<td align="left">$(1, 0)$</td>
<td align="left">$0^\ast01{$}0^\omega$ and $0^\ast0{$}1^\omega$</td>
</tr>
<tr>
<td align="left">${4\over 3}$</td>
<td align="left">$(1, {1\over 3})$</td>
<td align="left">$0^\ast01{$}(01)^\omega$</td>
</tr>
<tr>
<td align="left">$-{3\over 2}$</td>
<td align="left">$(-2, {1\over 2})$</td>
<td align="left">$1^\ast10{$}10^\omega$</td>
</tr>
</tbody></table>
<p>$0^\ast&#x2F;1^\ast$ may be empty so make sure there is at least one $0$ or $1$ to ensure it is positive or negative, respectively.</p>
<h2 id="Encoding-Valuations-sigma-V’-rightarrow-mathbb-R"><a href="#Encoding-Valuations-sigma-V’-rightarrow-mathbb-R" class="headerlink" title="Encoding Valuations $\sigma:V’\rightarrow\mathbb{R}$"></a>Encoding Valuations $\sigma:V’\rightarrow\mathbb{R}$</h2><p>Assume there’s an arbitrary ordering of the <em>free</em> variables $V’&#x3D;\lbrace x_0,x_1,\dots,x_k\rbrace$. The valuation is then encoded as a word $\alpha_\sigma$ over the alphabet $\lbrace0,1\rbrace^k\cup\lbrace{$}\rbrace^k$. Each letter of the word $\alpha_\sigma$ is a tuple, where the $i$-th position indicates the encoding of $x_i$. Also, we ensure that the encodings of all $x_i$ synchronize on the separation symbol ${$}$</p>
<p>Continue the example, one possible encoding of the valuation $x_1\mapsto1$, $x_2\mapsto{4\over3}$, $x_3\mapsto-{3\over2}$ is the infinite word</p>
<p>$$\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\begin{bmatrix}{$}\newline {$}\newline {$}\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}\left(\begin{bmatrix}0\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\right)^\omega$$</p>
<p>In the next section, we will illustrate an example of translation from linear arithmetic to automata.</p>
<hr>
<p>Next chapter: <a href="../agv8-3/">Translation from Linear Arithmetic to Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-03T04:33:32.000Z" title="03/12/2024, 05:33:32">2024-12-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 481 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-1/">AGV 8.1 -- Linear Arithmetic (Theory)</a></p><div class="content"><p>Previous chapter: <a href="../agv7-3/">Translating Alternating to Nondeterministic automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the previous sections, we have seen that the automata machinery can be applied to logical problems by translating formulas into automata. We now study another application of the powerful connection between logic and automata, this time in the setting of real numbers.</p>
<h2 id="Theory-of-Linear-Arithmetic"><a href="#Theory-of-Linear-Arithmetic" class="headerlink" title="Theory of Linear Arithmetic"></a>Theory of Linear Arithmetic</h2><h3 id="Definitions-and-Semantics"><a href="#Definitions-and-Semantics" class="headerlink" title="Definitions and Semantics"></a>Definitions and Semantics</h3><p>Let $V$ be a set of <code>(first-order) variables</code>. The <strong>terms</strong> of linear arithmetic are defined by the following grammar:</p>
<p>$$t::&#x3D;0\mid1\mid x\mid t+t$$</p>
<p>The <strong>formulas</strong> of linear arithmetic are defined by the following grammar, where $x\in V$ is a variable:</p>
<p>$$\varphi::&#x3D;t\leq t\mid\neg\varphi\mid\varphi\wedge\varphi\mid\exists x.\varphi$$</p>
<p>Additionally, we allow the usual <strong>boolean connectives</strong> and introduce the following abbreviations:</p>
<p>$$\begin{array}{lrllllrll}<br>\cdot&amp;n&amp;:&#x3D;&amp;\overbrace{1+1+\dots+1}^{n\text{ times}},&amp;\hspace{2cm}&amp;\cdot&amp;nx&amp;:&#x3D;&amp;\overbrace{x+x+\dots+x}^{n\text{ times}},\newline<br>\cdot&amp;t\geq t’&amp;:&#x3D;&amp;t’\leq t,&amp;\hspace{2cm}&amp;\cdot&amp;t&lt;t’&amp;:&#x3D;&amp;t\leq t’\wedge\neg(t&#x3D;t’)\newline<br>\cdot&amp;t&#x3D;t’&amp;:&#x3D;&amp;t\leq t’\wedge t\geq t’,&amp;\hspace{2cm}&amp;\cdot&amp;t&gt;t’&amp;:&#x3D;&amp;t’&lt;t<br>\end{array}$$</p>
<p>The semantics of a formula is given relative to a valuation $\sigma:V\rightarrow\mathbb{R}$ that assigns to each variable a real number. The value of a term is then defined as follows:</p>
<p>$$\begin{array}{llll}<br>\hspace{1cm}\cdot\ \lbrack 0\rbrack_{\sigma} &#x3D; 0 &amp;<br>\hspace{1cm}\cdot\ \lbrack 1\rbrack_{\sigma} &#x3D; 1 &amp;<br>\hspace{1cm}\cdot\ \lbrack x\rbrack_{\sigma} &#x3D; \sigma(x) &amp;<br>\hspace{1cm}\cdot\ \lbrack t+u\rbrack_{\sigma} &#x3D;\lbrack t\rbrack_{\sigma}+\lbrack u\rbrack_{\sigma}\end{array}$$</p>
<p>$\models$ is the smallest relation that satisfies the following:</p>
<p>$$\begin{array}{lllllllllllll}<br>\cdot&amp;\sigma\models t\leq u&amp;\text{ iff }&amp;\lbrack t\rbrack_{\sigma}\leq\lbrack u\rbrack_{\sigma}\newline<br>\cdot&amp;\sigma\models\neg\varphi&amp;\text{ iff }&amp;\sigma\neg\models\varphi\newline<br>\cdot&amp;\sigma\models\varphi_0\wedge\varphi_1&amp;\text{ iff }&amp;\sigma\models\varphi_0\text{ and }\sigma\models\varphi_1\newline<br>\cdot&amp;\sigma\models\exists x.\varphi&amp;\text{ iff }&amp;\text{there is an }a\in\mathbb{R}\ \text{ s.t. }\ \sigma’\models\varphi\ \text{ and }\ \sigma’(y)&#x3D;\left\lbrace\begin{array}{cll}\sigma(y)&amp;\text{if}&amp;y\neq x\newline a&amp;\text{if}&amp;y&#x3D;x\end{array}\right.<br>\end{array}$$</p>
<p>Let $V’\subseteq V$ be the set of <strong>free</strong> variables occurring in the formula $\varphi$. The solutions of $\varphi$ are the set of all valuations $\sigma$ of $V’$ such that $\sigma\models\varphi$.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><table>
<thead>
<tr>
<th align="left"><strong>formula</strong></th>
<th align="left"><strong>Solution Space</strong></th>
<th align="left"><strong>Explaination</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">$x−1\geq1$</td>
<td align="left">$\lbrace x\mapsto a\in\mathbb{R}\mid a\geq2\rbrace$</td>
<td align="left">$x$ can be any real number, as long as it has to be larger than 2.</td>
</tr>
<tr>
<td align="left">$\exists y.\ x−1\geq y$</td>
<td align="left">$\lbrace x\mapsto a\mid a\in\mathbb{R}\rbrace$</td>
<td align="left">For any real number $y$, we can always find an $x$ that is larger than $y$ after minus 1.</td>
</tr>
</tbody></table>
<hr>
<p>Next chapter: <a href="../agv8-2/">Encoding real numbers</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-02T03:02:13.000Z" title="02/12/2024, 04:02:13">2024-12-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.419Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">17 minutes read (About 2561 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv7-3/">AGV 7.3 -- Translating Alternating to Nondeterministic automata</a></p><div class="content"><p>Previous chapter: <a href="../agv7-2/">From LTL to Alternating Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The translation from alternating to nondeterministic automata is based on a representation of runs as directed acyclic graphs (DAGs). The idea is similar to the DAG representation we used in the complementation construction for nondeterministic Büchi automata in <a href="../agv5-1/">Section 5</a>.</p>
<p>There the DAG was used to represent the <strong>set of all runs</strong> of the nondeterministic automaton. The complement automaton would then ”guess” the DAG level-by-level. Here, the DAG is used to represent the <strong>branches of a (single) run</strong> of the alternating automaton. The idea is illustrated in the following example.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/7_3_eg.png"></p>
<blockquote>
<p>$\textbf{Definition 7.5. } \text{ A } \textit{run DAG }\text{ of an alternating Büchi automaton }\mathcal{A}\text{ on an infinite word }\alpha\text{ is a}\newline\text{DAG }(V,E)\text{, with }V\subseteq Q\times\mathbb{N}\text{ and }(q_0,0)\in V\text{, where}$</p>
<p>$\begin{array}{ll} \hspace{0.5cm} \cdot &amp; E\subseteq \bigcup_{i\in\mathbb{N}}(Q\times\lbrace i\rbrace)\times(Q\times\lbrace i+1\rbrace) \newline \hspace{0.5cm} \cdot &amp; \forall(q,i)\in V \ . \ \exists Y\subseteq Q\text{ s.t. } \newline &amp; Y\models\delta(q,\alpha(i)),Y\times\lbrace i+1\rbrace\subseteq V\text{ and }\lbrace(q,i)\rbrace\times (Y\times\lbrace i+1\rbrace)\subseteq E.\end{array}$</p>
</blockquote>
<ul>
<li>Every vertices are expressed in (state, letter index)</li>
<li>Edges are all possible paths from current state $q$</li>
</ul>
<p>A run DAG is <strong>accepting</strong> if every infinite path has infinitely many visits to $F\times\mathbb{N}$.</p>
<p>Our construction of the nondeterministic automaton will be <strong>based on run DAGs</strong> rather than trees.<br>However, <strong>not every run tree can be represented as a DAG</strong>. This is illustrated by the following example:</p>
<h3 id="Example-cont"><a href="#Example-cont" class="headerlink" title="Example (cont.)"></a>Example (cont.)</h3><p>The following run tree cannot be represented as a DAG, because there are two nodes that are both labeled with $\mathbf{q}$ has different children (one transits to $p$ and the other to $q$). We say this tree has <strong>memory</strong>.</p>
<p><img src="/images/notes/uds/agv/7_3_bold.png"></p>
<h3 id="Similar-Nodes-and-Memoryless-Tree"><a href="#Similar-Nodes-and-Memoryless-Tree" class="headerlink" title="Similar Nodes and Memoryless Tree"></a>Similar Nodes and Memoryless Tree</h3><p>We call two nodes $x_1, x_2\in\mathcal{T}$ in a run tree $(\mathcal{T},r)$ <strong>similar</strong> if</p>
<ul>
<li>$|x_1| &#x3D; |x_2|$ (same index), and</li>
<li>$r(x_1) &#x3D; r(x_2)$ (same state).</li>
</ul>
<p>We call a run tree <strong>memoryless</strong> if the subtrees starting in <strong>similar</strong> nodes have the <strong>same labels</strong>.<br>Memoryless run trees can be represented as DAGs.</p>
<blockquote>
<p>$\textbf{Definition 7.5. } \text{ A run tree }(\mathcal{T},r)\text{ is }\textit{memoryless }\text{ if for all similar nodes }x_1\text{ and }x_2\text{ and for all}\newline y\in D^\ast\text{ we have that }(x_1\cdot y\in\mathcal{T}\text{ iff }x_2\cdot y\in\mathcal{T} )\text{ and } r(x_1\cdot y) &#x3D; r(x_2\cdot y).$</p>
</blockquote>
<p>The following theorem shows that whenever there is an accepting run tree, there is also an accepting run tree that is memoryless. Hence, we can show some word are accpeted by the automaton by showing the <strong>existence of a memoryless run tree</strong>, or, equivalently, the <strong>existence of an accepting run DAG</strong>.</p>
<blockquote>
<p>$\textbf{Theorem 7.2. } \textit{ If an alternating Büchi automaton }\mathcal{A}\textit{ accepts a word }\alpha\textit{, then there exists a}\newline\textit{memoryless accepting run of }\mathcal{A}\textit{ on }\alpha.$</p>
</blockquote>
<h2 id="Proof-of-Memoryless-Run-exists"><a href="#Proof-of-Memoryless-Run-exists" class="headerlink" title="Proof of Memoryless Run exists"></a>Proof of Memoryless Run exists</h2><p>Let $(\mathcal{T},r)$ be an accepting run tree on $\alpha$ with directions $D$. We construct a memoryless run tree $(\mathcal{T’},r’)$ by copying from $(\mathcal{T},r)$. Inuitively, we pick, whenever there are multiple occurrences of the same state in $(\mathcal{T},r)$, the occurrence where the last visit to the accepting states was the <strong>longest time ago</strong>.</p>
<h3 id="gamma-mathcal-T-rightarrow-mathbb-N-number-of-steps-since-the-last-visit-to-F"><a href="#gamma-mathcal-T-rightarrow-mathbb-N-number-of-steps-since-the-last-visit-to-F" class="headerlink" title="$\gamma:\mathcal{T}\rightarrow\mathbb{N}$: number of steps since the last visit to $F$"></a>$\gamma:\mathcal{T}\rightarrow\mathbb{N}$: number of steps since the last visit to $F$</h3><ul>
<li><p>Initiate the run tree (root) with zero steps:</p>
<ul>
<li>$\gamma(\varepsilon)&#x3D;0$</li>
</ul>
</li>
<li><p>For $n$’s children $d$, it increase one step from $n$, unless $n$ is an accepting state then it resets to zero</p>
<ul>
<li>$\gamma(n\cdot d)&#x3D;\left\lbrace\begin{array}{ll} \gamma(n)+1 &amp; \text{if }r(n)\notin F\newline 0 &amp; \text{if }r(n)\in F\end{array}\right.$</li>
</ul>
</li>
</ul>
<p>Now, we can define the tree node that the last visit to the accepting states was the <strong>longest time ago</strong> based on $\gamma$.</p>
<h3 id="Delta-Q-times-mathbb-N-rightarrow-mathcal-T-mapping-to-return-node-visit-F-longest-time-ago"><a href="#Delta-Q-times-mathbb-N-rightarrow-mathcal-T-mapping-to-return-node-visit-F-longest-time-ago" class="headerlink" title="$\Delta:Q\times\mathbb{N}\rightarrow\mathcal{T}$: mapping to return node visit $F$ longest time ago"></a>$\Delta:Q\times\mathbb{N}\rightarrow\mathcal{T}$: mapping to return node visit $F$ longest time ago</h3><p>For state $q\in Q$ and level $n\in\mathbb{N}$, it returns a tree node $y\in\mathcal{T}$ that is the leftmost and visit $F$ longest time ago:</p>
<p>$$\begin{array}{ll}\Delta(q,n)&#x3D;&amp;\text{the leftmost }y\in\mathcal{T}\text{ with }|y|&#x3D;n\ \text{ s.t. }\ r(y)&#x3D;q\newline &amp; \text{and }\forall z\in\mathcal{T}.\ |z|&#x3D;n\wedge r(z)&#x3D;q\Rightarrow\gamma(z)\leq\gamma(y)\end{array}$$</p>
<h3 id="Construction-of-Memoryless-Run-Tree-mathcal-T’-r’"><a href="#Construction-of-Memoryless-Run-Tree-mathcal-T’-r’" class="headerlink" title="Construction of Memoryless Run Tree $(\mathcal{T’},r’)$"></a>Construction of Memoryless Run Tree $(\mathcal{T’},r’)$</h3><p>We now construct $(\mathcal{T’},r’)$ by copying from the nodes in $(\mathcal{T},r)$ indicated by $\Delta$:</p>
<ul>
<li><p>Both trees have same initial states (root):</p>
<ul>
<li>$\varepsilon\in\mathcal{T’}\text{ and }r’(\varepsilon)&#x3D;r(\varepsilon)$</li>
</ul>
</li>
<li><p>Children node $d$ in $\mathcal{T’}$ are $d$ with longest steps, and of course a child of $n$:</p>
<ul>
<li>$d\in\mathcal{T’}\text{ if and only if }\Delta(r’(n),|n|)\cdot d\in\mathcal{T}\text{ and } r’(n\cdot d)&#x3D;r(\Delta(r’(n),|n|)\cdot d)$</li>
</ul>
</li>
</ul>
<h3 id="mathcal-T’-r’-is-a-run-of-mathcal-A-on-alpha"><a href="#mathcal-T’-r’-is-a-run-of-mathcal-A-on-alpha" class="headerlink" title="$(\mathcal{T’},r’)$ is a run of $\mathcal{A}$ on $\alpha$"></a>$(\mathcal{T’},r’)$ is a run of $\mathcal{A}$ on $\alpha$</h3><ul>
<li>The root is labeled by the initial state: $r’(\varepsilon)&#x3D;r(\varepsilon)&#x3D;q_0$.</li>
<li>For some node $n\in\mathcal{T’}$, let node $q_n&#x3D;\Delta(r’(n),|n|)$ ($q_n$ visits $F$ longest time ago among all $n$)</li>
<li>Then, the set $\lbrace r(q_n\cdot d)\mid d\in D, q_n\cdot d \in \mathcal{T}\rbrace$ satisfies $\delta(r(q_n), \alpha(|q_n|))$ (path of $q_n$ in original tree exists)</li>
<li>Therefore $\lbrace r’(n\cdot d)\mid d\in D, n\cdot d \in \mathcal{T’}\rbrace\models\delta(r’(n), \alpha(|n|))$ (by the construction above)</li>
</ul>
<h3 id="mathcal-T’-r’-is-accepting"><a href="#mathcal-T’-r’-is-accepting" class="headerlink" title="$(\mathcal{T’},r’)$ is accepting"></a>$(\mathcal{T’},r’)$ is accepting</h3><p>First, we show that for every $n\in\mathcal{T’}$, the node obtained from the mapping is indeed the longest path, i.e. $\gamma(n)\leq\gamma(\Delta(r’(n),|n|))$. This is shown by induction on the length of $n$:</p>
<ul>
<li><p>for $n&#x3D;\varepsilon$ we have that $\gamma(n)&#x3D;0$</p>
</li>
<li><p>for $n&#x3D;n’\cdot d$ (where $d\in D$) we have:</p>
<ul>
<li>if $r(n’)\in F$, then $\gamma(n)&#x3D;0$</li>
<li>if $r(n’)\notin F$, then</li>
</ul>
</li>
</ul>
<p>$$\begin{array}{lcl} \gamma(\Delta(r’(n’\cdot d),|n’\cdot d|))&amp;\overset{\text{Def. }\Delta}{\geq}&amp;\gamma(\Delta(r’(n’),|n’|)\cdot d)\overset{\text{Def. }\gamma}{&#x3D;}1+\gamma(\Delta(r’(n’),|n’|))\newline&amp;\overset{\text{IH}}{\geq}&amp;1+\gamma(n’)\overset{\text{Def. }\gamma}{&#x3D;}\gamma(n’\cdot d)\end{array}$$</p>
<p>(Last visit of the Mapping of children of $n’$ $\geq$ Last visit of mapping of $n$’s children. By induction hypothesis, the children of $n’$ through the mapping $\Delta$ is never smaller than any other possible children of $m’$)</p>
<p>Assume $(\mathcal{T’},r’)$ constructed from a accepting $(\mathcal{T},r)$ is not accepting. Then there is an infinite branch that does not visit $F$ infinitely often, i.e. $n_0, n_1, n_2,\dots$ in $\mathcal{T’}$ and $\exists k\in\mathbb{N}$ such that $\forall j\geq k. r’(n_j)\notin F$.</p>
<p>Let $m_i&#x3D;\Delta(r’(n_i), |n_i|)\text{ for }i\geq k$. We have,</p>
<p>$$<br>\begin{array}{ccccc} \gamma(n_k)&amp;&lt;&amp;\gamma(n_{k+1})&amp;&lt;&amp;\dots\newline &#x2F;\mathord{\bigwedge} &amp;&amp; &#x2F;\mathord{\bigwedge}<br>\newline\gamma(m_k)&amp;&lt;&amp;\gamma(m_{k+1})&amp;&lt;&amp;\dots\end{array}<br>$$</p>
<p>So, for any $j\geq k$ it holds that $\gamma(m_j)\geq j−k$ (because there are at least $j-k$ steps without visiting $F$). Since $\mathcal{T}$ is finitely branching, there must be a branch with an infinite suffix of non-$F$ labeled positions. So we can always find the branch in $\mathcal{T}$ identical with the path with $m_i$ This contradicts the assumption $(\mathcal{T},r)$ is accepting.</p>
<blockquote>
<p>$\textbf{Corollary 7.1. }\textit{A word }\alpha\textit{ is accepted by an alternating Büchi automaton }\mathcal{A}\textit{ if and only if}\newline\mathcal{A}\textit{ has an accepting run DAG on }\alpha$</p>
</blockquote>
<h2 id="Translating-alternating-to-nondeterministic-automata"><a href="#Translating-alternating-to-nondeterministic-automata" class="headerlink" title="Translating alternating to nondeterministic automata"></a>Translating alternating to nondeterministic automata</h2><p>We are now ready to translate an alternating Büchi automaton into an equivalent nondeterministic Büchi automaton. The construction is due to Miyano and Hayashi (1984).</p>
<blockquote>
<p>$\textbf{Construction 7.2. }\text{For an alternating Büchi automaton }\mathcal{A}&#x3D;(\Sigma,Q,q_0,\delta,\small\text{BÜCHI} \normalsize(F))\text{, we}\newline\text{construct a nondeterministic Büchi automaton }\mathcal{A’}&#x3D;(\Sigma,Q’,I’,T’,\small\text{BÜCHI} \normalsize(F’))\text{ with }\mathcal{L(A)}&#x3D;\newline\mathcal{L(A’)}\text{ as follows:}$</p>
<p>$\begin{array}{ll}<br>\hspace{0.5cm} \cdot \ Q’&amp;&#x3D; 2^Q\times2^Q \newline<br>\hspace{0.5cm} \cdot \ I’&amp;&#x3D; \lbrace(\lbrace q_0\rbrace,\varnothing)\rbrace\newline<br>\hspace{0.5cm} \cdot \ T’&amp;&#x3D; \lbrace((X,\varnothing),\sigma,(X’,X’\setminus F))\mid X’\models\wedge_{q\in X}\delta(q,\sigma)\rbrace\ \cup\newline<br> &amp;\hspace{0.5cm} \lbrace((X,W),\sigma,(X’,W’\setminus F))\mid W\neq\varnothing,W’\subseteq X’, X’\models\wedge_{q\in X}\delta(q,\sigma),W’\models\wedge_{q\in W}\delta(q,\sigma)\rbrace\newline<br>\hspace{0.5cm} \cdot \ F’&amp;&#x3D; \lbrace(X,\varnothing)\mid X\subseteq Q\rbrace<br>\end{array}$</p>
</blockquote>
<h3 id="Modified-Example-from-section-7-1"><a href="#Modified-Example-from-section-7-1" class="headerlink" title="Modified Example from section 7.1"></a>Modified Example from section 7.1</h3><p><img src="/images/notes/uds/agv/7_3_alt.png"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Example</th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$Q’$</td>
<td align="left">$X&#x3D;\lbrace\lbrace p\rbrace,\lbrace q\rbrace,\lbrace p,q\rbrace\rbrace$ </br>$W &#x3D; \lbrace\varnothing,\lbrace q\rbrace\rbrace$</td>
<td align="left">States Q’ is a tuple consist of two <strong>set of states</strong> in $Q$, first one must be non-empty and the second one does not contain any states $q\in F$</td>
</tr>
<tr>
<td align="left">$I’$</td>
<td align="left">$I’&#x3D;(\lbrace p\rbrace,\varnothing)$</td>
<td align="left">1st element is the initial state while the second element is empty</td>
</tr>
<tr>
<td align="left">$T’$</td>
<td align="left">$(\lbrace p\rbrace,\varnothing)\overset{b}{\longrightarrow}(\lbrace p,q\rbrace,$ $\lbrace \lbrace p,q\rbrace\setminus\lbrace p\rbrace\rbrace)&#x3D;(\lbrace p,q\rbrace,\lbrace q\rbrace)$</td>
<td align="left">$X$ represent the behaviour of the original automata, while $W$ tracks whether the original accepting states are visited after the transition.</td>
</tr>
<tr>
<td align="left">$T’$</td>
<td align="left">$(\lbrace p,q\rbrace,\lbrace q\rbrace) \overset{b}{\longrightarrow}(\lbrace p,q\rbrace,\varnothing)$ $(\delta(p,b)&#x3D;p\wedge q,\delta(q,b)&#x3D;\textit{true}&#x3D;\varnothing$ $\therefore\delta(p\wedge q,b)&#x3D;p\wedge q.)$</td>
<td align="left">If $W$ is empty, it means accepting states is reached and next transition we start again on tracking. If $W$ is non-empty, then its behaviour align with $X$</td>
</tr>
<tr>
<td align="left">$F’$</td>
<td align="left">$F’&#x3D;\lbrace(\lbrace p\rbrace,\varnothing), (\lbrace p,q\rbrace,\varnothing)\rbrace$</td>
<td align="left">The run&#x2F;word is aceepting if $W$ is empty infinite often.</td>
</tr>
</tbody></table>
<blockquote>
<p>$\textbf{Theorem 7.3. } \text{(Miyano and Hayashi, 1984). }\textit{For every alternating Büchi automaton }\mathcal{A}\textit{, we can}\newline\textit{effectively construct a nondeterministic Büchi automaton }\mathcal{A’}\textit{ with }\mathcal{L(A)}&#x3D;\mathcal{L(A’)}.$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><blockquote>
<p>$\mathcal{L(A)}\supseteq\mathcal{L(A’)}$ (all word accepted by $\mathcal{L(A’)}$ must also be accepted by $\mathcal{L(A)}$):</p>
</blockquote>
<p>Let $\alpha\in\mathcal{L(A’)}$ with an accepting run $r’&#x3D;(X_0,W_0)(X_1,W_1)(X_2,W_2)\dots$<br>where $W_0 &#x3D;\varnothing$ and $X_0&#x3D;\lbrace q_0\rbrace$. We construct the run DAG $(V,E)$ for $\mathcal{A}$ on $\alpha$:</p>
<ul>
<li><p>All vertices in DAG in level $i$ come from the tree in level $i$:</p>
<ul>
<li>$V&#x3D;\lbrace (x,i)\mid i\in\mathbb{N}, x\in X_i\rbrace$</li>
</ul>
</li>
<li><p>$X_i$ represent the behaviour of the automaton and $W_i$ is for tracking whether the states are accepting.<br> If the state is not tracked by $W_i$, i.e. $(x\in X_i \setminus W_i)$, that means it is accepted, no extra tracking is needed,<br> If it is tracked, i.e. $(x\in W_i)$, it either moves to some accepting state or it is continue tracked $(F\cup W_{i+1})$:</p>
<ul>
<li>$E&#x3D;\lbrace((x,i),(x’,i+1))\mid i\in\mathbb{N}, x\in X_i \setminus W_i, x’\in X_{i+1}\rbrace\cup\newline\hspace{0.95cm}\lbrace((x, i),(x’,i+1))\mid i\in\mathbb{N}, x\in W_i, x’\in X_{i+1}\cap (F\cup W_{i+1})\rbrace$</li>
</ul>
</li>
</ul>
<p>First, we show that $(V,E)$ is a run DAG: $(q_0,0)\in V$ and for every $(x,i)\in V$:</p>
<ul>
<li>The state is accepted, any transitions from here are valid:<ul>
<li>if $x\in X_i\setminus W_i,\ X_{i+1}\models\delta(x,\alpha(i))$;</li>
</ul>
</li>
<li>The state is tracked, only transitions to accepting state or continue tracked are valid:<ul>
<li>if $x\in W_i, x’\in X_{i+1}\cap (F\cup W_{i+1})\models\delta(x,\alpha(i))$.</li>
</ul>
</li>
</ul>
<p>Since the automata is accepting, so it has $W_i&#x3D;\varnothing$ exist for infinitely many $i$. So the run DAG is accepting, because there is $x\in X_i\setminus W_i$ infinitely often, every path through the run DAG visits $F$ infinitely often.</p>
<blockquote>
<p>$\mathcal{L(A)}\subseteq\mathcal{L(A’)}$ (all word accepted by $\mathcal{L(A)}$ must also be accepted by $\mathcal{L(A’)}$):</p>
</blockquote>
<p>Let $\alpha\in\mathcal{L(A)}$ and $(V,E)$ be an accepting run DAG of $\mathcal{A}$ on $\alpha$.<br>We construct a run $r’&#x3D;(X_0,W_0)(X_1,W_1)(X_2,W_2)\dots$ on $\mathcal{A’}$ as follows:</p>
<ul>
<li><p>$X_0&#x3D;\lbrace q_0\rbrace$ and $W_0&#x3D;\varnothing$</p>
</li>
<li><p>We simulate the behaviour using $X_i$: for $i\geq 0$, let $X_{i+1} &#x3D; \lbrace x’\in Q\mid ((x,i),(x’,i+1))\in E, x\in X_i\rbrace$</p>
<ul>
<li>If the state is accepted, align the behaviour with $X$:<br>$W_{i+1} &#x3D; X_{i+1} \setminus F$ if $W_i&#x3D;\varnothing$</li>
<li>If not, track and see if the accepting condition is fulfiled: $W_{i+1} &#x3D; \lbrace x’\in Q \setminus F \mid\exists(x,i)\in V, ((x,i),(x’,i+1))\in E,x\in W_i\rbrace$.</li>
</ul>
</li>
</ul>
<p>Clearly, $r’$ is a run: it starts with $(\lbrace q_0\rbrace,\varnothing)$ and obeys $T’$. That is, $(X_{i+1},W_{i+1})$ contains states in $\delta(x,\alpha(i))$:</p>
<ul>
<li>For $x\in X_i\setminus W_i$, we have that $X_{i+1}\models\delta(x,\alpha(i))$;</li>
<li>For $x\in W_i$, $X_{i+1}\cap (F\cup W_{i+1})$ satisfies $\delta(x,\alpha(i))$.</li>
</ul>
<p>The run $r’$ is accepting, otherwise some state $(X_{i+1},W_{i+1})$ is rejected, and thus rejects the path in $(V,E)$.</p>
<h3 id="Example-with-the-construction"><a href="#Example-with-the-construction" class="headerlink" title="Example with the construction"></a>Example with the construction</h3><p><img src="/images/notes/uds/agv/7_3_nonde.png"></p>
<blockquote>
<p>$\textbf{Corollary 7.2. }\textit{A language is }\omega\textit{-regular if and only if it is recognizable by an alternating Büchi automaton.}$</p>
</blockquote>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this section, we have proved that any $\omega$-regular language can be recongnized by some alternating Büchi automaton. Let see how it is done.</p>
<ol>
<li><p>Every accepted word in an alternating Büchi automaton has an <strong>Memoryless Accepting Run</strong> (<em>Theorem 7.2</em>).</p>
</li>
<li><p>Every <strong>Memoryless Run Tree</strong> can be represented as a <strong>Run DAG</strong></p>
</li>
<li><p>Thus, Every accepted word in an alternating Büchi automaton has an <strong>Accepting Run DAG</strong> (<em>Corollary 7.1</em>).</p>
</li>
<li><p>For every <strong>Alternating Büchi Automaton</strong> there exists a <strong>Nondeterministic Büchi Automaton</strong> (<em>Theorem 7.3</em>).</p>
</li>
<li><p>An $\omega$-language is Büchi-recognizable iff it is $\omega$-regular (Büchi’s Characterization Theorem) (<em>Theorem 3.6</em>).</p>
</li>
<li><p>An $\omega$-language is <strong>Alternating</strong> Büchi-recognizable iff it is $\omega$-regular (<em>Corollary 7.2</em>).</p>
</li>
</ol>
<hr>
<p>Next chapter: <a href="../agv8-1/">Linear Arithmetic (Theory)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-01T02:08:48.000Z" title="01/12/2024, 03:08:48">2024-12-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.418Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 850 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv7-2/">AGV 7.2 -- From LTL to Alternating Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv7-1/">Alternating Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>It is usually much simpler to translate a logical formula into an alternating automaton than into a nondeterministic automaton. We illustrate this with the translation of LTL formulas into equivalent alternating Büchi automata. The states are simply the subformulas of the given formula and their negations (this set is called the <em>closure</em> of the formula). The transition function is derived from the <em>expansion laws</em> of the logic.</p>
<p>For example, an <code>Until</code> formula $\varphi_1\ \mathcal{U}\ \varphi_2$ holds if:</p>
<ul>
<li>$\varphi_2$ holds <strong>or</strong></li>
<li>$\varphi_1$ holds <strong>and</strong> the entire formula holds in the next step.</li>
</ul>
<p>The boolean formula produced by the transition function from the state $\varphi_1\ \mathcal{U}\ \varphi_2$ is therefore:</p>
<ul>
<li>a <code>disjunction</code> $(\wedge)$ between the transition function for $\varphi_2$ and</li>
<li>a <code>conjunction</code> $(\vee)$ between the transition function for $\varphi_1$ and the state $\varphi_1\ \mathcal{U}\ \varphi_2$.</li>
</ul>
<h2 id="From-LTL-to-Alternating-Automata"><a href="#From-LTL-to-Alternating-Automata" class="headerlink" title="From LTL to Alternating Automata"></a>From LTL to Alternating Automata</h2><blockquote>
<p>$\textbf{Construction 7.1. }\text{Let }\varphi\text{ be an LTL formula. We construct the alternating Büchi automaton }\newline\mathcal{A_\varphi}&#x3D;(\Sigma,Q,\varphi,\delta,\small\text{BÜCHI} \normalsize(F))\text{ using:}$<br>$\begin{array}{ll}<br>\hspace{0.5cm} \cdot \ Q &#x3D; \text{closure}(\varphi):&#x3D;\lbrace\psi,\neg\psi\mid\psi\text{ is subformula of }\varphi\rbrace \newline<br>\hspace{0.5cm} \cdot \ \delta(p,a)&#x3D;  \left\lbrace \begin{array}{ll}\textit{true}&amp;\text{if }p\in a\newline \textit{false}&amp;\text{if }p\not\in a\end{array}\right. &amp;\cdot \ \delta(\neg\psi,a)&#x3D;\overline{\delta(\psi,a)}\newline<br>\hspace{0.5cm} \cdot \ \delta(\psi_1\wedge\psi_2,a)&#x3D;\delta(\psi_1,a)\wedge\delta(\psi_2,a) &amp;\cdot \ \delta(\psi_1\vee\psi_2,a)&#x3D;\delta(\psi_1,a)\vee\delta(\psi_2,a)\newline<br>\hspace{0.5cm} \cdot \ \delta(\psi_1\ \mathcal{U}\ \psi_2,a)&#x3D;\delta(\psi_2,a)\vee(\delta(\psi_1,a)\wedge\psi_1\ \mathcal{U}\ \psi_2)&amp;\cdot \ \delta(\bigcirc\psi,a)&#x3D;\psi\newline<br>\hspace{0.5cm} \cdot \ F &#x3D; \lbrace\neg(\psi_1\ \mathcal{U}\ \psi_2)\in\text{clousure}(\varphi)\rbrace<br>\end{array}\newline$<br>$\text{where we define }\overline{\varphi}&#x3D;\neg\varphi\text{ for all other }\psi\in Q\text{ and }\overline{\ \cdot\ }\text{ for }\psi,\psi_1,\psi_2\in Q\text{ via:}$<br>$\begin{array}{ll}<br>\hspace{0.5cm} \cdot \ \overline{\neg\varphi}&#x3D;\varphi<br>\hspace{0.5cm} \cdot \ \overline{\psi_1\wedge\psi_2}&#x3D;\overline{\psi_1}\vee\overline{\psi_2}<br>\hspace{0.5cm} \cdot \ \overline{\psi_1\vee\psi_2}&#x3D;\overline{\psi_1}\wedge\overline{\psi_2}<br>\hspace{0.5cm} \cdot \ \overline{\textit{true}}&#x3D;\overline{\textit{false}}<br>\hspace{0.5cm} \cdot \ \overline{\textit{false}}&#x3D;\overline{\textit{true}}<br>\end{array}$</p>
</blockquote>
<h2 id="Explanation-and-Examples-in-Human-language"><a href="#Explanation-and-Examples-in-Human-language" class="headerlink" title="Explanation and Examples in Human language"></a>Explanation and Examples in Human language</h2><p>Remember that $\delta$ function returns <em>set of states</em>.</p>
<p>As we can see most of the function here don’t actually have a designated successor except for <strong>atomic proposition</strong> $p$, <strong>neXt</strong> $\bigcirc$, and <strong>Until</strong> $\mathcal{U}$.</p>
<p>For example, here are simple steps to construct a automaton for a formula $p\wedge\bigcirc q$:</p>
<ol>
<li><p>List of all possible atomic propositions input: $\sigma&#x3D;\lbrace\lbrace\varnothing\rbrace,\lbrace p\rbrace,\lbrace q\rbrace,\lbrace p,q\rbrace\rbrace$</p>
</li>
<li><p>Write a truth table basic on the formula and its corresponding function $\delta$:<br>$\ \newline\hspace{1cm}\delta(p\wedge\bigcirc q,\sigma) &#x3D; \delta(p,\sigma)\wedge\delta(\bigcirc q,\sigma)&#x3D;\delta(p,\sigma)\wedge q<br>\newline\ \newline<br>\hspace{1cm}\cdot \ \delta(\bigcirc q,\sigma)&#x3D;\left\lbrace \begin{array}{ll}<br>q&amp;\text{if }\sigma&#x3D;\lbrace\varnothing\rbrace,\lbrace q\rbrace,\lbrace p\rbrace,\lbrace p,q\rbrace\end{array} \right. \newline\ \newline<br>\hspace{1cm}\cdot \ \delta(p,\sigma)&#x3D;\left\lbrace\begin{array}{ll}<br>\textit{false}&amp;\text{if }\sigma&#x3D;\lbrace\varnothing\rbrace,\lbrace q\rbrace\newline<br>\textit{true}&amp;\text{if }\sigma&#x3D;\lbrace p\rbrace,\lbrace p,q\rbrace\end{array}\right.<br>\hspace{1cm}\cdot \ \delta(q,\sigma)&#x3D;\left\lbrace\begin{array}{ll}<br>\textit{false}&amp;\text{if }\sigma&#x3D;\lbrace\varnothing\rbrace,\lbrace p\rbrace\newline<br>\textit{true}&amp;\text{if }\sigma&#x3D;\lbrace q\rbrace,\lbrace p,q\rbrace\end{array}\right.<br>\newline\ \newline\hspace{1cm}\therefore\ \delta(p\wedge\bigcirc q,\sigma)&#x3D;\left\lbrace\begin{array}{ll}<br>\textit{false}\wedge q &#x3D; \textit{false}&amp;\text{if }\sigma&#x3D;\lbrace\varnothing\rbrace,\lbrace q\rbrace\newline<br>\textit{true}\wedge q &#x3D; q&amp;\text{if }\sigma&#x3D;\lbrace p\rbrace,\lbrace p,q\rbrace\end{array}\right.<br>$</p>
</li>
<li><p><strong>Initial state</strong> is always the orginal formula, then we add extra state according to the truth table we constructed. Here, our graph have no <strong>universal</strong> or <strong>nondeterministic</strong> transitions:</p>
</li>
</ol>
<p><img src="/images/notes/uds/agv/7_2_next.png"></p>
<p>For a more complicated example, i.e. $((\Diamond p)\ \mathcal{U}\ (\square q))$, check <a href="../agv7-2-eg/">here</a> as an extra material</p>
<blockquote>
<p>$\textbf{Theorem 7.1. } \textit{For every LTL formula }\varphi\textit{, there is an alternating Büchi automaton }\mathcal{A_\varphi}\newline\textit{with }\mathcal{L(A_\varphi)} &#x3D; \mathcal{L(\varphi)}.$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We can simply prove this by induction. First, any LTL formula $\varphi$ can be recursively seperate into smaller subformula, namely $\psi$.</p>
<p>Similarly we can construct automaton $\mathcal{A^\psi_\varphi}$ from $\mathcal{A_\varphi}$ according to above construction 7.1. By structural induction on $\psi$, we can then prove that $\mathcal{L(A^\psi_\varphi)&#x3D;L(A_\varphi)}$.</p>
<hr>
<p>Next chapter: <a href="../agv7-3/">Translating Alternating to Nondeterministic automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-30T01:25:22.000Z" title="30/11/2024, 02:25:22">2024-11-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.418Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 953 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv7-1/">AGV 7.1 -- Alternating Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv6-7/">S1S$_0$ and Büchi-recognizable Language</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Logics are often significantly more concise than automata. For example, in the translation from S1S to Büchi automata in the proof of <a href="../agv6-7/">Theorem 6.4</a>, each negation increases the size of the Büchi automaton exponentially, resulting in a non-elementary number of states. The blow-up when translating LTL formulas is less dramatic, but still exponential. In this section, we show that the conciseness of the logic and the automata can be brought closer together when the automata are equipped with both <strong>nondeterministic</strong> and <strong>universal</strong> choices.</p>
<h2 id="Alternating-Automata"><a href="#Alternating-Automata" class="headerlink" title="Alternating Automata"></a>Alternating Automata</h2><h3 id="Nondeterministic-and-Universal"><a href="#Nondeterministic-and-Universal" class="headerlink" title="Nondeterministic and Universal"></a>Nondeterministic and Universal</h3><p>In previous sections, we discussed a lot about <strong>Nondeterministic</strong> transitions. Here we introduce a new concept <strong>Universal</strong> transitions for our new automaton called alternating automaton. We allow for both types of choices by defining, for each state and input letter, a <strong>positive Boolean formula</strong> over the successor states.</p>
<table>
<thead>
<tr>
<th align="left">Choices</th>
<th align="left">Symbol</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Nondeterministic</strong></td>
<td align="left">disjunction $(\vee)$</td>
<td align="left">the suffix of an input word is <strong>accepted by SOME</strong> successor state</td>
</tr>
<tr>
<td align="left"><strong>Universal</strong></td>
<td align="left">conjunction $(\wedge)$</td>
<td align="left">the suffix of an input word is <strong>accepted by ALL</strong> successor states</td>
</tr>
</tbody></table>
<h3 id="Positive-Boolean-Formulas-mathbb-B-X"><a href="#Positive-Boolean-Formulas-mathbb-B-X" class="headerlink" title="Positive Boolean Formulas $\ \mathbb{B}^+(X)$"></a>Positive Boolean Formulas $\ \mathbb{B}^+(X)$</h3><blockquote>
<p>$\textbf{Definition 7.1. } \text{The }\textit{positive Boolean formulas }\text{over a set }X\text{, denoted }\mathbb{B}^+(X)\text{, are the formulas}\newline\text{built from elements of }X\text{, conjunction }\wedge\text{, disjunction }\vee,\textit{ true}\text{ and }\textit{false.}$</p>
</blockquote>
<p>In our automata construction, elements of $X$ will be <strong>states</strong>. Let say we have a set of states $Y\subseteq X$.<br>We denote $Y\models\varphi$ if $Y$ satisfies a formula $\varphi\in\mathbb{B^+}(X)$. In other words:</p>
<ul>
<li>all states in $Y$ will be assigned as $\textit{true}$ by $\varphi$, and</li>
<li>all states in $X\setminus Y$ will be assigned as $\textit{false}$ by $\varphi$.</li>
</ul>
<h3 id="Trees-and-Runs"><a href="#Trees-and-Runs" class="headerlink" title="Trees and Runs"></a>Trees and Runs</h3><blockquote>
<p>$\textbf{Definition 7.2. } \text{ An } \textit{Alternating automaton over infinite words }\mathcal{A}\newline\text{ is a tuple }\mathcal{A} &#x3D; (\Sigma,Q,q_0,\delta,Acc)\text{, where}\newline\begin{array}{ll}<br>\hspace{1cm} \cdot \ Q &amp;\text{ is a finite set of states} \newline<br>\hspace{1cm} \cdot \ q_0 \in Q&amp; \text{ is the initial states} \newline<br>\hspace{1cm} \cdot \ \delta:Q\times\Sigma\rightarrow\mathbb{B^+}(Q)&amp; \text{ is the } \textit{transition functions}\text{, and} \newline<br>\hspace{1cm} \cdot \ Acc \subseteq Q^\omega&amp; \text{ is an accepting condition.}<br>\end{array}$</p>
</blockquote>
<p>For alternating automata, runs generalize from sequences to <strong>trees</strong>. Here we define a tree as a <strong>prefix-closed subset</strong>, guarantees that all nodes must be able to trace all the back the <strong>root</strong> of the tree.</p>
<blockquote>
<p><strong>prefix-closed subset</strong>:<br>If a word $w&#x3D;\lbrace ab\rbrace^\omega$ is in the set, then all its prefix (i.e. $\lbrace ab\rbrace,\lbrace aba\rbrace,\lbrace abab\rbrace,\dots$) must also be in the set.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Symbol&#x2F;Functions</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Set of Squences</strong></td>
<td align="left">$D^\ast$</td>
<td align="left">All possible sequence of every word by direction $D$</td>
</tr>
<tr>
<td align="left"><strong>Set of Directions</strong></td>
<td align="left">$D$</td>
<td align="left">Branches possible in each node</td>
</tr>
<tr>
<td align="left"><strong>Tree</strong></td>
<td align="left">$\mathcal{T}$</td>
<td align="left">Sequence of ONE word, a prefix-closed subset of $D^*$</td>
</tr>
<tr>
<td align="left"><strong>Root</strong></td>
<td align="left">$\varepsilon$</td>
<td align="left">The Empty Sequence</td>
</tr>
<tr>
<td align="left"><strong>Node</strong></td>
<td align="left">$n\in\mathcal{T}$</td>
<td align="left">Depends on the label, it may be the states or the letters</td>
</tr>
<tr>
<td align="left"><strong>Children of $n$</strong></td>
<td align="left">$\text{children}(n)&#x3D;\lbrace n\cdot d\in \mathcal{T}\mid d\in D\rbrace$</td>
<td align="left">Succssor states of $n$ over direction $d$</td>
</tr>
<tr>
<td align="left"><strong>$Q$-labeled tree</strong></td>
<td align="left">$(\mathcal{T},\ell)$</td>
<td align="left">A tree that labels nodes with the states</td>
</tr>
<tr>
<td align="left"><strong>$\Sigma$-labeled tree</strong></td>
<td align="left">$(\mathcal{T},\ell)$</td>
<td align="left">A tree that labels nodes with the input letters</td>
</tr>
<tr>
<td align="left"><strong>Labeling Function</strong></td>
<td align="left">$\ell:\mathcal{T}\rightarrow\Sigma$</td>
<td align="left">Label each node of the tree with the input letters for $\Sigma$-labeled tree</td>
</tr>
</tbody></table>
<p>Below, we define a <strong>run</strong> of an alternating autoamton using <strong>$Q$-labeled tree</strong>:</p>
<blockquote>
<p>$\textbf{Definition 7.3. } \text{ A } \textit{run }\text{of an alternating automaton on a word }\alpha\in\Sigma^\omega\newline\text{ is a Q-labeled tree (T , r) with the following properties:}\newline<br>\begin{array}{l}<br>\hspace{1cm} \cdot \ r(\varepsilon)&#x3D;q_0\text{ and}\newline<br>\hspace{1cm} \cdot \ \text{for all }n\in\mathcal{T}\text{, if }r(n)&#x3D;q\text{, then }\lbrace r(n’)\mid n’\in\text{children}(n)\rbrace\ \text{ satisfies }\delta(q,\alpha(|n|)).<br>\end{array}$</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>The following alternating Büchi automaton recognizes the language $L&#x3D;((a+b)^\ast b)^\omega$. Universal choice $(\wedge)$ are depicted by connecting the edges with a small arc $(\blacksquare)$. The transition function $(\delta)$ is given as follows:</p>
<ul>
<li>$\delta(p,a)&#x3D;p\wedge q$,</li>
<li>$\delta(p,b)&#x3D;p$,</li>
<li>$\delta(q,a)&#x3D;q$,</li>
<li>$\delta(q,b)&#x3D;\textit{true}$.</li>
</ul>
<p><img src="/images/notes/uds/agv/7_1_alt.png"></p>
<p>On the input word $\alpha&#x3D;(aab)^\omega$, our automaton has the following run. Note that, in general, an alternating automaton may have more than one run on a particular word, or also no run at all. We use a <strong>dotted line</strong> to indicate that the subtree repeats infinitely often.</p>
<p><img src="/images/notes/uds/agv/7_1_tree.png"></p>
<p>Similar to DAG, we can apply the <strong>acceptance condition</strong> only on <strong>all infinite branches</strong> of the run tree. A <em>branch</em> of a tree $\mathcal{T}$ is a <strong>maximal sequence</strong> of words $n_0n_1n_2\dots$ such that $n_0&#x3D;\varepsilon$ and $n_{i+1}$ is a child of $n_i$ for $i\geq0$.</p>
<p>Obviously, if every infinite branch is accepting, then the entire tree is thus accepting, i.e. there’s no way to pick a non-accepting path for to be the run.</p>
<blockquote>
<p>$\textbf{Definition 7.4. } \text{A run }(\mathcal{T},r)\text{ is }\textit{accepting }\text{iff, for every infinite branch }n_0n_1n_2\dots,$<br>$$r(n_0)r(n_1)r(n_2)\dots\in Acc.$$</p>
</blockquote>
<hr>
<p>Next chapter: <a href="../agv7-2/">From LTL to Alternating Büchi Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-28T23:36:06.000Z" title="29/11/2024, 00:36:06">2024-11-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.418Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1063 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-7/">AGV 6.7 -- S1S$_0$ and Büchi-recognizable Language</a></p><div class="content"><p>Previous chapter: <a href="../agv6-6/">Express QPTL using S1S</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>To prepare for the proof that every S1S-definable language is Büchi-recognizable, we show in the following lemma that we can focus on a restricted sublogic, called S1S$_0$, which is defined by the following grammar:</p>
<p>$$\varphi::&#x3D;0\in X\mid x\in Y\mid x&#x3D;0\mid x&#x3D;y\mid x&#x3D;S(y)\mid \neg\varphi\mid\varphi\wedge\varphi\mid\exists x.\varphi\mid\exists X.\varphi$$</p>
<ul>
<li><strong>Membership tests</strong> $(\in)$: variables $(x,y,\dots)$ and $0$ only</li>
<li><strong>Equalities</strong> $(&#x3D;)$: variables $(x,y,\dots)$, $0$ and a <strong>single</strong> successor operation $(S(t))$ only<ul>
<li>i.e. $S(S(t))$ is not allowed.</li>
</ul>
</li>
</ul>
<p>Complex formula in S1S can then be simplified by introducing additional variables.</p>
<h2 id="From-S1S-to-S1S-0"><a href="#From-S1S-to-S1S-0" class="headerlink" title="From S1S to S1S$_0$"></a>From S1S to S1S$_0$</h2><blockquote>
<p>$\textbf{Lemma 6.1. } \textit{For every S1S formula }\varphi\textit{ there is an S1S}_0\text{ formula }\varphi’\textit{ such that }\mathcal{L}(\varphi)&#x3D;\mathcal{L}(\varphi’).$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We rewrite a given S1S formula $\varphi$ into the S1S$_0$ formula $\varphi$’ using the following rewrite rules:</p>
<table>
<thead>
<tr>
<th align="left">S1S</th>
<th align="left">S1S_0</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$S(t)\in X$</td>
<td align="left">$\exists y. y&#x3D;S(t)\wedge y\in X$</td>
<td align="left">only $0$ and <code>First-order variable</code> $(x,y,\dots)$ is allowed on the L.H.S of $\in$</td>
</tr>
<tr>
<td align="left">$0&#x3D;x$</td>
<td align="left">$x&#x3D;0$</td>
<td align="left"><code>First-order variable</code> has higher priority than $0$</td>
</tr>
<tr>
<td align="left">$S(t)&#x3D;0$</td>
<td align="left">$0&#x3D;S(t)$</td>
<td align="left">successor operation not allowed on L.H.S</td>
</tr>
<tr>
<td align="left">$S(t)&#x3D;x$</td>
<td align="left">$x&#x3D;S(t)$</td>
<td align="left">successor operation not allowed on L.H.S</td>
</tr>
<tr>
<td align="left">$S(t)&#x3D;S(t’)$</td>
<td align="left">$t&#x3D;t’$</td>
<td align="left">successor operation not allowed on L.H.S</td>
</tr>
<tr>
<td align="left">$0&#x3D;0$</td>
<td align="left">$\exists Y.0\in Y\vee0\notin Y$</td>
<td align="left">only accept the form $x&#x3D;0$</td>
</tr>
<tr>
<td align="left">$0&#x3D;S(t)$</td>
<td align="left">$\exists y.y&#x3D;S(t)\wedge y&#x3D;0$</td>
<td align="left">only accept the form $x&#x3D;0$ or $x&#x3D;S(y)$</td>
</tr>
<tr>
<td align="left">$t&#x3D;S(0)$</td>
<td align="left">$\exists x.x&#x3D;0\wedge t&#x3D;S(x)$</td>
<td align="left">only accept the form $x&#x3D;S(y)$</td>
</tr>
<tr>
<td align="left">$t&#x3D;S(S(t’)$</td>
<td align="left">$\exists y.y&#x3D;S(t’)\wedge t&#x3D;S(y)$</td>
<td align="left">only allow one successor operation</td>
</tr>
</tbody></table>
<h2 id="From-S1S-definable-to-Buchi-recognizable"><a href="#From-S1S-definable-to-Buchi-recognizable" class="headerlink" title="From S1S-definable to Büchi-recognizable"></a>From S1S-definable to Büchi-recognizable</h2><blockquote>
<p>$\textbf{Theorem 6.4. } \textit{Every S1S-definable language is Büchi-recognizable.}$</p>
</blockquote>
<h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><p>Let $\varphi$ be an S1S-formula. We construct a Büchi automaton $\mathcal{A}$ with $\mathcal{L}(\varphi)&#x3D;\mathcal{L}(\mathcal{A})$.</p>
<ul>
<li>Step 1: We begin by translating $\varphi$ into an equivalent S1S$_0$ according to the above Lemma 6.1.</li>
<li>Step 2: Express every basic S1S$_0$ formula from the grammar above using Büchi automaton.</li>
</ul>
<p>Remember in <a href="../agv6-6/">last section</a>, when we translate QPTL to S1S, we defined <code>Second-order variable</code> $X$ as atomic proposition of QPTL. Here same definitions continue:</p>
<p>First of all, <strong>$A$ is the set of atomic propositions $(A\subseteq AP)$ which is avaliable in the current state</strong>. For example, in state $q_2$, $A &#x3D; \lbrace X,Y\rbrace$, where $AP &#x3D; \lbrace X,Y,Z\rbrace$. Which means in $q_2$ there exists transitions only when proposition $X$ or $Y$ is $\textit{true}$.</p>
<p>Then, words are defined as a sequence containing atomic propositions. For example, a possible structure for word $\alpha$ may look like this: $$\alpha&#x3D;\lbrace XYYXXYY\dots\rbrace$$</p>
<p>Finally, our <a href="../agv6-5/">definition</a> of <code>Second-order variable</code> is <strong>set of positions</strong>, and <code>First-order variable</code> are the <strong>positions</strong>. The relationship between proposition and variables in S1S is essentially $\alpha[x] &#x3D; X$, where $x$ is some <code>First-order variable</code> and $X$ is some <code>Second-order variable</code>.</p>
<p>We can also use the S1S way to interpret, that proposition $X$ holds $\textit{true}$ in position x and y, i.e. $X&#x3D;\lbrace x,y\rbrace$.</p>
<p>Therefore, when we see transitions like $\lbrace A\mid X\in A\rbrace$, it means if $X$ is part of the avaliable propositions for the current state and holds in certain letter(position), then the automata can take this transition as a path. (Here the position is not specified, will see more examples below)</p>
<ol>
<li><p>$0\in X$: This statement holds $\textit{true}$ iff. theres a word that contains $X$ in zero position.<br><img src="/images/notes/uds/agv/6_7_0inX.png"></p>
</li>
<li><p>$x\in Y$: This statement holds $\textit{true}$ iff. theres a word that contains $Y$ in $x$ position.<br><img src="/images/notes/uds/agv/6_7_xinY.png"></p>
</li>
<li><p>$x&#x3D;0$: This statement holds $\textit{true}$ iff. the word exist some propositions that only holds $\textit{true}$ in $x$-th position, assign $x$ as $0$.<br><img src="/images/notes/uds/agv/6_7_x=0.png"></p>
</li>
<li><p>$x&#x3D;y$: This statement holds $\textit{true}$ iff. the word exist some propositions that only holds $\textit{true}$ in $x$-th and $y$-th position, which are indeed the same.<br><img src="/images/notes/uds/agv/6_7_x=y.png"></p>
</li>
<li><p>$x&#x3D;S(y)$: This statement holds $\textit{true}$ iff. the word exist some propositions that only holds $\textit{true}$ in $x$-th and $y$-th position, where $x$ and $y$ are different and $x$ is the next position after $y$.<br><img src="/images/notes/uds/agv/6_7_x=S(y).png"></p>
</li>
<li><p>$\varphi\wedge\psi$: Let $\mathcal{A_\varphi}$ and $\mathcal{A_\psi}$ be the automata constructed for $\varphi$ and $\psi$, respectively. We obtain the automaton $\mathcal{A}_{\varphi\wedge\psi}$ by constructing the automaton that recognizes the intersection of $\mathcal{L(A_\varphi)}$ and $\mathcal{L(A_\psi)}$.<br>Below is the example of $0\in X \wedge x \in Y$:<br><img src="/images/notes/uds/agv/6_7_and.png"></p>
</li>
<li><p>$\neg\varphi$: let $\mathcal{A_{\varphi}}$ be the automaton constructed for $\varphi$. We obtain the automaton $\mathcal{A_{\neg\varphi}}$ by first constructing the automaton that recognizes the complement of $\mathcal{L(A_{\varphi})}$ and then intersecting it with $A_x$ for each <strong>free</strong> <code>first-order variable</code> $x$, which ensures that $x$ appears exactly once. Below we use $\neg(x\in Y)$ as an example:<br><img src="/images/notes/uds/agv/6_7_neg.png"><br>Notice that $(\lbrace x,Y\rbrace\subseteq A)\wedge(x\in A)&#x3D;\lbrace x,Y\rbrace\subseteq A$:<br><img src="/images/notes/uds/agv/6_7_notphi.png"></p>
</li>
<li><p>$\exists X.\varphi$: Let $\mathcal{A_{\varphi}}$ be the automaton constructed for $\varphi$. We obtain the automaton $\mathcal{A}_{\exists X. \varphi}$ for by eliminating $X$ from the input alphabet, i.e., we replace each transition $(q,A,q’)$ by $(q,A\setminus\lbrace X\rbrace,q’)$.<br>(Because the Büchi-recognizable Language only contains the set of <strong>free</strong> atomic propositions)</p>
</li>
<li><p>$\exists x. \varphi$: Similarly, we replace each transition $(q,A,q’)$ by $(q,A\setminus\lbrace x\rbrace,q’)$.</p>
</li>
</ol>
<hr>
<p>Next chapter: <a href="../agv7-1/">Alternating Büchi Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-28T22:45:21.000Z" title="28/11/2024, 23:45:21">2024-11-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.423Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 461 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-6/">AGV 6.6 -- Express QPTL using S1S</a></p><div class="content"><p>Previous chapter: <a href="../agv6-5/">Monadic Second-Order Logic of One Successor (S1S)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We already showed, in <a href="../agv6-4/">Theorem 6.2</a>, that every Büchi-recognizable language is QPTL-definable. We now complete a full circle by showing that every QPTL-definable language is S1S-definable, and that every S1S-definable language is Büchi-recognizable. <strong>Hence, QPTL, S1S, and Büchi automata are equally expressive.</strong></p>
<blockquote>
<p>$\textbf{Theorem 6.3. } \textit{Every QPTL-definable language is S1S-definable.}$</p>
</blockquote>
<h2 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h2><p>In <a href="../agv6-4/">section 6.4</a>, we defined the language of QPTL as: $\mathcal{L}(\varphi)&#x3D;\lbrace\alpha\in{(2^{AP’})}^{\omega}\mid\alpha\models\varphi\rbrace$, and</p>
<p>In <a href="../agv6-5/">section 6.5</a>, we defined the language of S1S as: $\mathcal{L}(\varphi)&#x3D;\lbrace \alpha_{\sigma_1,\sigma_2}\in(2^{V’_1\cup V’_2})^\omega\mid\sigma_1,\sigma_2\models\varphi\rbrace$</p>
<p>Notice main difference comes from $\alpha\models\varphi$ and $\sigma_1,\sigma_2\models\varphi$. Also, QPTL uses <em>propositions</em> but S1S uses <em>term</em>. We thus define S1S formula as $T(\varphi,t)$, where $\varphi$ is a QPTL-formula over $AP$ and $t$ is a S1S-term. Lastly, with $V_2&#x3D;AP$, we can now define a S1S formula for all $\alpha\in(2^{AP})^\omega$,</p>
<blockquote>
<p>$$\alpha\lbrack\lbrack t\rbrack_{\sigma_1},\infty\rbrack\models_{QPTL}\varphi\hspace{0.5cm}\text{iff}\hspace{0.5cm}\sigma_1,\sigma_2\models_{S1S}T(\varphi,t)\varphi,\hspace{1cm}\text{where }\ \sigma_2:P\mapsto\lbrace i\in\mathbb{N}\mid P\in\alpha(i)\rbrace$$</p>
</blockquote>
<p>$\begin{array}{llll}<br>\hspace{1cm}\cdot&amp;T(P,t)&amp;&#x3D;&amp;t\in P\text{, for }P\in AP\newline<br>\hspace{1cm}\cdot&amp;T(\neg\varphi,t)&amp;&#x3D;&amp;\neg T(\varphi,t)\newline<br>\hspace{1cm}\cdot&amp;T(\varphi\wedge\psi,t)&amp;&#x3D;&amp;T(\varphi,t)\wedge T(\psi,t)\newline<br>\hspace{1cm}\cdot&amp;T(\bigcirc\varphi,t)&amp;&#x3D;&amp;T(\varphi,S(t))\newline<br>\hspace{1cm}\cdot&amp;T(\Diamond\varphi,t)&amp;&#x3D;&amp;\exists x.(x\geq t\wedge T(\varphi, x))\newline<br>\hspace{1cm}\cdot&amp;T(\exists P.\varphi,t)&amp;&#x3D;&amp;\exists P. T(\varphi,t)\newline<br>\end{array}$</p>
<p>Therefore, the language of $\varphi$ is then defined by the S1S formula $T(\varphi, 0)$.</p>
<h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>We apply every basic QPTL operators into $\varphi$, and transform them using S1S operators.</p>
<p>For proposition $P$, we can assign its value based on the temporal state when it holds. For example, for $\alpha&#x3D;{PPQPQQQ\dots}$, $P$ is in position $\alpha[0], \alpha[1], \alpha[3]$. So $\sigma_2:P\mapsto\lbrace0,1,3\rbrace$<br>And $T(P,t)$ is true when $t$ have value equals to {1,2,3}.</p>
<p>For the Finally operator $\Diamond$, it is expressed as true when the value is greater than or equals to t.</p>
<hr>
<p>Next chapter: <a href="../agv6-7/">S1S$_0$ and Büchi-recognizable Language</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-27T02:21:19.000Z" title="27/11/2024, 03:21:19">2024-11-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.416Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1048 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-5/">AGV 6.5 -- Monadic Second-Order Logic of One Successor (S1S)</a></p><div class="content"><p>Previous chapter: <a href="../agv6-4/">Quantified Propositional Temporal Logic (QPTL)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Temporal logics like LTL and QPTL refer to the positions of the input word <em>implicitly</em> through the <code>temporal operators</code>. With S1S, we now introduce a logic that allows us to manipulate positions <em>explicitly</em>.</p>
<p>For example, the mutual exclusion property in LTL is $\square\neg(\ell_1\wedge m_1)$, where the Always operator $\square$ <strong>implicitly quantifies over all positions</strong>. In S1S, we use <strong>explicit universal quantifiers</strong> instead: $\forall x.\neg(x\in P_{\ell_1}\wedge x\in P_{m_1})$.</p>
<h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul>
<li><em><strong>Monadic</strong></em>: the second-order quantification is restricted to <strong>unary relations</strong>, i.e., sets,</li>
<li><em><strong>One successor</strong></em>: only have a single successor operation.</li>
</ul>
<p>Later in the course, we will study monadic second-order logics of two or more successors (S2S, WS1S, etc.), which allow us to describe <em>trees</em> rather than <em>words</em>.</p>
<h2 id="S1S-syntax"><a href="#S1S-syntax" class="headerlink" title="S1S syntax"></a>S1S syntax</h2><p>In automaton, we use <em>states</em>; in LTL and QPTL, we use <em>propositions</em>, in S1S, we use <strong>positions</strong>.<br>Propositions in QPTL can be interpreted as <strong>set of positions</strong> that holds $\textit{true}$.</p>
<table>
<thead>
<tr>
<th align="left">basic variables</th>
<th align="left">Defintiion</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>first-order variables</code></td>
<td align="left">store <strong>positions</strong></td>
<td align="left">$0,1,x,y,\dots$</td>
</tr>
<tr>
<td align="left"><code>second-order variables</code></td>
<td align="left">store <strong>sets of positions</strong> (refer to $p$ as $\exists p.\varphi$ in QPTL)</td>
<td align="left">$X,Y,\dots$</td>
</tr>
<tr>
<td align="left"><code>successor operation</code></td>
<td align="left">$S$, allows us to navigate to the next position (same as $\bigcirc$ in LTL)</td>
<td align="left">$S(t), S(2),\dots$</td>
</tr>
</tbody></table>
<h3 id="Terms-and-Formulas"><a href="#Terms-and-Formulas" class="headerlink" title="Terms and Formulas"></a>Terms and Formulas</h3><p>Let $V_1&#x3D;\lbrace x, y,\dots\rbrace$ be a set of <code>first-order variables</code> and $V_2&#x3D;\lbrace X, Y,\dots\rbrace$ a set of <code>second-order variables</code>. Then the <strong>terms</strong> of S1S are defined by the following grammar:</p>
<p>$$t::&#x3D;0\mid x\mid S(t)$$</p>
<p>The <strong>formulas</strong>&#96;of S1S are defined by the following grammar:</p>
<p>$$\varphi::&#x3D;t\in X\mid t&#x3D;t\mid\neg\varphi\mid\varphi\wedge\varphi\mid\exists x.\varphi\mid\exists X.\varphi$$</p>
<p>The precedence order of the operators goes from left (highest precedence) to right (lowest precedence), as denoted by the grammar above. We still allow usual boolean connectives with the following abbreviations:</p>
<p>$<br>\begin{array}{ll}<br>\hspace{1cm}\cdot\hspace{0.5cm} \forall X.\varphi :&#x3D; \neg\exists X. \neg\varphi&amp; \hspace{3cm}\cdot\hspace{0.5cm} \forall x.\varphi :&#x3D; \neg\exists x. \neg\varphi\newline<br>\hspace{1cm}\cdot\hspace{0.5cm} x\notin Y :&#x3D; \neg(x\in Y)&amp; \hspace{3cm}\cdot\hspace{0.5cm} x\neq y:&#x3D; \neg(x&#x3D;y)<br>\end{array}<br>$</p>
<h3 id="Variable-Valuations"><a href="#Variable-Valuations" class="headerlink" title="Variable Valuations"></a>Variable Valuations</h3><p>The semantics of an S1S formula is given relative to a valuation of the variables.</p>
<ul>
<li><code>First-order Valuation</code>: $\sigma_1:V_1\rightarrow\mathbb{N}$ assigns to each <code>first-order variable</code> a <strong>natural number</strong>.</li>
<li><code>Second-order Valuation</code>: $\sigma_2:V_2\rightarrow 2^\mathbb{N}$ assigns to each <code>second-order variable</code> a <strong>set of natural numbers</strong>.</li>
</ul>
<p>The value of a term is then defined as follows:</p>
<p>$\begin{array}{lll}<br>\hspace{1cm}\cdot\hspace{0.5cm} \lbrack 0\rbrack_{\sigma_1} &#x3D; 0 &amp;<br>\hspace{4cm}\cdot\hspace{0.5cm} \lbrack x\rbrack_{\sigma_1} &#x3D; \sigma_1(x) &amp;<br>\hspace{3cm}\cdot\hspace{0.5cm} \lbrack S(t)\rbrack_{\sigma_1} &#x3D;[t]_{\sigma_1}+1\newline<br>\end{array}$</p>
<h2 id="Free-Bound-and-the-Language-of-S1S"><a href="#Free-Bound-and-the-Language-of-S1S" class="headerlink" title="Free, Bound and the Language of S1S"></a>Free, Bound and the Language of S1S</h2><p>Again, we define the subsets of <strong>free</strong> first-order and <strong>free</strong> second-order variables as $V’_1\subseteq V_1$ and $V’_2\subseteq V_2$ respectively. An S1S formula $\varphi$ then defines the following language over the alphabet $2^{V’_1\cup V’_2}$:</p>
<p>$$\mathcal{L}(\varphi)&#x3D;\lbrace \alpha_{\sigma_1,\sigma_2}\in(2^{V’_1\cup V’_2})^\omega\mid\sigma_1,\sigma_2\models\varphi\rbrace$$</p>
<p>where $x\in\alpha_{\sigma_1,\sigma_2}(j)\text{ iff }&#x3D;\sigma_1(x)$, and $X\in\alpha_{\sigma_1,\sigma_2}(j)\text{ iff }j&#x3D;\sigma_2(X)$, and $\models$ is the smallest relation that satisfies the following:</p>
<p>$<br>\begin{array}{llllll}<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; t\in X &amp; \text{iff} &amp; \lbrack t\rbrack_{\sigma_1}\in\sigma_2(X)\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; t_1&#x3D;t_2 &amp; \text{iff} &amp;\lbrack t_1\rbrack_{\sigma_1}&#x3D;\lbrack t_2\rbrack_{\sigma_1}\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; \neg\psi &amp; \text{iff} &amp;\sigma_1,\sigma_2\not\models\psi\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; \varphi_0\wedge \varphi_1 &amp; \text{iff} &amp;\sigma_1,\sigma_2\models\varphi_0\text{ and }\sigma_1,\sigma_2\models\varphi_1\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; \exists x.\varphi &amp; \text{iff} &amp;\text{there is an }\alpha\in\mathbb{N}\text{ s.t. }\sigma’_1,\sigma_2\models\varphi\text{ and }\sigma’_1(y)&#x3D;\left\lbrace\begin{array}{ll}\sigma_1(y)&amp;\text{if }y\neq x \newline a&amp;\text{if }y&#x3D;x\end{array}\right.\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; \exists X.\varphi &amp; \text{iff} &amp;\text{there is an }A\in\mathbb{N}\text{ s.t. }\sigma_1,\sigma’_2\models\varphi\text{ and }\sigma’_2(Y)&#x3D;\left\lbrace\begin{array}{ll}\sigma_2(Y)&amp;\text{if }Y\neq X\newline A&amp;\text{if }Y&#x3D;X\end{array}\right.<br>\end{array}<br>$</p>
<p>For Existence Operator $(\exists)$, the definition is similar to QPTL: We have $\sigma’_1$ that behave exactly the same for every <code>first-order variable</code> $y$. Except for some $x$, there is a value $a$ that $\sigma’_1$ can assign to $x$ so that $\varphi$ holds. Same definition apply on <code>second-order variable</code> $X$ resepctively.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><table>
<thead>
<tr>
<th align="left">Statement</th>
<th align="left">Formula</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$X$ is a subset of $Y$</td>
<td align="left">$X\subseteq Y\equiv\forall z.\ (z\in X\rightarrow z\in Y)$</td>
</tr>
<tr>
<td align="left">$X$ and $Y$ are equal</td>
<td align="left">$X &#x3D; Y\equiv X\subseteq Y \wedge Y\subseteq X$</td>
</tr>
<tr>
<td align="left">$X$ is upward closed</td>
<td align="left">$\textit{Upwardclosed}(X)\equiv\forall y.\ (y\in X\rightarrow S(y)\in X)$</td>
</tr>
<tr>
<td align="left">$x$ is less than or equals to $y$</td>
<td align="left">$x\leq y\equiv\forall Z.\ (x\in Z\wedge\textit{Upwardclosed}(Z))\rightarrow y\in Z$</td>
</tr>
<tr>
<td align="left">$X$ is a finite set</td>
<td align="left">$\textit{Fin}(X)\equiv\exists Y.\ (X\subseteq Y\wedge(\exists z.\ z\notin Y)\wedge(\forall z.\ (z\notin Y\rightarrow S(z)\notin Y)))$</td>
</tr>
<tr>
<td align="left">$X$ is the set of even numbers</td>
<td align="left">$\textit{Even}(X)\equiv0\in X\wedge\neg S(0)\in X \wedge \forall y.\ (y\in X\leftrightarrow S(S(y))\in X)$</td>
</tr>
<tr>
<td align="left">Every even number in $X$ is in $Y$</td>
<td align="left">$\textit{EvenCount}(X,Y)\equiv\forall w.\ (\exists Z.\ \textit{Even}(Z)\wedge w\in Z)\rightarrow(w\in X\rightarrow w\in Y)$</td>
</tr>
</tbody></table>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In the next section, we will try to compare S1S with QPTL and see their expressiveness.</p>
<hr>
<p>Next chapter: <a href="../agv6-6/">Express QPTL using S1S</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Notes/page/2/">Previous</a></div><div class="pagination-next"><a href="/categories/Notes/page/4/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Notes/">1</a></li><li><a class="pagination-link" href="/categories/Notes/page/2/">2</a></li><li><a class="pagination-link is-current" href="/categories/Notes/page/3/">3</a></li><li><a class="pagination-link" href="/categories/Notes/page/4/">4</a></li><li><a class="pagination-link" href="/categories/Notes/page/5/">5</a></li><li><a class="pagination-link" href="/categories/Notes/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>