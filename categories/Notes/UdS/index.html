<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: UdS - GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li><a href="/categories/Notes/">Notes</a></li><li class="is-active"><a href="#" aria-current="page">UdS</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-16T19:12:54.000Z" title="16/02/2025, 20:12:54">2025-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.411Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">2 minutes read (About 305 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv12-2/">Emptiness Game</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now prove that parity tree automata are closed under complementation. As discussed at the beginning of the section, our proof makes heavy use of the determinacy of parity games (with infinite game arenas) established in <a href="../agv11-4">Theorem 11.3</a>.</p>
<blockquote>
<p>$\textbf{Theorem 12.3. } \textit{For every parity tree automaton }\mathcal{A}\textit{ over }\Sigma\textit{ there is a parity tree automaton }\mathcal{A}’\newline\textit{ with }\mathcal{L(A’)}&#x3D;\mathcal{T}_\Sigma\setminus\mathcal{L(A)}.$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Let $\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,\small\text{PARITY} \normalsize(C))$. By Theorem 12.1, a tree $(\mathcal{T},t)$ is accepted by $\mathcal{A}$ iff Player 0 has a winning strategy from position $(\varepsilon,q_0)$ of the acceptance game $\mathcal{G}_{\mathcal{A},t}$. </p>
<p>Since $\mathcal{A}$ is a parity tree automaton, $\mathcal{G}<em>{\mathcal{A},t}$ is a parity game and therefore, by Theorem 11.3, memoryless determined. Hence, $\mathcal{A}$ does not accept some tree $t$ iff Player 1 has a winning memoryless strategy $\sigma$ in $\mathcal{G}</em>{\mathcal{A},t}$ from $(\varepsilon,q_0)$. </p>
<p>The strategy $\sigma:\lbrace 0,1\rbrace^\ast\times T\rightarrow\lbrace 0,1\rbrace^\ast\times Q$ can be represented as a function $\sigma’:\lbrace 0,1\rbrace^\ast\times T\rightarrow\lbrace 0,1\rbrace$</p>
<p>where $\sigma(w,(q,\sigma,q^0,q^1))&#x3D;(wi,q^i)$ iff $\sigma’(w,(q,\sigma,q^0,q^1))&#x3D;i$. Yet another representation of the same strategy is $\sigma’:\lbrace 0,1\rbrace^\ast\rightarrow\lbrace T\rightarrow\lbrace 0,1\rbrace\rbrace$,</p>
<p>which can be understood as a labeling of $\mathcal{T}$ with finite “local strategies”. Hence, A does not accept $(\mathcal{T},t)$ iff</p>
<ol>
<li>there is a $(T\rightarrow\lbrace 0,1\rbrace)$-labeled tree $(\mathcal{T},v)$ such that</li>
<li>for all i0i1i2 . . . ∈ {0, 1}</li>
</ol>
<hr>
<p>Next chapter: <a href="../agv/"></a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-16T18:11:08.000Z" title="16/02/2025, 19:11:08">2025-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.436Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">2 minutes read (About 363 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><div class="content"><p>Previous chapter: <a href="../agv12-1/">Tree Automata and Acceptance Game</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Emptiness-Game"><a href="#Emptiness-Game" class="headerlink" title="Emptiness Game"></a>Emptiness Game</h2><p>The acceptance game can also be used to test if the language of a given tree automaton is non-empty. For this purpose, we first translate the given automaton into an automaton with singleton alphabet.</p>
<blockquote>
<p>$\textbf{Construction 12.1. } \text{For a given tree automaton }\mathcal{A}\text{ over }\Sigma\text{-labeled trees, we consider the}\newline\text{following tree automaton }\mathcal{A}’\text{ over }\lbrace1\rbrace\text{-labeled trees, such that }\mathcal{L(A)}&#x3D;\varnothing\text{ iff }\mathcal{L(A’)}&#x3D;\varnothing:\newline<br>\begin{array}{l}<br>\hspace{1cm} \cdot \ Q’&#x3D;Q \newline<br>\hspace{1cm} \cdot \ q_0’&#x3D;q_0\newline<br>\hspace{1cm} \cdot \ T’&#x3D;\lbrace(q,1,q’,q’’)\mid(q,\sigma,q’,q’’)\in T,\sigma\in\Sigma\rbrace\newline<br>\hspace{1cm} \cdot \ Acc’ &#x3D; Acc<br>\end{array}$</p>
</blockquote>
<p>Because the subtrees of a $\lbrace 1\rbrace$-labeled binary tree are the same from all nodes, we can simplify its acceptance game such that only finitely many positions are needed. We call this game the <strong>emptiness game</strong>.</p>
<blockquote>
<p>$\textbf{Definition 12.5. } \text{Let }\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,Acc)\text{ be a tree automaton. The }\textit{emptiness game}\text{ of }\mathcal{A}\newline \text{ is the game }\mathcal{G}_{\mathcal{A}}&#x3D;(\mathcal{A}’,\text{Win}’)\text{ with the finite game arena }\mathcal{A}’&#x3D;(Q\cup T, Q,T,E)\text{, where}\newline E&#x3D;\lbrace(q,\tau)\mid\tau&#x3D;(q,\sigma,q^0,q^1),\tau\in T\rbrace\cup\lbrace(\tau,q’)\mid\tau&#x3D;(\rule{0.5em}{0.4pt},\sigma,q^0,q^1)\text{ and }(q’&#x3D;q^0\text{ or }q’&#x3D;q^1)\rbrace\newline\text{and Win’}&#x3D;\lbrace q(0)\tau(0)q(1)\tau(1)\dots\mid q(0)q(1)\dots\in Acc,\tau(0)\tau(1)\dots\in T^\omega\rbrace$</p>
</blockquote>
<blockquote>
<p>$\textbf{Theorem 12.2. } \textit{The language of a tree automaton }\mathcal{A}\textit{ is non-empty iff Player 0 wins the}\newline\textit{emptiness game }\mathcal{G}_{\mathcal{A}}\textit{ from position }q_0.$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>The emptiness game corresponds to the acceptance game of the automaton from Construction 12.1 on the $\lbrace 1\rbrace$-labeled binary tree.</p>
<hr>
<p>Next chapter: <a href="../agv11-3/">Complementation of Parity Tree Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-15T23:21:11.000Z" title="16/02/2025, 00:21:11">2025-02-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.408Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1267 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv12-1/">AGV 12.1 -- Tree Automata and Acceptance Game</a></p><div class="content"><p>Previous chapter: <a href="../agv11-6/">A Remark on Undetermined Games</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Infinite games allow us to reason elegantly about infinite trees. A famous example of an argument that became significantly simpler with the introduction of game-theoretic ideas is the proof of <strong>Rabin’s theorem</strong>. </p>
<p>Rabin’s theorem states that the satisfiability of <strong>monadic second-order logic with two successors (S2S)</strong> is decidable. Like in <a href="../agv6-5/">Section 6</a>, where we showed that S1S formulas can be translated to automata, we will show that S2S formulas can be translated to automata, this time, in order to accommodate more than one successor function, to automata over infinite trees. </p>
<p>The most difficult part of the proof of Rabin’s theorem is to show that tree automata are <em>closed under complement</em>. The original proof was purely combinatorial (and very difficult to understand), but the game-theoretic argument is simply based on <strong>the determinacy of the acceptance game of the tree automaton</strong>:</p>
<ul>
<li><p>the acceptance of a tree by a tree automaton &#x3D; the existence of a winning strategy for Player 0,</p>
</li>
<li><p>the non-acceptance &#x3D; the absence of such a strategy &#x3D; the existence of a winning strategy for Player 1.</p>
</li>
</ul>
<p>We can therefore complement the language of a given tree automaton by constructing a new automaton that verifies the existence of a winning strategy for Player 1. We begin this section with a discussion of tree automata. The logic S2S and the translation to tree automata will be introduced later in the section.</p>
<h2 id="Tree-Automata"><a href="#Tree-Automata" class="headerlink" title="Tree Automata"></a>Tree Automata</h2><p>We consider tree automata over infinite binary trees. We use the notation for trees introduced in <a href="../agv7-1/">Section 7.1</a>. The (full) binary tree is the language $\mathcal{T} &#x3D;\lbrace 0, 1\rbrace^\ast$. For an alphabet $\Sigma, \mathcal{T}_\Sigma &#x3D; \lbrace(\mathcal{T}, t)\mid t:\mathcal{T}\rightarrow\Sigma\rbrace$ is the set of all binary $\Sigma$-labeled trees.</p>
<blockquote>
<p>$\textbf{Definition 12.1. } \text{An }\textit{automaton over infinite binary trees }\mathcal{A}\text{ is a tuple }(\Sigma,Q,q_0,T,Acc)\text{, where}\newline<br>\begin{array}{l}<br>\hspace{1cm} \cdot \ \Sigma \text{ is a finite alphabet,} \newline<br>\hspace{1cm} \cdot \ Q \text{ is a finite set of states,} \newline<br>\hspace{1cm} \cdot \ q_0 \in Q \text{ is an initial states,} \newline<br>\hspace{1cm} \cdot \ T \subseteq Q \times \Sigma \times Q \times Q, \newline<br>\hspace{1cm} \cdot \ Acc \subseteq Q^\omega \text{ is the accepting condition}<br>\end{array}$</p>
</blockquote>
<p>In the following, we will refer to automata over infinite binary trees simply as tree automata. Note that a transition of a tree automaton has two successor states, rather than a successor state as for word automata. The two states correspond to the two directions 0 and 1 of the input tree, the automaton may transition into different states for the different directions.</p>
<blockquote>
<p>$\textbf{Definition 12.2. } \text{A }\textit{run }\text{of a tree automata }\mathcal{A}\text{ on an infinite }\Sigma\text{-labeled binary tree }(\mathcal{T},t)\newline\text{ is a }Q\text{-labeled binary tree }(\mathcal{T},r)\text{ such that the following hold:}\newline<br>\begin{array}{l}<br>\hspace{0.5cm} \cdot \ r(\varepsilon)&#x3D;q_0 \hspace{2.5cm} \cdot \ (r(n),t(n),r(n0),r(n1))\in T\text{ for all }n\in\lbrace 0,1\rbrace^\ast<br>\end{array}$</p>
</blockquote>
<p>Note that $n0$ and $n1$ are the children of node $n$ in direction 0 and 1, respectively. The <strong>accepting runs</strong> are defined as for alternating automata in <a href="../agv7-1/">Section 7.1</a>: we apply the acceptance condition to the branches of the run tree. (Note that a run of an alternating automaton may have finite and infinite branches. The acceptance condition is only checked on infinite branches. Here, all branches are infinite.)</p>
<blockquote>
<p>$\textbf{Definition 12.3. } \text{A }\textit{run }(\mathcal{T},r)\text{ is }\textit{accepting}\text{ iff, for every infinite branch }n_0n_1n_2\dots,$<br>$$r(n_0)r(n_1)r(n_2)\dots\in Acc$$</p>
</blockquote>
<p>The language of the tree automaton $\mathcal{A}$ consists of the set of accepted $\Sigma$-labeled trees.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>The following Büchi tree automaton $\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,\small\text{BÜCHI}\normalsize(F))$ accepts all $\lbrace a,b\rbrace$-labeled trees with infinitely many $b$’s on each branch.</p>
<ul>
<li>$\Sigma &#x3D; \lbrace a,b\rbrace$</li>
<li>$Q&#x3D;\lbrace q_a,q_b\rbrace; q_0&#x3D;q_a$</li>
<li>$T&#x3D;\lbrace(q_a,a,q_a,q_a),(q_b,a,q_a,q_a),(q_a,b,q_b,q_b),(q_b,b,q_b,q_b)\rbrace$</li>
<li>$F &#x3D; \lbrace q_b\rbrace$</li>
</ul>
<p>Consider the $\Sigma$-labeled input tree $(\mathcal{T},t)$:</p>
<p><img src="/images/notes/uds/agv/12_1_inputtree.png"></p>
<p>The following $Q$-labeled tree is a run $(\mathcal{T},r)$ of $\mathcal{A}$ on $(\mathcal{T},t)$:</p>
<p><img src="/images/notes/uds/agv/12_1_runtree.png"></p>
<h2 id="Acceptance-Game"><a href="#Acceptance-Game" class="headerlink" title="Acceptance Game"></a>Acceptance Game</h2><p>The acceptance mechanism of a tree automaton is also characterized via its <strong>acceptance game</strong>. Player 0 can choose the alphabet $t(w)$ and Player 1 can choose the next state $q’$:</p>
<blockquote>
<p>$\textbf{Definition 12.4. } \text{Let }\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,Acc)\text{ be a tree automata and let }(\mathcal{T},t)\text{ be a }\Sigma\text{-labeled}\newline\text{binary tree. Then the }\textit{acceptance game}\text{ of }\mathcal{A}\text{ on }(\mathcal{T},t)\text{ is the game }\mathcal{G}_{\mathcal{A},t}&#x3D;(\mathcal{A}’,\text{Win}’)\text{ with the}\newline\text{infinite game arena }\mathcal{A}’&#x3D;(V’,V_0’,V_1’,E’)\text{ and the winning condition Win’ defined as follows:}\newline<br>\begin{array}{lll}<br>\hspace{1cm} \cdot \ V_0’&amp;&#x3D;&amp;\lbrace(w,q)\mid w\in\lbrace0,1\rbrace^\ast,q\in Q\rbrace\newline<br>\hspace{1cm} \cdot \ V_1’&amp;&#x3D;&amp;\lbrace(w,\tau)\mid w\in\lbrace0,1\rbrace^\ast,\tau\in T\rbrace\newline<br>\hspace{1cm} \cdot \ E’&amp;&#x3D;&amp;\lbrace((w,q),(w,\tau))\mid\tau&#x3D;(q,t(w),q^0,q^1),\tau\in T\rbrace\ \cup \newline<br>&amp;&amp;\lbrace((w,\tau),(w,q’))\mid\tau&#x3D;(q,\sigma,q^0,q^1)\text{ and}\newline<br>&amp;&amp;\hspace{3.65cm}w’&#x3D;w0\text{ and }q’&#x3D;q^0\text{ or }w’&#x3D;w1\text{ and }q’&#x3D;q^1\rbrace\newline<br>\hspace{1cm} \cdot \ \text{Win}’ &amp;&#x3D;&amp; \lbrace(w[0,0],q(0))(w[0,0],\tau(0))(w[0,1],q(1))(w[0,1],\tau(1))\dots\mid\newline<br>&amp;&amp; \hspace{1cm} q(0)q(1)\dots\in Acc, w(0)w(1)\dots\in\lbrace 0,1\rbrace^\omega,\tau(0)\tau(1)\dots\in T^\omega\rbrace<br>\end{array}$</p>
</blockquote>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>The following is a part of the acceptance game of automaton $\mathcal{A}$ from the example above:</p>
<p><img src="/images/notes/uds/agv/12_1_accgame.png"></p>
<blockquote>
<p>$\textbf{Theorem 12.1. } \textit{A tree automaton }\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,Acc)\textit{ accepts an input tree }(\mathcal{T},r)\newline\textit{ if and only if Player 0 wins the acceptance game }\mathcal{G}_{\mathcal{A},t}&#x3D;(\mathcal{A}’,\text{Win}’)\textit{ from position }(\varepsilon,q_0).$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p><strong>If the input tree is accepted, there is a winning strategy for Player 0</strong></p>
<p>Given an accepting run $(\mathcal{T},r)$ of $\mathcal{A}$, we construct a memoryless winning strategy $\sigma:V_0’\rightarrow V’$ for Player 0:</p>
<p>$$\sigma(w,q)&#x3D;(w,(r(w),t(w),r(w0),r(w1)))$$</p>
<p><strong>If there is a winning strategy for Player 0, the input tree is accepted</strong></p>
<p>Given a winning strategy $\sigma:V’^\ast V_0’\rightarrow V’$, we construct an accepting run $(\mathcal{T},r)$ where $r(\varepsilon)&#x3D;q_0$ and for all $w\in\lbrace 0,1 \rbrace^\ast$</p>
<p>$$r(w0)&#x3D;q\text{ for }\sigma(\Delta(w))&#x3D;(w,(\rule{0.5em}{0.4pt},\rule{0.5em}{0.4pt},q,\rule{0.5em}{0.4pt}))\ \text{ and }\ r(w1)&#x3D;q\text{ for }\sigma(\Delta(w))&#x3D;(w,(\rule{0.5em}{0.4pt},\rule{0.5em}{0.4pt},\rule{0.5em}{0.4pt}q))$$</p>
<p>where $\Delta(\varepsilon)&#x3D;(\varepsilon,q_0)\ \text{ and }\ \Delta(wd)&#x3D;\Delta(w)\cdot\sigma(\Delta(w))\cdot(wd,r(wd))\text{ for }d\in\lbrace0,1\rbrace.$</p>
<hr>
<p>Next chapter: <a href="../agv12-2/">Emptiness Game</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-15T12:55:54.000Z" title="15/02/2025, 13:55:54">2025-02-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.437Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 765 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv11-6/">AGV 11.6 -- A Remark on Undetermined Games</a></p><div class="content"><p>Previous chapter: <a href="../agv11-5/">Muller Games</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>Since we have shown that <a href="../agv11-2/">reachability</a>, <a href="../agv11-3/">Büchi</a>, <a href="../agv11-4/">parity</a>, and <a href="../agv11-5/">Muller</a> games are all <strong>determined</strong>, it might seem as if all games were determined. The purpose of this last subsection is to remark that this is not the case. By definition, every play is either won by Player 0 or by Player 1; however, it is entirely possible that neither Player 0 nor Player 1 has a winning strategy.</p>
<p>We will construct a game with a winning condition that allows the players to <em>steal</em> strategies in the sense that if Player i has a winning strategy σ, then Player 1−$i$ has a strategy $\tau$ that mimicks $\sigma$ so that the play resulting from strategies σ and τ is won by Player 1-$i$: hence, strategy $\sigma$ is not winning after all! </p>
<p>We fix the alphabet $\mathbb{B}&#x3D;\lbrace 0,1\rbrace$. To define the winning condition, we introduce an <em>infinite</em> $\text{XOR}$ <em>function</em> $f$. An infinite $\text{XOR}$ function is a function $f:\mathbb{B}^\omega\rightarrow\mathbb{B}$ such that $f(\alpha)\neq f(\beta)$ for all α, β ∈ B ω that have the exact same letter in every position except for exactly one position where they have different letters. </p>
<p>To see that such a function exists, define an equivalence relation $\sim$ such that $\alpha\sim\beta$ iff there exists a position $n\in\mathbb{N}$ such that $\alpha(i)&#x3D;\beta(i)$ for all $i\geq n$. Let $S\subseteq\mathbb{B}^\omega$ be a set that contains exactly one element from each $\sim$-equivalence class, and let $r(\alpha)$ be the unique $\beta\in S$ such that $\alpha\sim\beta$. For every $\alpha\in\mathbb{B}^\omega$, the two sequences $\alpha$ and $r(\alpha)$ differ only in a finite number of positions. We define $f(\alpha)&#x3D;0$ if this number is even and $f(\alpha)&#x3D;1$ if it is odd. Hence, $f$ is indeed an infinite $\text{XOR}$ function: if two sequences $\alpha,\beta\in\mathbb{B}^\omega$ differ in exactly one position, then $f(\alpha)\neq f(\beta)$. </p>
<p>We now use the infinite $\text{XOR}$ function $f$ to define the game. We’ll describe the game somewhat informally in terms of rounds executed by the players; it is straightforward to translate this into an explicit arena and winning condition. Our game is played in rounds $n &#x3D; 0, 1, 2,\dots,$ where in round $n$, first Player 0 picks a finite word $w_{2n}\in\mathbb{B}^+$, then Player 1 picks $w_{2n+1}\in\mathbb{B}^+$. The resulting play $\alpha&#x3D;w_0,w_1,w_2,\dots$ is winning for Player $f(\alpha)$.</p>
<p>We now use the “strategy stealing” argument to show that no player has a winnig strategy in this game. A strategy for Player $i$ is a mapping $\sigma:\cup_{n\in\mathbb{N}}(\mathbb{B}^+)^{2n+i}$, where we denote $(\mathbb{B}^+)^0&#x3D;\varepsilon$.</p>
<p>As usual, $\sigma$ is a winning strategy for Player $i$ if Player $i$ wins every play that is consistent with $\sigma_i$ . Now fix an arbitrary strategy $\tau$ for Player 1. From $\tau$, we construct two different strategies $\sigma$ and $\sigma’$ for Player 0. </p>
<p>For the first round:</p>
<ul>
<li><p>$\sigma(\varepsilon)&#x3D;0$</p>
</li>
<li><p>$\sigma’(\varepsilon)&#x3D;1w_1$ where $w_1&#x3D;\tau(0)$</p>
</li>
</ul>
<p>and for all subsequent rounds:</p>
<ul>
<li><p>$\sigma(0,w_1,w_2,\dots,w_{2n+1})&#x3D;\tau(1w_1,w_2,\dots,w_{2n+1})$</p>
</li>
<li><p>$\sigma’(1w_1,w_2,\dots,w_{2n+1})&#x3D;\tau(0,w_1,w_2,\dots,w_{2n+1})$</p>
</li>
</ul>
<p>i.e., $\sigma$ continues to mimick $\tau$. Consider now the plays $\alpha$, resulting from playing strategies $\sigma$ and $\tau$, and $\alpha’$ resulting from playing strategies $\sigma’$ and $\tau$. By construction, $\alpha&#x3D; 0w_1w_2w_3\dots$ and $\alpha’&#x3D; 1w_1w_2\dots$ are the same except for the first position, where $\alpha$ has a 0 and $\alpha’$ has a 1. Hence, we have that $f(\alpha)\neq f(\alpha’)$: one of the two plays is won by Player 0, the other by Player 1. Hence, $\tau$ cannot be a winning strategy for Player 1! </p>
<p>The construction of the stealing strategies $\tau$, $\tau’$ for Player 1 from a given strategy σ of Player 0 is analogous. </p>
<p>For the first round:</p>
<ul>
<li><p>$\tau(w_0)&#x3D;0$ for $W_0&#x3D;\sigma(\varepsilon)$</p>
</li>
<li><p>$\tau’(w_0)&#x3D;1w_1$ for $w_1&#x3D;\sigma(0,w_0)$</p>
</li>
</ul>
<p>and for all subsequent rounds:</p>
<ul>
<li><p>$\tau(w_0,0,w_2,\dots,w_{2n+1})&#x3D;\sigma(w_0,1w_1,w_2,\dots,w_{2n+1})$</p>
</li>
<li><p>$\tau’(w_0,1w_1,w_2,\dots,w_{2n+1})&#x3D;\sigma(w_0,0,w_1,w_2,\dots,w_{2n+1})$</p>
</li>
</ul>
<p>Again, the resulting plays only differ in exactly one position and are, hence, won by different players. Thus, strategy $\sigma$ cannot be winning for Player 0 either.</p>
<hr>
<p>Next chapter: <a href="../agv12-1/">Tree Automata and Acceptance Game</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-13T17:01:42.000Z" title="13/02/2025, 18:01:42">2025-02-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.408Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1066 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv11-5/">AGV 11.5 -- Muller Games</a></p><div class="content"><p>Previous chapter: <a href="../agv11-4/">Parity Games</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>Muller games differ from the games we have studied so far in that they are not memoryless determined. Consider, for example, a game arena consisting of three positions $v_0,v_1,v_2$, such that there are edges from $v_0$ and $v_2$ to $v_1$ and from $v_1$ to $v_0$ and $v_2$. Hence, the only choice in the game is in $v_1$, where Player 0 gets to choose between moving to $v_0$ or $v_2$:</p>
<p><img src="/images/notes/uds/agv/11_5_muller.png"></p>
<p>The Muller condition $\mathcal{F}&#x3D;\lbrace\lbrace v_0,v_1,v_2\rbrace\rbrace$ is only satisfied if all three positions are visited infinitely often. Player 0 can therefore not win the game with a memoryless strategy, because such a strategy would either visit $v_0$ and $v_1$ infinitely often, or $v_1$ and $v_2$, but not all three positions.  </p>
<p>There is, however, a memoryful winning strategy: simply alternate between moving from $v_1$ to $v_0$ and to $v_2$.</p>
<p>In the following, we solve Muller games via a reduction to parity games, i.e., we define a parity game such that we can translate the winning strategy in the parity game into a winning strategy in the Muller game.</p>
<p>The fact that parity games are memoryless determined and Muller games are not, is not a contradiction: our reduction introduces additional state into the parity game, such that, on the extended state space, there exists a memoryless winning strategy. This augmentation of the state space is known as the <strong>latest appearence record</strong>:</p>
<h2 id="Latest-Appearence-Record"><a href="#Latest-Appearence-Record" class="headerlink" title="Latest Appearence Record"></a>Latest Appearence Record</h2><blockquote>
<p>$\textbf{Definition 11.11. } \text{Let }V\text{ be the set of positions of the game arena and let }{$}\text{ be some fresh}\newline\text{symbol. A }\textit{latest appearence record}\text{ over }V\text{ is a finite word over the alphabet }V\cup\lbrace{$}\rbrace\text{ where every}\newline\text{letter from }V\cup\lbrace{$}\rbrace\text{ appears exactly once and whose first letter is from }V\text{ . The }\textit{hit set}\text{ of a latest}\newline\text{appearence record }\ell&#x3D;v_0v_1\dots v_m{$}v_m+1\dots v_n\text{ is defined as }hit(\ell)&#x3D;\lbrace v_0,\dots v_m\rbrace.$</p>
</blockquote>
<p>We denote the set of all <strong>latest appearence records</strong> by $\text{LAR}$. Each latest appearence record represents a permutation of $V$ plus a position indicated by ${$}$.</p>
<p>We will construct the parity game in such a way that whenever the play visits $v_i$, $v_i$ is moved to the beginning of the word, and the ${$}$-symbol is moved to $v_i$’s previous position. </p>
<p>In this way, every play will reach a position such that, from then on, the <strong>hit set</strong> (i.e., the set of game positions to the left of ${$}$) is always a subset of the infinity set, and infinitely often equal to the infinity set. The winning condition in the parity game thus only needs to ensure that the infinity set is actually one that satisfies the Muller condition. </p>
<p>For this purpose, we assign even colors to hit sets (multiply the size of hit sets by 2) that appear in the table of the Muller condition, and odd colors to hit sets (multiply the size of hit sets by 2 then -1) that do not appear in the table. Since the hit set corresponds to subsets of the infinity set, we need to make sure that odd colors that result from strict subsets of entries in the table are ignored.</p>
<p>We do this by increasing the colors depending on the position of the ${$}$-symbol. In this way, the color of the appearence records corresponding to the full infinity set is more important than the colors of the subsets that appear in-between occurrences of the full infinity set.</p>
<blockquote>
<p>$\textbf{Definition 11.4. } \text{Let a Muller game }\mathcal{G}&#x3D;(\mathcal{A},\small\text{MULLER} \normalsize(\mathcal{F}))\text{ with arena }\mathcal{A} &#x3D; (V,V_0,V_1,E)\newline\text{be given. We compute a parity game }\mathcal{G}’&#x3D;(\mathcal{A}’,\small\text{PARITY}\normalsize(\mathcal{c}) )\text{ with arena }\mathcal{A}’ &#x3D; (V’,V_0’,V_1’,E’)\newline\text{ as follows.}$<br>$\begin{array}{l}<br>  \hspace{0.5cm} \cdot \ V’&#x3D;V\times\text{LAR},V_0’&#x3D;V_0\times\text{LAR},V_1’&#x3D;V_1\times\text{LAR} \newline<br>  \hspace{0.5cm} \cdot \ E’&#x3D;\lbrace((v,v_0v_1\dots v_m{$}v_{m+1}\dots v_n),(v’,v_0’v_1’\dots v_{j-1}{$}v_{j+1}\dots v_{m+1}\dots v_n))\mid(v,v’)\in E,v’&#x3D;v_j\rbrace\newline<br>  \hspace{0.5cm} \cdot \ c(v,\ell)&#x3D; \left\lbrace\begin{array}{ll}<br>    2\cdot |hit(\ell)| &amp; \text{if }hit(\ell)\in\mathcal{F}\newline<br>    2\cdot |hit(\ell)|-1 &amp; \text{if }hit(\ell)\notin\mathcal{F}\newline<br>  \end{array}\right. \newline<br>\end{array}$</p>
</blockquote>
<p>In order to solve a given Muller game, we solve the constructed parity game. To determine if a player has a winning strategy from some position $v$ of the Muller game, we then simply check if the same player wins from the corresponding position of the parity game.</p>
<p>In principle, we could use any position of the parity game where $v$ appears in the first component of the position of the parity game. In the following theorem, we arbitrarily fix the position $(v,v_0v_1\dots v_n{$})$.</p>
<blockquote>
<p>$\textbf{Theorem 11.4. } \textit{For every Muller game }\mathcal{G}&#x3D;(\mathcal{A},\small\text{MULLER} \normalsize(\mathcal{F}))\textit{ with arena }\mathcal{A} &#x3D; (V,V_0,V_1,E),\newline\textit{there is a parity game }\mathcal{G}’&#x3D;(\mathcal{A}’,\small\text{PARITY}\normalsize(\mathcal{c}) )\text{ with arena }\mathcal{A}’ &#x3D; (V’,V_0’,V_1’,E’)\textit{ where}\newline V’&#x3D;V\times\text{LAR}\textit{ such that each player has a winning strategy from a position }v\in V\textit{ of the Muller}\newline\textit{game iff the same player has a winning strategy from position }(v,v_0v_1\dots v_n{$})\textit{ of the parity game.}$</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Consider the following game with winning condition $\small\text{MULLER} \normalsize(\lbrace\lbrace v_0,v_1\rbrace\rbrace)$:</p>
<p><img src="/images/notes/uds/agv/11_5_example.png"></p>
<p>We construct the following parity game:</p>
<p><img src="/images/notes/uds/agv/11_5_parity.png"></p>
<p>(Shown is only the reachable part of the arena from positions $(v_0, v_0v_1{$})$ and $(v_1, v_0v_1{$})$.) Since Player 0 wins from every position of the parity game, we conclude that the same is true for every position of the Muller game.</p>
<hr>
<p>Next chapter: <a href="../agv11-6/">A Remark on Undetermined Games</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-13T09:24:29.000Z" title="13/02/2025, 10:24:29">2025-02-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.438Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">12 minutes read (About 1808 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv11-4/">AGV 11.4 -- Parity Games</a></p><div class="content"><p>Previous chapter: <a href="../agv11-3/">Büchi Games</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Perhaps the most intriguing type of infinite games are <strong>parity games</strong>. <strong>Parity games</strong> play a key role in verification (in particular for $\mu$-calculus model checking) and synthesis, and finding fast algorithms for parity games is an active research topic. </p>
<p>The algorithm discussed in the following takes exponential time. There are also several quasi-polynomial-time algorithms for solving parity games (starting with a breakthrough result by Calude, Jain, Khoussainov, Li, and Stephan in 2017). In practice, however, these algorithms do not perform well (yet).</p>
<h2 id="Parity-Condition"><a href="#Parity-Condition" class="headerlink" title="Parity Condition"></a>Parity Condition</h2><blockquote>
<p>$\textbf{Definition 11.10. }\text{The }\textit{parity condition }\small\text{PARITY} \normalsize(C)\text{ for a coloring function }c:V\rightarrow\mathbb{N}\text{ is the set}$<br>$$\small\text{PARITY} \normalsize(C)&#x3D;\lbrace\alpha\in V^\omega\mid\text{max}\lbrace c(q)\mid q\in\text{Inf}(\alpha)\rbrace\text{is even}\rbrace.$$</p>
</blockquote>
<p>The parity condition is satisfied if the biggest number $q$ of the coloring function is even, among all positions that are visited infinitely often.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/11_4_parity.png"></p>
<ul>
<li><p>The winning region for Player 0: $W_0(\mathcal{G})&#x3D;\lbrace v_3,v_6,v_7\rbrace$</p>
<ul>
<li>Strategy: $\sigma(v_3) &#x3D; v_6, \sigma(v_7) &#x3D; v_4, \sigma(v_7) &#x3D; v_6$ ($v_8$ have no choices and $v_1$ is arbitrary)</li>
</ul>
</li>
<li><p>The winning region for Player 1: $W_1(\mathcal{G})&#x3D;\lbrace v_0,v_1,v_2,v_4,v_5,v_8\rbrace$</p>
<ul>
<li>Strategy: $\tau(v_0) &#x3D; v_1, \tau(v_2) &#x3D; v_5, \tau(v_4) &#x3D; v_0, \tau(v_5) &#x3D; v_1$</li>
</ul>
</li>
</ul>
<p>We first prove that parity games are memoryless determined, then derive an algorithm for solving parity games. In the following theorem, we emphasize that determinacy holds also for (countably) infinite game arenas. </p>
<p>This will be helpful when we use the determinacy to complement tree automata, because the acceptance game of a tree automaton refers to the infinite input tree and is therefore infinite.</p>
<blockquote>
<p>$\textbf{Theorem 11.3. } \textit{Parity games are memoryless determined with uniform winning strategies}\newline\textit{for game arenas with a countable set of positions and a finite number of colors.}$</p>
</blockquote>
<p>Here, we try to construct a uniform winning strategy for an arbitrary parity game.</p>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Let $k&#x3D;\text{max}\lbrace c(v)\mid v\in V\rbrace$ be the highest color in the given parity game. We prove that parity games are memoryless determined by induction on $k$.</p>
<p><strong>Case</strong> $k&#x3D;0$: If the highest color is 0, then all plays are winning. $W_0(\mathcal{G})&#x3D;V, W_1(\mathcal{G})&#x3D;\varnothing$. For the memoryless winning strategy $\sigma$, we fix an arbitrary total order on $V$ and choose $\sigma(v)&#x3D;\text{min}\lbrace v’\in V\mid(v,v’)\in E\rbrace$.</p>
<p><strong>Case</strong> $k&gt;0$: If $k$ is even, consider Player $i$, otherwise Player (1-$i$). Let $W_{i-1}$ be the set of positions where Player (1-$i$) has a memoryless winning strategy. We show that Player $i$ has a memoryless winning strategy $\sigma$ from $V\setminus W_{1−i}$ . Consider the subgame $\mathcal{G’}$:</p>
<ul>
<li>$V_0’ &#x3D; V_0\setminus W_{1-i},V_i’&#x3D;V_1\setminus W_{1-i}, V’&#x3D;V_0’\cup V_1’$</li>
<li>$E’&#x3D;E\cap(V’\times V’)$</li>
<li>$c’(v)&#x3D;c(v)\text{ for all }v\in V’$</li>
</ul>
<p>Note that $\mathcal{G’}$ is still a game:</p>
<ul>
<li>for $v\in V_i’$, there is a $v\in V\setminus W_{1-i}$ with $(v,v’)\in E’$, otherwise $v$ would be in $W_{1-i}$</li>
<li>for $v\in V_{1-i}’$, for all $v’\in V$ with $(v,v’)\in E’$, $v’\in V\setminus W_{1-i}$, hence there is a $v’\in V’$ with $(v,v’)\in E$.</li>
</ul>
<p>Let $c’^{−1}(k)&#x3D;\lbrace v\in V’\mid c’(v)&#x3D;k\rbrace$ (set of highest color positions in $V’$), and<br>Let $Y&#x3D;Attr_i’(c’^{-1}(k))$. (attractor here means the set of positions that at least visit $c’^{-1}(k)$ once)<br>Let $\sigma_A$ be the corresponding attractor strategy on $\mathcal{G’}$ into $c’^{-1}(k)$, as defined in the proof of <a href="../agv11-2/">Theorem 11.1</a>.</p>
<p>Now consider the subgame $\mathcal{G’’}$:</p>
<ul>
<li>$V_0’’ &#x3D; V_0’\setminus Y,V_i’’&#x3D;V_1’\setminus Y, V’’&#x3D;V_0’’\cup V_1’’$</li>
<li>$E’’&#x3D;E’\cap(V’’\times V’’)$</li>
<li>$c’’:V’’\rightarrow\lbrace 0,\dots,k-1\rbrace;c’’(v)&#x3D;c’(v)\text{ for all }v\in V’’$</li>
</ul>
<p>Note that $\mathcal{G’’}$ is still a game, and that the maximal color in $\mathcal{G’’}$ is at most $k−1$ (we removed position that color as $k$ and positions that can visit it by Player $i$). By induction hypothesis, that $\mathcal{G’’}$ is memoryless determined. </p>
<p>It is also clear that $W_{1-i}’’$, the set of positions in game $\mathcal{G’’}$ where Player (1−$i$) has a memoryless winning strategy, is empty, because $W_{1-i}’’$ is a subset of $W_{1-i}$: </p>
<p>assume Player (1−$i$) had a memoryless winning strategy from some position in $V’’$. Then this strategy would win in $\mathcal{G}$, too, since Player $i$ has no opportunity to leave $\mathcal{G’’}$ other than to $W_{1-i}$. </p>
<p>Hence, there is a uniform winning memoryless winning strategy $\sigma_{IH}$ for player $i$ from all positions in $V’’$. We define the following uniform strategy $\sigma$ for Player $i$ in game $\mathcal{G}$:</p>
<p>$$\sigma(v)&#x3D;\left\lbrace\begin{array}{ll}<br>\sigma_{IH}(v)&amp;\text{if }\ v\in V’’\newline<br>\sigma_{A}(v)&amp;\text{if }\ v\in V\setminus c’^{-1}(k)\newline<br>\text{min. successor in }V\setminus W_{1-i}&amp;\text{if }\ v\in V\cap c’^{-1}(k)\newline<br>\text{min. successor in }V&amp;\text{otherwise.}\newline<br>\end{array}\right.<br>$$</p>
<p>The strategy $\sigma$ is winning for Player 0 on $V\setminus W_{1−\sigma}$. Consider a play that is consistent with $\sigma$, it can be either:</p>
<ol>
<li><p>$Y$ (Set of positions that Player 0 can visit the highest color $k$) is visited infinitely often. Thus, Player $i$ wins.</p>
</li>
<li><p>Eventually only positions in $V’’$ are visited. Hence, since Player $i$ follows $\sigma_{IH}$, Player $i$ wins.</p>
</li>
</ol>
<h2 id="Construct-W-1−i-with-McNaughton’s-algorithm"><a href="#Construct-W-1−i-with-McNaughton’s-algorithm" class="headerlink" title="Construct $W_{1−i}$ with McNaughton’s algorithm"></a>Construct $W_{1−i}$ with McNaughton’s algorithm</h2><p>The proof above is non-constructive in the sense that we begin the argument by considering (rather than computing) the set $W_{1−i}$ of positions where the opponent, Player (1−$i$), has a memoryless winning strategy. McNaughton’s algorithm, one of the classic algorithms for parity games over finite arenas, computes this set iteratively, with repeated recursive calls:</p>
<blockquote>
<p>$\textbf{Construction 11.3. } \text{Let a finite parity game }\mathcal{G} &#x3D; (\mathcal{A},\small\text{PARITY} \normalsize(C))\text{ be given. We compute the}\newline\text{winning regions }W_0(\mathcal{G})\text{ and }W_1(\mathcal{G})\text{ as follows. (To avoid confusion we indicate in each attractor}\newline\text{construction explicitly the game it refers to.)}$<br>$\newline<br>\text{Function }\textit{McNaughton}(\mathcal{G})&#x3D;\newline<br>\begin{array}{ll}<br>  \hspace{1cm} 1. &amp; k:&#x3D;\text{ highest color in }\mathcal{G}\newline<br>  \hspace{1cm} 2. &amp; \textbf{if }k&#x3D;0\text{ or }V&#x3D;\varnothing\newline<br>  &amp;\textbf{then return }(V,\varnothing)\newline<br>  \hspace{1cm} 3. &amp; i:&#x3D;k\text{ mod }2\newline<br>  \hspace{1cm} 4. &amp; W_{1-i}:&#x3D;\varnothing\newline<br>  \hspace{1cm} 5. &amp; \textbf{repeat}\newline<br>  &amp;\begin{array}{ll}<br>    \hspace{0.5cm} (a) &amp; \mathcal{G}’:&#x3D;\mathcal{G}\setminus Attr^i(c^{-1}(k),\mathcal{G})\newline<br>    \hspace{0.5cm} (b) &amp; (W_0’,W_1’):&#x3D;\textit{McNaughton}(\mathcal{G}’)\newline<br>    \hspace{0.5cm} (c) &amp; \textbf{if }(W_{1-i}’&#x3D;\varnothing)\textbf{ then}\newline<br>    &amp;\begin{array}{rl}<br>      \ \text{i.}  &amp; W_i:&#x3D;V\setminus W_{1-i}\newline<br>      \ \text{ii.} &amp; \textbf{return }(W_0,W_1)\newline<br>    \end{array}\newline<br>    \hspace{0.5cm} (d) &amp; W_{1-i}:&#x3D;W_{1-i}\cup Attr^{1-i}(W_{1-i}’,\mathcal{G})\newline<br>    \hspace{0.5cm} (e) &amp; \mathcal{G}’:&#x3D;\mathcal{G}\setminus Attr^{1-i}(c^{-1}(W_{1-i}’,\mathcal{G})\newline<br>  \end{array}<br>\end{array}$</p>
</blockquote>
<h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p><strong>(Line 1):</strong> The construction begins by determining the highest color $k$ that appears in the arena. </p>
<p><strong>(Line 2):</strong> If this color is 0 (or the arena is empty), then Player 0 wins the game from all positions, function ends.</p>
<p><strong>(Line 3):</strong> Otherwise we continue by analyzing the game from the perspective of Player $i &#x3D; 0$ if $k$ is even and from the perspective of Player $i &#x3D; 1$ if $k$ is odd. </p>
<p><strong>(Line 4):</strong> We initialize the winning region for the opponent to $\varnothing$ and repeat the following: </p>
<p><strong>(Line 5a):</strong> First, we eliminate all positions where Player $i$ can enforce a visit to the highest color $k$ (which, if visited infinitely often, is beneficial for Player $i$). </p>
<p><strong>(Line 5b):</strong> We recursively solve the resulting subgame $\mathcal{G}’$. </p>
<p><strong>(line 5c):</strong> If the oppoent does not have any winning positions in the subgame, then we are done: </p>
<ul>
<li><p>If the play of $\mathcal{G}$ stays in the subgame, then Player $i$ wins with the winning strategy of the subgame.</p>
</li>
<li><p>If the play leaves the subgame, then Player $i$ can enforce a visit to the highest color.</p>
</li>
</ul>
<p>So either the play eventually stays in the subgame forever, and Player $i$ wins there, or it infinitely often leaves the subgame, and Player $i$ wins by visiting the highest color infinitely often. </p>
<p><strong>(line 5d):</strong> If the opponent wins from some non-empty winning region $W_{1−i}’$ of the subgame, then we add the opponent’s attractor of $W_{1−i}’$ to the winning region of $\mathcal{G}$.</p>
<ul>
<li><p>The opponent is sure to win from every position in the attractor by first ensuring a visit to $W_{1−i}’$ and then staying there forever applying its winning strategy inside $\mathcal{G}’$.</p>
</li>
<li><p>Player $i$ cannot force the game out of the subgame, because $\mathcal{G}’$ was constructed by removing Player $i$’s attractor from $\mathcal{G}$.</p>
</li>
</ul>
<p><strong>(line 5e):</strong> We remove the entire attractor from $\mathcal{G}$ (line 5e) and continue with the resulting subgame.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>Consider again the example above. </p>
<p><strong>(line 1):</strong> The highest color is $k&#x3D;4$,<br><strong>(line 3):</strong> k is even, hence $i&#x3D;0$.<br><strong>(line 5a):</strong> We have that $c^{-1}(4)&#x3D;\lbrace v_4, v_8\rbrace$ and $Attr^0(c^{-1}(4))&#x3D;Attr^0(\lbrace v_4,v_8\rbrace)&#x3D;\lbrace v_3,v_4,v_6,v_7,v_8\rbrace$. Hence, $\mathcal{G}’$ is the subgame consisting of positions $v_0$, $v_1$, $v_2$, and $v_5$:</p>
<p><img src="/images/notes/uds/agv/11_4_eg1.png"></p>
<p><strong>(line 5b):</strong> The recursive call returns $W_0’&#x3D;\varnothing, W_1’&#x3D;\lbrace v_0,v_1,v_2,v_5\rbrace$. (We skip over the evaluation of the recursive call here, note that Player 1 wins from every position with a strategy that moves from $v_2$ to $v_5$.)<br><strong>(line 5d):</strong> We have that $Attr^1(\lbrace v_0,v_1,v_2,v_5\rbrace)&#x3D;\lbrace v_0,v_1,v_2,v_4,v_5,v_8\rbrace$. Hence, $W_1$ is set to $\lbrace v_0,v_1,v_2,v_4,v_5,v_8\rbrace$,<br><strong>(line 5e):</strong> And $\mathcal{G}$ is reduced to the subgame consisting of positions $v_3$, $v_6$ and $v_7$:</p>
<p><img src="/images/notes/uds/agv/11_4_eg2.png"></p>
<p><strong>(line 5b):</strong> Now, the game does not contain any positions with color 4 anymore, we therefore call the algorithm recursively. It returns $W_0’&#x3D;\lbrace v_3,v_6,v_7\rbrace, W_1’&#x3D;\varnothing$. (We again skip over the evaluation of the recursive call, note that all plays are winning for Player 0.)<br><strong>(line 5ci):</strong> Since $W_1’&#x3D;\varnothing$, we set $W_0$ to $V\setminus W_1$,<br><strong>(line 5cii):</strong> Return the final result $W_0&#x3D;\lbrace v_3,v_6,v_7\rbrace$, $W_1&#x3D;\lbrace v_0,v_1,v_2,v_4,v_5,v_8\rbrace$.</p>
<hr>
<p>Next chapter: <a href="../agv8811-5/">Muller Games</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-12T23:27:50.000Z" title="13/02/2025, 00:27:50">2025-02-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.408Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 865 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv11-3/">AGV 11.3 -- Büchi Games</a></p><div class="content"><p>Previous chapter: <a href="../agv11-2/">Reachability Games</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Recurrence-Construction"><a href="#Recurrence-Construction" class="headerlink" title="Recurrence Construction"></a>Recurrence Construction</h2><p>In a Büchi game, the goal of Player 0 is to visit some accepting position <strong>infinitely often</strong>. The attractor construction checks whether there is a strategy which enforces at least one visit to an accepting position. Reaching an accepting state at least once is indeed a necessary precondition, but we also have to ensure that from this position we can enforce a second visit to some accepting state, then a third, and so forth.</p>
<p>The <strong>recurrence construction</strong> computes the largest subset of the accepting states from which Player 0 can enforce infinitely many subsequent visits to the subset.</p>
<blockquote>
<p>$\textbf{Construction 11.2. } \text{Let an arena }\mathcal{A} &#x3D; (V_0,V_1,E)\text{ with }V&#x3D;V_0\cup V_1\text{ be given. The }\newline\textit{recurrence construction}\text{ on }\mathcal{A}\text{ is defined for all }n\in\mathbb{N}\text{ and }F\subseteq V\text{ as:}$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ W_n^1(F) &amp;&#x3D;&amp; V\setminus Attr^0(Recur_n(F))\newline<br>\hspace{1cm} \cdot \ Recur_{0}(F)&amp;&#x3D;&amp;F \newline<br>\hspace{1cm} \cdot \ Recur_{n+1}(F)&amp;&#x3D;&amp;Recur_{n}(F)\setminus CPre^{1}(W_n^1(F)) \newline<br>\hspace{1cm} \cdot \ Recur(F)&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcap} Recur_{n}(R)\newline<br>\end{array}$</p>
</blockquote>
<p>The set $W_n^1(F)$ contains those positions in $V$ from which Player 1 can enforce that at most $n$ visits to $F$.</p>
<p>The set $CPre^{1}(W_n^1(F))$ adds those positions in $V$ from which move to positions in $W_n^1(F)$, meaning that there are at most $n+1$ visits to $F$ in newly added positions.</p>
<p>The set $Recur_{n}(F)$ contains the subset of $F$ from which Player 0 can enforce at least $n$ <em>further</em> (i.e., a total of at least $n+1$) visits to $F$.</p>
<p>The set $Recur(F)$ contains the subset of $F$ from which Player 0 can enforce infinitely many visits to $F$. The recurrence construction solves a game with winning condition $\small\text{BÜCHI} \normalsize (F)$ as follows:</p>
<blockquote>
<p>$$<br>W_0(\mathcal{G})&#x3D;Attr^0(Recur(F)),\ W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})<br>$$</p>
</blockquote>
<p>$$<br>\text{Position of Player 0: Circles;}\ \ \text{Positions of Player 1: rectangles.}$$ </p>
<p><img src="/images/notes/uds/agv/11_3_recur1.png"></p>
<p><img src="/images/notes/uds/agv/11_3_recur2.png"></p>
<p><img src="/images/notes/uds/agv/11_3_recur3.png"></p>
<blockquote>
<p>$\textbf{Theorem 11.2. } \textit{Büchi games are memoryless determined. It holds that}\newline W_0(\mathcal{G})&#x3D;Attr^0(Recur(F)), W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})\textit{. Both players have a uniform winning strategy.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We show for all positions $v\in V$ that</p>
<p>If $v\in Attr^0(Recur(F))$, then $v\in W_0(\mathcal{G})$, with the following uniform memoryless strategy $\sigma$:</p>
<ul>
<li><p>We fix some arbitrary total ordering on $V$. For $v\in (Attr^0(Recur(F))\setminus Recur(F))\cap V_0$, we follow the attractor strategy from the proof of <a href="../agv11-2/">Theorem 11.1</a>. </p>
</li>
<li><p>For $v\in Recur(F)\cap V_0$, we choose the smallest $v’\in V$ with $(v,v’)\in E$ and $v’\in Attr^0(Recur(F))$. Such a successor must exist, because otherwise $v\in CPre^{1}(W_n^1(F))$ for some $n\in\mathbb{N}$, and hence $v\notin Recur(F)$.</p>
</li>
<li><p>Every play that is consistent with $\sigma$ visits $Recur(F)\subseteq F$ infinitely often. Hence, $\sigma$ is winning for Player 0.</p>
</li>
</ul>
<p>If $v\in V\setminus Attr^0(Recur (F))$, then $v\in W_1(\mathcal{G})$, with the following uniform memoryless strategy $\tau$:</p>
<ul>
<li><p>We again fix an arbitrary total ordering on $V$. We define the memoryless strategies $\tau$ such taht, for $n\in\mathbb{N}$, if a play starts in $v\in W_n^1&#x3D;V\setminus Attr^0(Recur_n(F))$ and is consistent with $\tau$, there are at most $n$ visits to $F$.</p>
<ul>
<li><p>For $n&#x3D;0$ let $\tau(v)$ be the smallest $v’\in V$ such that $(v,v’)\in E$ and $v’\in V\setminus Attr^0(F)$. </p>
</li>
<li><p>For $n&gt;0$ let $\tau(v)$ be the smallest $v’\in W_{n-1}^1(F)$ with $(v,v’)\in E$ if $v\in CPre^1(W_{n-1}^1(F))$, otherwise be the smallest $v’$ in $W_{n}^1(F)$ with $(v,v’)\in E$. Such a $v’$ always exists as otherwise $v\in Attr^0(Recur (F))$.</p>
</li>
</ul>
</li>
</ul>
<h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p><strong>Strategy for Player 0</strong></p>
<ul>
<li><p>If a position $v$ belongs to $(Attr^0(Recur(F))\setminus Recur(F))\cap V_0$, it must have edges to $Recur(F)$, then choose the smallest $v’$ among those.</p>
</li>
<li><p>If a position $v$ belongs to $Recur(F)\cap V_0$, we need to ensure it will visit $F$ again, so we need to choose an edge that belongs to $Attr^0(Recur(F))$.</p>
</li>
</ul>
<p><strong>Strategy for Player 1</strong></p>
<ul>
<li><p>Every position from Player 1 must belong to $W_n^1$, that ensures that only at most n times visits to $F$, otherwise Player 1 has no choice (belongs to $Attr^0(F)$)</p>
</li>
<li><p>For such $n &#x3D; 0$, we can ensure it never visit $F$ by choosing smallest $v’$ that does not move to $Attr^0(F)$.</p>
</li>
<li><p>For such $n &gt; 0$, if $v$ belongs to $W_{n-1}^1$, then it must have edge(s) that also belongs to $W_{n-1}^1$, otherwise there exist edge(s) belongs to $W_{n}^1$, so that it can stays in winning region of Player 1 without visiting $Attr^0(F)$.</p>
</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv11-4/">Parity Games</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-11T19:48:34.000Z" title="11/02/2025, 20:48:34">2025-02-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.439Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 974 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv11-2/">AGV 11.2 -- Reachability Games</a></p><div class="content"><p>Previous chapter: <a href="../agv11-1/">Infinite Games (Basic Definitions)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Reachability-Condition"><a href="#Reachability-Condition" class="headerlink" title="Reachability Condition"></a>Reachability Condition</h2><p>We will now analyze infinite games for various types of winning conditions. We start with the simple <strong>reachability</strong> condition.</p>
<p>The reachability condition is given as a set $R$ of positions called the reachability set. The reachability condition is satisfied if the play reaches some position in $R$. Formally, for an infinite word $\alpha$ over $\Sigma$, we use $\text{Occ}(\alpha) :&#x3D; \lbrace\sigma\in\Sigma\mid\exists n\in\mathbb{N}.\ \alpha(n)&#x3D;\sigma\rbrace$ to denote the set of all letters occurring in $\alpha$.</p>
<blockquote>
<p>$\textbf{Definition 11.11. } \text{The }\textit{reachability condition }\small\text{REACH} \normalsize(R)\text{ on a set of positions }R\subseteq V\text{ is the set}$</p>
<p>$$<br>\small\text{REACH} \normalsize(R) &#x3D; \lbrace\rho\in V^\omega\mid\text{Occ}(\rho)\cap R\neq\varnothing\rbrace\newline\newline\text{A game }\mathcal{G}&#x3D;(\mathcal{A},\text{Win})\text{ with Win}&#x3D;\small\text{REACH} \normalsize(R)\text{ is called a }\textit{reachability game}\text{ with reachability set }R<br>$$</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>$$<br>\text{Position of Player 0: Circles;}\ \ \text{Positions of Player 1: rectangles.}$$ </p>
<p><img src="/images/notes/uds/agv/11_2_reachability.png"></p>
<p>$$\mathcal{G}&#x3D;(\mathcal{A},\small\text{REACH} \normalsize(R)),\ R&#x3D;\lbrace v_4,v_5\rbrace<br>$$</p>
<ul>
<li>The winning region for Player 0: $W_0(\mathcal{G})&#x3D;\lbrace v_3,v_4,v_5,v_6,v_7,v_8\rbrace$<ul>
<li>Strategy: $\sigma(v_1) &#x3D; v_2, \sigma(v_3) &#x3D; v_4, \sigma(v_7) &#x3D; v_8, \sigma(v_8) &#x3D; v_5$</li>
</ul>
</li>
</ul>
<h2 id="Attractor-Construction"><a href="#Attractor-Construction" class="headerlink" title="Attractor Construction"></a>Attractor Construction</h2><p>Reachability games can be solved with a simple fixed point construction called the <strong>attractor construction</strong>.</p>
<p>The attractor construction computes the winning region for Player 0 iteratively by the <strong>reachability set</strong>:</p>
<ol>
<li>adds all positions owned by Player 0 that <strong>have an edge</strong> into the winning region,</li>
<li>then adds all positions owned by Player 1 where <strong>all edges</strong> lead into the winning region. (no choices)</li>
<li>Repeats until no more positions can be added.</li>
</ol>
<p>In the following, we give a slightly more general definition of the attractor construction that can be applied also to Player 1. We do this in preparation for the constructions for other winning conditions, which will use the attractor construction as a subroutine.</p>
<blockquote>
<p>$\textbf{Construction 11.1. } \text{Let an arena }\mathcal{A} &#x3D; (V,V_0,V_1,E)\text{ be given. The }\textit{attractor construction}\text{ on}\newline\mathcal{A}\text{ is defined for each Player }i\text{, for all }n\in\mathbb{N}\text{ and }R\subseteq V\text{ as follows.}$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ CPre^{i}(R) &amp;&#x3D;&amp; \lbrace v\in V_i\mid\exists v’\in V.(v, v’)\in E\wedge v’\in R\rbrace\cup\ \newline<br>&amp;&amp;\lbrace v\in V_{1-i}\mid\forall v’\in V.(v, v’)\in E\rightarrow v’\in R\rbrace\newline<br>\hspace{1cm} \cdot \ Attr_{0}^{i}(R)&amp;&#x3D;&amp;R \newline<br>\hspace{1cm} \cdot \ Attr_{n+1}^{i}(R)&amp;&#x3D;&amp;Attr_{n}^{i}(R)\cup CPre^{i}(Attr_{n}^{i}(R)) \newline<br>\hspace{1cm} \cdot \ Attr^{i}(R)&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcup} Attr_{n}^{i}(R)\newline<br>\end{array}$</p>
</blockquote>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/11_2_attractor.png"></p>
<p>In general, the attractor construction solves a game with winning condition $\small\text{REACH} \normalsize(R)$ as follows: $W_0(\mathcal{G})&#x3D;Attr^0(R), W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})$. We can furthermore give a uniform memoryless winning strategy. These results are summarized in the following theorem.</p>
<blockquote>
<p>$\textbf{Theorem 11.1. } \textit{Reachability games are memoryless determined. It holds that}\newline W_0(\mathcal{G})&#x3D;Attr^0(R), W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})\textit{. Both players have a uniform winning strategy.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We show for all positions $v\in V$ that</p>
<p>If $v\in Attr^0(R)$, then $v\in W_0(\mathcal{G})$, with the following uniform memoryless strategy $\sigma$:</p>
<ul>
<li>We fix an arbitrary total ordering on $V$ . For $v\in (Attr^0(R)\setminus R)\cap V_0$, let $n &#x3D; min\lbrace n\in\mathbb{N}\mid v\in Attr_{n}^0(R)\rbrace$. Then, let $\sigma(v)$ be the smallest $v’\in Attr_{n-1}^0(R)$ with $(v, v′)\in E$</li>
<li>For every other position $v\in V_0\setminus(Attr^0(R)\setminus R)$, let $\sigma(v)$ be the smallest $v’\in V$ with $(v, v′)\in E$</li>
<li>We show, by induction on $n\in\mathbb{N}$, that any play that starts in $v\in Attr_{n}^0(R)$<br>and is consistent with $\sigma$ reaches $R$ within at most $n$ steps.</li>
</ul>
<p>If $v\in V\setminus Attr^0(R)$, then $v\in W_1(\mathcal{G})$, with the following uniform memoryless strategy $\tau$:</p>
<ul>
<li>We again fix an arbitrary total ordering on $V$. For $v\in V_1\setminus Attr^0(R)$, let $\tau(v)$ be the smallest $v’\in V\setminus Attr^0(R)$ such that $(v, v′)\in E$. Such a successor $v’$ always exists, because otherwise $v\in Attr^0(R)$.</li>
<li>For every other position $v\in V_1\cap Attr^0(R)$ let $\tau(v)$ be the smallest $v’\in V\setminus Attr^0(R)$ with $(v, v′)\in E$. Now let $\rho$ be an arbitrary play that is consistent with $\tau$.</li>
<li>We show, by induction on $n$, that $\rho(n)\notin Attr^0(R)$ and, hence, $\rho(n)\notin R$, for all $n\in\mathbb{N}$.</li>
</ul>
<h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p><strong>Strategy for Player 0</strong></p>
<ul>
<li>A position $v$ belongs to $Attr_{n}^0(R)\setminus R$, must have edges to $v’\in Attr_{n-1}^0(R)$, then choose the smallest $v’$</li>
<li>If a position $v$ does not belong to $Attr^0(R)\setminus R$, simply choose the smallest $v’$ from its edges.</li>
</ul>
<p><strong>Strategy for Player 1</strong></p>
<ul>
<li>If a position $v$ does not belong to $Attr_{n}^0(R)$, it must have any one edge does not move to $Attr^0(R)$, choose the smallest $v’$ among those.</li>
<li>If a position $v$ belongs to $Attr_{n}^0(R)$, since all its edges move to some positions in $Attr_{n}^0(R)$, simply choose the smallest $v’$ from its edges.</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv11-3/">Büchi Games</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-11T16:11:48.000Z" title="11/02/2025, 17:11:48">2025-02-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.408Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">9 minutes read (About 1375 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv11-1/">AGV 11.1 -- Infinite Games (Basic Definitions)</a></p><div class="content"><p>Previous chapter: <a href="../agv10-5/">From semi-deterministic Büchi to deterministic Muller</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now introduce <em>infinite two-player games on finite graphs</em>. Infinite games are useful to solve the synthesis problem, where we are interested in finding a strategy that guarantees that a given specification is satisfied (cf. <a href="../agv1.2/">Section 1.2</a>). As we will see, games also play a fundamental role in automata theory, in particular for automata over infinite trees.</p>
<h2 id="Basic-Definitions"><a href="#Basic-Definitions" class="headerlink" title="Basic Definitions"></a>Basic Definitions</h2><p>The game is played on a graph, called the <strong>arena</strong>. The vertices of the graph are called <strong>positions</strong> and are partitioned into the positions of Player 0 and the positions of Player 1. </p>
<ul>
<li>A play of the game starts in some initial position</li>
<li>In any positions, the player who <strong>owns the position chooses the edge</strong> on which the play is continued.</li>
<li>Player 0 wins if the play is an element of the <strong>winning condition</strong>.</li>
</ul>
<p>The winner is determined by a winning condition, which, like the acceptance condition of an automaton on infinite words is a subset of the infinite words over the positions. </p>
<blockquote>
<p>$\textbf{Definition 11.1. } \text{A }\textit{game arena}\text{ is a tuple }\mathcal{A} &#x3D; (V,V_0,V_1,E)\text{, where}\newline\begin{array}{l}<br>\hspace{0.5cm} \cdot \ V_0\text{ and }V_1&#x3D;V\setminus V_0\text{ are disjoint sets of positions,}\newline<br>\hspace{1cm} \text{called the positions of Player 0 and Player 1.}\newline<br>\hspace{0.5cm} \cdot \ E\subseteq V\times V\text{ is a set of edges such that every position }v\in V\newline<br>\hspace{1cm} \text{has at least one outgoing edge }(v,v’)\in E.\newline<br>\end{array}$</p>
</blockquote>
<blockquote>
<p>$\textbf{Definition 11.2. } \text{A }\textit{play}\text{ is an infinite sequence }  \rho\in V^\omega\text{ such that}$<br>$$\forall n\in\mathbb{N}.(\rho(n),\rho(n+1))\in E$$</p>
</blockquote>
<p>We say a play $\rho$ starts in a position $v$ iff $v&#x3D;\rho(0)$. We denote the set of all possible plays on $\mathcal{A}$ with $\text{Plays}(\mathcal{A})$ and the set of all possible plays starting in position $v$ with $\text{Plays}(\mathcal{A},v)$.</p>
<blockquote>
<p>$\textbf{Definition 11.3. }\text{A }\textit{game }\mathcal{G}&#x3D;(\mathcal{A},\text{Win})\text{ consists of an arena }\mathcal{A}\text{ and a }\textit{winning condition}\newline\text{Win}\subseteq V^\omega\text{. We call a play }\rho\textit{ winning for Player 0}\text{ iif }\rho\in\text{Win and }\textit{winning for Player 1}\text{ otherwise.}$ </p>
</blockquote>
<p>When it is Player $i$’s turn, the current vertex must be a <strong>position</strong> of Player $i$ ($V_i$), all the prefix of the play seen so far (including current vertex) is called the <strong>history</strong> of the <strong>play</strong>, which is an element of $V^\ast V_i$.</p>
<p>A <strong>strategy</strong> fixes the decisions of a player based on the <strong>history</strong> of the play. A <strong>strategy</strong> for Player $i$ is a function $\sigma:V^\ast V_i\rightarrow V$ that selects for each such history a successor position.</p>
<blockquote>
<p>$\textbf{Definition 11.4. }\text{A }\textit{strategy}\text{ for Player }i\text{ is a function }\sigma:V^\ast V_i\rightarrow V\text{ such that }(v,v’)\in E\newline\text{whenever }\sigma(wv)&#x3D;v’\text{ for some }w\in V^\ast,v\in V_i$ </p>
</blockquote>
<p>In the following, we use $\sigma$ and $\tau$ to denote strategies for Player $i$ and the opponent Player $(1−i)$, respectively.</p>
<blockquote>
<p>$\textbf{Definition 11.5. }\text{A play }\rho\text{ is }\textit{consistent}\text{ with a strategy }\sigma\text{ iff}$<br>$$\forall n\in\mathbb{N}.\text{if }\rho(n)\in V_i\text{ then }\rho(n+1)&#x3D;\sigma(\rho[n])$$</p>
</blockquote>
<p>We denote the set of all plays that begin in some position $v$ and are consistent with strategy $\sigma$ with $\text{Plays}(\mathcal{A}, \sigma, v)$. Note that the strategies $\sigma$ and $\tau$ of the two players together uniquely identify a specific play: $\mid \text{Plays}(\mathcal{A}, \sigma, v)\cap \text{Plays}(\mathcal{A}, \tau, v)\mid &#x3D; 1$. </p>
<p>Our definition of a strategy is very general in the sense that the decisions are based on the entire history of the play. Intuitively, this means that the players have infinite memory. It often suffices to work with simpler strategies, such as <strong>memoryless</strong> strategies. <strong>Memoryless</strong> strategies are often also called <strong>positional</strong>.</p>
<blockquote>
<p>$\textbf{Definition 11.6. }\text{A strategy }\sigma\text{ for Player }i\text{ is }\textit{memoryless}\text{ iff }\sigma(wv)&#x3D;\sigma(v)\text{ for all }w\in V^\ast,v\in V_i.$</p>
</blockquote>
<p>In a slight abuse of notation, memoryless strategies are often given directly as a function $\sigma:V_i\rightarrow V$ that maps the positions owned by Player $i$ to their successor positions. Next, we characterize <strong>winning</strong> strategies:</p>
<blockquote>
<p>$\textbf{Definition 11.7. }\text{A strategy }\sigma\text{ for Player }i\text{ is }\textit{winning}\text{ from a position }v\text{ if all plays that}\newline\text{start in }v\text{ and that are consistent with }\sigma\text{ are winning for Player }i.$</p>
</blockquote>
<p>Note that this definition refers to a specific position $v$ in which we start the play. The set of all positions where the player has a winning strategy is called the <strong>winning region</strong>.</p>
<blockquote>
<p>$\textbf{Definition 11.8. }\text{ The }\textit{winning region }W_i(\mathcal{G})\text{ of Player }i\text{ in a game }\mathcal{G}\text{ is defined as}\newline\text{the set of positions }v\in V\text{ for which there exists a strategy for Player }i\text{ that is winning from }v.$</p>
</blockquote>
<p>Note that the strategies for different positions in the winning region may be different. If a strategy $\sigma$ is winning from all positions of the winning region, we call $\sigma$ a <strong>uniform winning strategy</strong>.</p>
<p>It is easy to see that no position can be in the winning regions of both players. Otherwise there exists a position $v$ and strategies $\sigma$ and $\tau$ that are winning from $v$ for Player 0 and 1, respectively. Then the unique play that is consistent with $\sigma$ and $\tau$ need to be both in Win, because $\sigma$ is winning, and not in Win, because $\tau$ is winning. </p>
<p>A more difficult question is whether all positions are in some winning region, i.e., whether the winning regions form a partition of $V$. This property is called the <strong>determinacy</strong> of a game:</p>
<blockquote>
<p>$\textbf{Definition 11.9. }\text{A }\textit{game }\mathcal{G}\text{ is }\textit{determined }\text{if }V&#x3D;W_0(\mathcal{G})\cup W_1(\mathcal{G})$</p>
</blockquote>
<p>If the winning strategies are in fact memoryless, we say the game is <strong>memoryless</strong> (<strong>positionally</strong>) determined.</p>
<blockquote>
<p>$\textbf{Definition 11.10. }\text{A game is }\textit{memoryless determined }\text{if for every position }v\in V\text{, there exists}\newline\text{a memoryless stratey that is winning for some player from position }v.$</p>
</blockquote>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this section, we have learned:</p>
<ul>
<li><p><strong>Arena</strong>: the graph of the game, expressed as a tuple $\mathcal{A}&#x3D;(V,V_0,V_1,E)$</p>
<ul>
<li><strong>Position</strong>: vertex of Arena $v\in V$</li>
<li><strong>Positions of Player $i$</strong>: a disjoint set of position $V_i$</li>
</ul>
</li>
<li><p><strong>Play</strong>: an infinite sequence of $\rho\in V^\omega$</p>
<ul>
<li><strong>set of all Plays</strong>: $\text{Plays}(\mathcal{A})$</li>
<li><strong>set of all Plays in position $v$</strong>: $\text{Plays}(\mathcal{A},v)$</li>
<li><strong>starting position</strong>: $v &#x3D; \rho(0)$</li>
<li>the player who <strong>owns the position chooses the edge</strong> on which the play is continued ($\rho\in V_i$)</li>
</ul>
</li>
<li><p><strong>Game</strong>: consist of an arena and a winning condition $\mathcal{G}&#x3D;(\mathcal{A},\text{Win})$</p>
<ul>
<li><strong>winning condition</strong>: $\text{Win}\subseteq V^\omega$</li>
<li><strong>winning play for Player 0</strong>: $\rho\in\text{Win}$</li>
<li><strong>winning play for Player 1</strong>: $\rho\notin\text{Win}$</li>
</ul>
</li>
<li><p><strong>history</strong>: all previous positions $V^\ast$</p>
</li>
<li><p><strong>Strategy</strong>: decisions of a player based on history of the play</p>
<ul>
<li><strong>Strategy of Player $i$</strong>: $\sigma:V^\ast V_i\rightarrow V$</li>
<li><strong>Strategy of Player 0</strong>: $\sigma$</li>
<li><strong>Strategy of Player 1</strong>: $\tau$</li>
</ul>
</li>
<li><p><strong>Memoryless (positional) Strategy</strong>: $\sigma(wv)&#x3D;\sigma(v)\text{ for all }w\in V^\ast,v\in V_i$</p>
</li>
<li><p><strong>Winning Region</strong>: set of all positions that Player $i$ has a winning strategy $W_i(\mathcal{G})\in V$  </p>
<ul>
<li><strong>Uniform Winning Strategy</strong>: one strategy that can apply to any position in a winning region.</li>
</ul>
</li>
<li><p><strong>Determinacy</strong>: $\mathcal{G}$ is determined if every position is in some player’s winning region $V&#x3D;W_0(\mathcal{G})\cup W_1(\mathcal{G})$</p>
<ul>
<li>A determined game have winning strategy in every positions.</li>
</ul>
</li>
<li><p><strong>Memoryless Game</strong>: all strategies are memoryless in every position of a determined game</p>
</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv11-2/">Reachability Games</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-11T07:41:39.000Z" title="11/02/2025, 08:41:39">2025-02-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.439Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">2 minutes read (About 259 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-5/">AGV 10.5 -- From semi-deterministic Büchi to deterministic Muller</a></p><div class="content"><p>Previous chapter: <a href="../agv10-4/">Semi-Deterministic Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>From the semi-deterministic Büchi automaton we now build a deterministic Muller automaton. The idea of the construction is to continuously simulate, in the deterministic automaton, the nondeterministic part of the semi-deterministic automaton and to ”attempt” a transition into the deterministic part whenever possible.</p>
<p>In the state of the deterministic automaton we maintain an “array” of states that correspond to these attempts. Along each run of the automaton, there may of course be infinitely many such attempts; we only need a finite array, however, because we do not need to keep track of two different attempts to enter the deterministic part, if they both reach the same state (in this case, we simply track the attempt that entered the deterministic part earlier). </p>
<p>We use an array of size $2m$, where m is the number of states of the deterministic part. The factor two allows us to leave a position of the array empty (“␣”) if an attempt is not continued. This is necessary to distinguish a situation where a previously started attempt failed and, at the same time, a new attempt enters the deterministic part, from the situation where the same attempt ran continuously. The deterministic automaton accepts if there is at least one attempt that runs forever after some point and reaches an accepting state infinitely often.</p>
<hr>
<p>Next chapter: <a href="../agv11-1/">Infinite Games (Basic Definitions)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Notes/UdS/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/Notes/UdS/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Notes/UdS/">1</a></li><li><a class="pagination-link" href="/categories/Notes/UdS/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/Notes/UdS/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>