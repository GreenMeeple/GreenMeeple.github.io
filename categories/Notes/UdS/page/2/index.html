<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: UdS - GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li><a href="/categories/Notes/">Notes</a></li><li class="is-active"><a href="#" aria-current="page">UdS</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-01-29T14:23:24.000Z" title="29/01/2025, 15:23:24">2025-01-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.407Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">10 minutes read (About 1455 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-4/">AGV 10.4 -- Semi-Deterministic Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv10-3/">Closure Properties of Muller automata Under Boolean Operations</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>To prove McNaughton’s theorem, in this subsection, we will introdue the <strong>semi-deterministic Büchi automata</strong>.</p>
<ol>
<li>translate nondeterministic Büchi automata into semi-deterministic Büchi automata.</li>
<li>translate from semi-deterministic Büchi automata to deterministic Muller automata.</li>
</ol>
<h2 id="Semi-deterministic-Buchi-Automata"><a href="#Semi-deterministic-Buchi-Automata" class="headerlink" title="Semi-deterministic Büchi Automata"></a>Semi-deterministic Büchi Automata</h2><p>A <em>semi-deterministic automaton</em> is a (possibly nondeterministic) automaton where all accepting runs ultimately end up in a <strong>subset of the states</strong> from which all transitions are deterministic.</p>
<blockquote>
<p>$\textbf{Definition 10.2. } \text{A Büchi automata }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ is }\textit{semi-deterministic}\text{ if}\newline Q &#x3D; N \uplus D\text{ is a partition of }Q\text{ such that }F\subseteq D, pr_2(T\cap(D\times\Sigma\times Q))\subseteq D\text{, and }\newline(\Sigma,D,\lbrace d\rbrace,T\cap(D\times\Sigma\times D),\small\text{BÜCHI}\normalsize(F)) \text{ is deterministic for every }d\in D.$</p>
</blockquote>
<h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p>$Q &#x3D; N \uplus D:$ a <em>disjoint union symbol</em> $\uplus$ indicates that $N$ and $D$ are two seperated subset.</p>
<p>$D:$ firstly, set of accepting states in part of $D$ ($F\subseteq D$). Then for all transistion starts from $D$ ($T\cap(D\times\Sigma\times Q)$), their successors are also in $D$ ($pr_2(T\cap(D\times\Sigma\times Q))\subseteq D$).</p>
<p>Therefore, we can split such automaton into nondeterministic part $N$ and determinstic part $D$, and the accepting run will end up stays in $D$.</p>
<h2 id="From-Nondeterministic-to-Semi-deterministic-Buchi-Automata"><a href="#From-Nondeterministic-to-Semi-deterministic-Buchi-Automata" class="headerlink" title="From Nondeterministic to Semi-deterministic Büchi Automata"></a>From Nondeterministic to Semi-deterministic Büchi Automata</h2><p>The translation is based on a <strong>subset construction</strong>, where we collect two sets of states:</p>
<ol>
<li>the states that are reachable on the given input word, and</li>
<li>the states that are reachable on some path through an accepting state.</li>
</ol>
<p>A state of the semi-deterministic automaton is accepting if the <strong>two sets become equal</strong>; when this happens, the second set is reinitialized with the subset of accepting states that appear in the first component.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/10_4_nonde.png"></p>
<p><img src="/images/notes/uds/agv/10_4_subset.png"></p>
<p>The subset construction produces a <em>deterministic</em> automaton that accepts a subset of the words accepted by the original automaton. If the two sets are equal infinitely often, we can construct a run of the original automaton that goes through accepting states infinitely often:</p>
<p>intuitively, we can go “backwards” from each position where the two sets have become equal and select a path segment for the original automaton where an accepting state is visited (in the proof below we give a more precise argument using König’s lemma).</p>
<p>There is no general guarantee that the set of reachable states from some position of an accepting run and the set of states reachable on a path through some accepting state are the same. This is illustrated by the following example.</p>
<p><img src="/images/notes/uds/agv/10_4_counter.png"></p>
<p>Let the input word be $\alpha^\omega$. From the initial position of some run, which starts in the initial state $p$, all states are reachable, but only $r$ and $s$ are reachable on paths from $s$.</p>
<p>Ultimately, however, every accepting run must reach (and remain in) positions where the <strong>set of reachable states</strong> and the <strong>set of states reachable on a path through some accepting state</strong> are the same. This is because the set of reachable states can only become smaller finitely often; hence, at some point, the set of reachable states will remain the same from all subsequent positions, including those (future) positions of the accepting run where the run visits an accepting state.</p>
<p>In our semi-deterministic automaton, we therefore start by simulating the given nondeterministic automaton. At any point we allow a nondeterministic transition into the (from then on) deterministic subset construction.</p>
<blockquote>
<p>$\textbf{Construction 10.5. } \text{For a Büchi automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize (F))\text{, we construct the semi-}\newline\text{deterministic Büchi automaton }\mathcal{A’} &#x3D; (\Sigma,Q’,I’,T’,\small\text{BÜCHI}\normalsize (F’))\text{ with }\mathcal{L}(\mathcal{A’})&#x3D;\mathcal{L}(\mathcal{A})\text{ as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ Q’&#x3D;Q\uplus (2^Q\times2^Q)\newline<br>\hspace{1cm} \cdot \ I’&#x3D;I’ \newline<br>\hspace{1cm} \cdot \ T’&#x3D;T\cup\lbrace(q,\sigma,(\lbrace q’\rbrace,\varnothing))\mid(q,\sigma,q’)\in T\rbrace \newline<br>\hspace{2.85cm}\cup \ \lbrace((L_1,L_2),\sigma,(L’_1,L’_2))\mid L_1\neq L_2\newline<br>\hspace{3.8cm}L’_1&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times Q)\newline<br>\hspace{3.8cm}L’_2&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times F)\cup pr_2(T\cap L_2\times\lbrace\sigma\rbrace\times Q)\rbrace\newline<br>\hspace{2.85cm}\cup \ \lbrace((L_1,L_2),\sigma,(L’_1,L’_2))\mid L_1&#x3D; L_2\newline<br>\hspace{3.8cm}L’_1&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times Q)\newline<br>\hspace{3.8cm}L’_2&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times F)\newline<br>\hspace{1cm} \cdot \ F’&#x3D;\lbrace(L,L)\in(2^Q\times2^Q)\mid L\neq\varnothing\rbrace\newline<br>\end{array}$</p>
</blockquote>
<blockquote>
<p>$\textbf{Lemma 10.1. } \textit{For every Büchi automaton }\mathcal{A}\textit{ there exists a semi-deterministic Büchi}\newline\textit{automaton }\mathcal{A’}\textit{ with }\mathcal{L}(\mathcal{A})&#x3D;\mathcal{L}(\mathcal{A’}).$</p>
</blockquote>
<h2 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h2><p>$\mathcal{L}(\mathcal{A’})\subseteq\mathcal{L}(\mathcal{A})$</p>
<p>Let $\alpha\in\mathcal{L}(\mathcal{A’})$ and let $r’&#x3D;q_0q_1\dots q_{n-1}(L_n,L’<em>n)(L</em>{n+1},L’<em>{n+1})\dots$ be an accepting run of $\mathcal{A’}$ on $\alpha$. Since $r’$ is accepting, there is an infinite sequence $i_0i_1\dots$ of indices such that $i_0&#x3D;n$, and, for all $j\geq1$, $L</em>{i_j} &#x3D; L’<em>{i_j}$ and $L’</em>{i_j}\neq\varnothing$. For every $j\geq1$, and every $q’\in L_{i_j}$ there exists a state $q\in L_{i_{j−1}}$ and a sequence $q &#x3D; q_{i_{j−1}} , q_{i_{j−1}+1},\dots, q_{i_j} &#x3D; q’$ such that $(q_k, \alpha(k), q_{k+1})\in T$ for all $k\in \lbrace i_{j−1},\dots,i_j − 1\rbrace$ and $q_k\in F$ for some $k\in\lbrace i_{j−1}+1,\dots,i_j\rbrace$. We use the following notation: $\textit{predecessor}(q’,i_j) :&#x3D; q, \textit{run}(q’,i_0) &#x3D; q_0q_1\dots q_{n−1}q’$ for $L_{i_0} &#x3D; \lbrace q’\rbrace$, and $\textit{run}(q’,i_j)&#x3D;(q_{i_{j−1}+1})(q_{i_{j−1}+2})\dots q_{i_j}$, for $j\geq1$. </p>
<p>Now consider the  j∈N Lij × {j} -labeled tree where the root is labeled with (q ′ , 0) for Li0 &#x3D; {q ′}, and the parent of each node with a label (q ′ , j) is labeled with (predecessor(q ′ , ij ), j − 1). The tree is infinite and finite-branching, and, hence, by K¨onig’s Lemma, has an infinite branch (qi0 , i0),(qi1 , i1), . . ., corresponding to an accepting run of A: run(qi0 , i0) · run(qi1 , i1) · run(qi2 , i2) · . . . </p>
<p>L(A) ⊆ L(A′ ): Let α ∈ L(A) and let r &#x3D; q0, q1, . . . be an accepting run of A on α. Let i ∈ N be an index s.t. qi ∈ F and for all j ≥ i there exists a k &gt; j, such that {q ∈ Q | qi α[i,k] −−−→ q} &#x3D; {q ∈ Q | qj α[j,k] −−−→ q}. The index i exists: ”⊇” holds for all i, because there is a path through qj . Assume, by way of contradiction, that for all i ∈ N, there is a j ≥ i s.t for all k &gt; j ”⊋” holds. Then there exists an i ′ s.t. {q ∈ Q | qi ′ α[i ′ ,k] −−−−→ q} &#x3D; ∅ for all k &gt; i′ . Contradiction. We define a run r ′ of A′ : r ′ &#x3D; q0 . . . qi−1({qi}, ∅)(L1, L′ 1 )(L2, L′ 2 ). . . where Lj and L ′ j are determined by the definition of A′ . To prove that r ′ is accepting, assume otherwise, and let m ∈ N be an index such that Ln ̸&#x3D; L ′ n for all n ≥ m. Then, let j &gt; m be some index with qj ∈ F; hence qj ∈ L ′ j . There exists a k &gt; j such that L ′ k+1 &#x3D; {q ∈ Q | qj α[j,k] −−−→ q} &#x3D; {q ∈ Q | qi α[i,k] −−−→ q} &#x3D; Lk+1. Contradiction.</p>
<hr>
<p>Next chapter: <a href="../agv10-5/">From semi-deterministic Büchi to deterministic Muller</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><i class="fas fa-thumbtack level-item" title="Pinned"></i><span class="level-item">Posted&nbsp;<time dateTime="2024-12-22T15:35:16.000Z" title="22/12/2024, 16:35:16">2024-12-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.405Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">2 minutes read (About 325 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv/">Automata, Games, and Verification (Portal)</a></p><div class="content"><blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1. Introduction"></a>Chapter 1. Introduction</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv1-1/">1.1. Model Checking</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv1-2/">1.2. Synthesis</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv1-3/">1.3. The Logic-Automata Connection</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-2-Buchi-Automata"><a href="#Chapter-2-Buchi-Automata" class="headerlink" title="Chapter 2. Büchi Automata"></a>Chapter 2. Büchi Automata</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv2-1/">2.1. Preliminaries</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv2-2/">2.2. Automata over Infinite Words</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv2-3/">2.3. The Büchi Acceptance Condition</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-3-Buchi’s-Characterization-Theorem"><a href="#Chapter-3-Buchi’s-Characterization-Theorem" class="headerlink" title="Chapter 3. Büchi’s Characterization Theorem"></a>Chapter 3. Büchi’s Characterization Theorem</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv3-1/">3.1. Kleene’s Theorem</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv3-2/">3.2. $\omega$-regular language</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv3-3/">3.3 Closure Properties of the Büchi-recognizable languages (Intersection and Union)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv3-4/">3.4 Closure Properties of the Büchi-recognizable languages (Concatenations)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv3-5/">3.5 Büchi’s Characterization Theorem</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-4-Deterministic-Buchi-Automata"><a href="#Chapter-4-Deterministic-Buchi-Automata" class="headerlink" title="Chapter 4. Deterministic Büchi Automata"></a>Chapter 4. Deterministic Büchi Automata</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv4-1/">4.1. Deterministic vs. Nondeterministic Büchi Automata</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv4-2/">4.2. Complementation of deterministic Büchi Automata</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-5-Complementation-of-Buchi-automata"><a href="#Chapter-5-Complementation-of-Buchi-automata" class="headerlink" title="Chapter 5. Complementation of Büchi automata"></a>Chapter 5. Complementation of Büchi automata</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv5-1/">5.1. Infinite Directed Acyclic Graph (DAG)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv5-2/">5.2. Ranking of DAG</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv5-3/">5.3. Complement Büchi Automaton with Odd Ranking</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-6-Logics-over-Infinite-Sequences"><a href="#Chapter-6-Logics-over-Infinite-Sequences" class="headerlink" title="Chapter 6. Logics over Infinite Sequences"></a>Chapter 6. Logics over Infinite Sequences</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv6-1/">6.1. Linear-Time Temporal Logic (LTL)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-2/">6.2. Expressing Program Properties using LTL</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-3/">6.3. LTL and Counting Languages</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-4/">6.4. Quantified Propositional Temporal Logic (QPTL)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-5/">6.5. Monadic Second-Order Logic of One Successor (S1S)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-6/">6.6. Express QPTL using S1S</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-7/">6.7. S1S$_0$ and Büchi-recognizable LanguageBüchi-recognizable</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-7-Alternating-Buchi-Automata"><a href="#Chapter-7-Alternating-Buchi-Automata" class="headerlink" title="Chapter 7. Alternating Büchi Automata"></a>Chapter 7. Alternating Büchi Automata</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv7-1/">7.1. Alternating Büchi Automata</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv7-2/">7.2. From LTL to Alternating Büchi Automata</a></td>
<td align="left"><a href="../agv7-2/">$\varphi&#x3D;(\Diamond p)\ \mathcal{U}\ (\square q)$</a></td>
</tr>
<tr>
<td align="left"><a href="../agv7-3/">7.3. Translating Alternating to Nondeterministic automata</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-8-Linear-Arithmetic"><a href="#Chapter-8-Linear-Arithmetic" class="headerlink" title="Chapter 8. Linear Arithmetic"></a>Chapter 8. Linear Arithmetic</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv8-1/">8.1. Linear Arithmetic (Theory)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv8-2/">8.2 Encoding real numbers</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv8-3/">8.3 Translation from Linear Arithmetic to Automata</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv8-4/">8.4 Homogenous Inequality Testing is Automatic</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv8-5/">8.5 From Linear Arithmetic to Automata</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-9-LTL-Model-Checking"><a href="#Chapter-9-LTL-Model-Checking" class="headerlink" title="Chapter 9. LTL Model Checking"></a>Chapter 9. LTL Model Checking</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv9-1/">9.1 Automata-based LTL Model Checking with Sequential Circuits</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv9-2/">9.2 Nested depth-first search</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv9-3/">9.3 The Emerson-Lei algorithm</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-10-McNaughton’s-Theorem"><a href="#Chapter-10-McNaughton’s-Theorem" class="headerlink" title="Chapter 10. McNaughton’s Theorem"></a>Chapter 10. McNaughton’s Theorem</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv10-1/">10.1 The Muller Acceptance Condition</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv10-2/">10.2 From Büchi automata to Muller automata</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv10-3/">10.3 Closure Properties of Muller Automata under Boolean Operations</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<p>Next chapter: <a href="../agv/"></a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-17T03:02:09.000Z" title="17/12/2024, 04:02:09">2024-12-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.423Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 513 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv7-2-eg/">AGV -- (Exercise 7.2) LTL to Alternating Büchi Automata</a></p><div class="content"><p>Previous Exercise: <a href=""></a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>This is an example exercise to express LTL formula into Alternating Büchi Automata. For further definitions, you may check <a href="../agv7-2/">Section 7.2</a>.</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Use the <a href="../agv7-2/">construction from the lecture</a> to construct an alternating Büchi automaton $\mathcal{A}$ such that $$\mathcal{L(A)&#x3D;L}((\Diamond p)\ \mathcal{U}\ (\square q))$$</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>we build the following alternating Büchi automaton  $\mathcal{A} &#x3D; (2^{p,q},Q,\varphi,\delta,\small\text{BÜCHI} \normalsize(F))$ which recognizes the models of $\varphi&#x3D;(\Diamond p)\ \mathcal{U}\ (\square q)$. First we consider the transition function $\delta$ for an arbitrary symbol $a\in2^{p,q}:$</p>
<p>$\begin{array}{lll}<br>\hspace{1cm}\bullet &amp;&amp;\delta(\square q,a)\newline<br>&amp;&#x3D;&amp;\delta(\neg(\textit{true}\ \mathcal{U}\ \neg q) ,a)\newline<br>&amp;&#x3D;&amp;\overline{\delta(\textit{true}\ \mathcal{U}\ \neg q ,a)}\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)\vee(\delta(\textit{true},a)\wedge(\textit{true}\ \mathcal{U}\ \neg q))}\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\overline{(\delta(\textit{true},a)\wedge (\textit{true}\ \mathcal{U}\ \neg q))}&amp;(\textit{true}\wedge \psi&#x3D;\psi)\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\overline{(\textit{true}\ \mathcal{U}\ \neg q)}&amp;(\text{Using line 1})\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\square q\newline<br>&amp;&#x3D;&amp;\left\lbrace \begin{array}{lll}<br>\square q&amp;\text{if }q\in a\newline<br>\textit{false}&amp;\text{if }q\notin a\newline<br>\end{array}\right.<br>\end{array}<br>\ \newline \ \newline<br>\begin{array}{lll}<br>\hspace{1cm}\bullet &amp;&amp;\delta(\Diamond p,a)\newline<br>&amp;&#x3D;&amp;\delta(\textit{true}\ \mathcal{U}\ p ,a)\newline<br>&amp;&#x3D;&amp;\delta(p,a)\vee(\delta(\textit{true},a)\wedge\Diamond p)&amp;(\textit{true}\wedge \psi&#x3D;\psi)\newline<br>&amp;&#x3D;&amp;\delta(p,a)\vee\Diamond p\newline<br>&amp;&#x3D;&amp;\left\lbrace \begin{array}{lll}<br>\Diamond p&amp;\text{if }p\notin a\newline<br>\textit{true}&amp;\text{if }p\in a\newline<br>\end{array}\right.<br>\end{array}<br>$</p>
<p>By Substitution above result into $\delta((\Diamond p)\ \mathcal{U}\ (\square q),a)&#x3D;\delta(\square q,a)\vee(\delta(\Diamond p,a)\wedge(\Diamond p)\ \mathcal{U}\ (\square q))$, we have:</p>
<p>$$\delta((\Diamond p)\ \mathcal{U}\ (\square q),a)&#x3D;\left\lbrace<br>\begin{array}{lll}<br>\Diamond p\wedge((\Diamond p)\ \mathcal{U}\ (\square q))&amp;\text{if }a &#x3D;\varnothing &amp;(\vee\ \textit{false}\text{ is omitted.})\newline<br>(\Diamond p)\ \mathcal{U}\ (\square q)&amp;\text{if }a &#x3D;\lbrace p\rbrace&amp;(\wedge\ \textit{true}\text{ is omitted.})\newline<br>\square q\vee(\Diamond p\wedge((\Diamond p)\ \mathcal{U}\ (\square q)))&amp;\text{if }a &#x3D;\lbrace q\rbrace\newline<br>\square q\vee((\Diamond p)\ \mathcal{U}\ (\square q))&amp;\text{if }a &#x3D;\lbrace p,q\rbrace&amp;(\wedge\ \textit{true}\text{ is omitted.})\newline<br>\end{array}\right.$$</p>
<p>For each case, when we see $\vee$, that’s a <strong>nondeterministic transitions</strong>, we need draw two seperate transitions for each successors. On the other hand $\wedge$ is a <strong>universal transitions</strong>, it is a single transition towards both successors, we split the extra branches from the path to indicate that. Thus we have the following automaton $\mathcal{A}$:</p>
<p><img src="/images/notes/uds/agv/7_2_eg.png"></p>
<hr>
<p>Next Exercise: <a href="../agv/"></a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-13T04:02:57.000Z" title="13/12/2024, 05:02:57">2024-12-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.440Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 828 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-3/">AGV 10.3 -- Closure Properties of Muller automata Under Boolean Operations</a></p><div class="content"><p>Previous chapter: <a href="../agv10-2/">From Büchi automata to Muller automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now show that deterministic Muller automata are closed, like nondeterministic Büchi automata, under the Boolean operations (<code>complementation</code>, <code>union</code>, and <code>intersection</code>).</p>
<p>First we introduce the construction of these automaton with operations, then we will prove they are close by the runs under those constructions.</p>
<h2 id="Automata-construction-of-Complementation"><a href="#Automata-construction-of-Complementation" class="headerlink" title="Automata construction of Complementation"></a>Automata construction of Complementation</h2><blockquote>
<p>$\textbf{Construction 10.3. } \text{Let }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F}))\text{ be a complete and deterministic Muller}\newline\text{automaton, where we assume w.l.o.g that }Q\neq\varnothing.\text{ We construct the deterministic Muller}\newline\text{automaton }\mathcal{A}^C &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize(2^Q\setminus\mathcal{F}))\text{ with }\mathcal{L(A^C)}&#x3D;\Sigma\setminus\mathcal{L(A)}.$</p>
</blockquote>
<h2 id="Automata-construction-of-Intersection"><a href="#Automata-construction-of-Intersection" class="headerlink" title="Automata construction of Intersection"></a>Automata construction of Intersection</h2><p>We use the function $pr_n$ for $n\in\mathbb{N}$ to project to the (n+1)th component of a arbitrary length tuple, for example:</p>
<ul>
<li>$pr_0(x, y)&#x3D;x$</li>
<li>$pr_1(x, y)&#x3D;y$</li>
<li>$pr_2(x, y),pr_3(x, y),\dots pr_n(x, y) &#x3D;\text{Undefined}$</li>
</ul>
<p>We can also apply the projection to a set and return a <strong>set of components</strong>: $pr_n(S) &#x3D; \bigcup_{s∈S}{pr_n(s)}.$</p>
<blockquote>
<p>$\textbf{Construction 10.4. } \text{For Muller automata }\mathcal{A_1} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F_1}))\text{ and}\newline\mathcal{A_2} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F_2}))\text{ over the same alphabet }\Sigma.\text{ We construct the Muller Automaton}\newline\mathcal{A}_\cap &#x3D; (\Sigma,Q_1\times Q_2,I_1\times I_2,T_\cap,\small\text{MULLER} \normalsize(\mathcal{F_\cap}))\text{ with }\mathcal{L(A_\cap)}&#x3D;\mathcal{L(A_1)}\cap\mathcal{L(A_2)}\text{ and where }\mathcal{A_\cap}\text{ is}\newline\text{deterministic if }\mathcal{A_1}\text{ and }\mathcal{A_2}\text{ are deterministic, as follows:}$</p>
<p>$\begin{array}{l}\hspace{1cm}\cdot \ T_\cap&#x3D;\lbrace((q_1,q_2),\sigma,(q’_1,q’_2))\mid(q_1,\sigma,q’_1)\in T_1,(q_2,\sigma,q’_2)\in T_2\rbrace\newline\hspace{1cm}\cdot \ \mathcal{F}_\cap &#x3D; \lbrace P\subseteq Q_1\times Q_2\mid pr_0(P)\in\mathcal{F_1},pr_1(P)\in\mathcal{F_2}\rbrace\end{array}$</p>
</blockquote>
<h2 id="Closure-Properties-of-under-Boolean-Operations"><a href="#Closure-Properties-of-under-Boolean-Operations" class="headerlink" title="Closure Properties of under Boolean Operations"></a>Closure Properties of under Boolean Operations</h2><blockquote>
<p>$\textbf{Theorem 10.3. } \textit{The languages recognizable by deterministic Muller automata are closed}\newline\textit{under Boolean operations (complementation, union, intersection).}.$</p>
</blockquote>
<h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-complementation"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-complementation" class="headerlink" title="Proof of Deterministic Muller automata are closed under complementation"></a>Proof of Deterministic Muller automata are closed under complementation</h3><p>For a deterministic Muller automaton $\mathcal{A}$, the automaton $\mathcal{A’}$ of Construction 10.3 recognizes the <code>complement</code> language, because any set $F\notin F$ has to be in the <code>complement</code>, i.e., $F\in2^Q\setminus F$.</p>
<h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-Intersection"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-Intersection" class="headerlink" title="Proof of Deterministic Muller automata are closed under Intersection"></a>Proof of Deterministic Muller automata are closed under Intersection</h3><p>For deterministic Muller automata $\mathcal{A_1}$ and $\mathcal{A_2}$, the automaton $\mathcal{A}_\cap$ of Construction 10.4 recognizes the <code>intersection</code>. Let $r_1 &#x3D; q^1_0q^1_1\dots$ and $r_2 &#x3D; q^2_0q^2_1\dots$ be accepting runs of $\mathcal{A_1}$ and $\mathcal{A_2}$ on some $\alpha$. Then $r&#x3D;(r^1_0,r^2_0)(r^1_1,r^2_1)\dots$ is an accepting run of $\mathcal{A}_\cap$ on $\alpha$ and vice versa.</p>
<h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-Union"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-Union" class="headerlink" title="Proof of Deterministic Muller automata are closed under Union"></a>Proof of Deterministic Muller automata are closed under Union</h3><p>It can be proved by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s laws</a> if they are closed under <code>complement</code> and <code>intersection</code>:</p>
<p>$$\Sigma\setminus(\mathcal{L(A_1)}\cap\mathcal{L(A_2)})&#x3D;(\Sigma\setminus\mathcal{L(A_1)})\cup(\Sigma\setminus\mathcal{L(A_2)})$$</p>
<h2 id="Regular-language-and-Limit-operator"><a href="#Regular-language-and-Limit-operator" class="headerlink" title="Regular language and Limit operator"></a>Regular language and Limit operator</h2><p>Similar to Büchi automata in <a href="../agv4-1/">section 4.1</a>, we can define an $\omega$-regular language from regular language, which is recognizable by deterministic Muller Automata:</p>
<blockquote>
<p>$\textbf{Theorem 10.4. }\textit{An language }L\textit{ is recognizable by a deterministic Muller Automata if and only}\newline\textit{if }L\textit{ is a Boolean combination of langauges }\overrightarrow{W}\textit{ where }W\subseteq\Sigma^*\text{ is regular.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>$”\Leftarrow”$<br>If $W$ is regular, then $\overrightarrow{W}$ is recognizable by a deterministic Büchi automaton. Hence, $\overrightarrow{W}$ is recognizable by a deterministic Muller automaton. Thus, the boolean combination $\mathcal{L}$ is recognizable by a deterministic Muller automaton.</p>
<p>$”\Rightarrow”$<br>A deterministic Muller automaton $\mathcal{A}$ accepts some word $\alpha$ with a unique run $r$ if for some $F\in\mathcal{F}$ we have that $\text{Inf}(r)&#x3D;F$. Thus, there is some $F\in\mathcal{F}$ such that for all $q\in F$ we have that $\alpha\in\overrightarrow{W_q}$ and for all $q\notin F$ we have that $\alpha\notin\overrightarrow{W_q}$, where $\overrightarrow{W_q}&#x3D;\mathcal{L(A_q)}$ for the finite-word automaton $\mathcal{A}_q&#x3D;(\Sigma,Q,I,T,\lbrace q\rbrace)$. Hence,</p>
<p>$$\alpha\in\underset{F\in\mathcal{F}}{\bigcup}\left(\underset{q\in F}{\bigcap}\overrightarrow{W_q}\cap\underset{q\notin F}{\bigcap}(\Sigma^\omega\setminus\overrightarrow{W_q})\right)$$</p>
<hr>
<p>Next chapter: <a href="../agv10-4/">Semi-Deterministic Büchi Automata</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s laws</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-12T22:37:22.000Z" title="12/12/2024, 23:37:22">2024-12-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.407Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1264 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-2/">AGV 10.2 -- From Büchi automata to Muller automata</a></p><div class="content"><p>Previous chapter: <a href="../agv10-1/">The Muller Acceptance Condition</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>In this section, we want to prove that Muller automata is equivalent to Büchi Automata.</p>
<h2 id="Translate-Buchi-Automata-into-Muller-Automata"><a href="#Translate-Buchi-Automata-into-Muller-Automata" class="headerlink" title="Translate Büchi Automata into Muller Automata"></a>Translate Büchi Automata into Muller Automata</h2><blockquote>
<p>$\textbf{Construction 10.1. } \text{For a (deterministic) Büchi Automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize (F))\newline\text{ we define the (deterministic) Muller automaton } \mathcal{A’} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F}))\text{ using}$</p>
<p>$$\mathcal{F}&#x3D;\lbrace S\subseteq Q\mid S\cap F\neq\varnothing\rbrace$$</p>
</blockquote>
<p>Since the construction does not modify the transitions, the Muller automaton is again deterministic if the Büchi automaton is deterministic. It is straightforward to see that the automata recognize the same language.</p>
<blockquote>
<p>$\textbf{Theorem 10.1. } \textit{For every (deterministic) Büchi automaton }\mathcal{A}\textit{, there is a (deterministic)}\newline\textit{Muller automaton }\mathcal{A’}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A’)}.$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>The automaton $\mathcal{A’}$ of Construction 10.1 complies with our requirements, according to previous section:</p>
<p>$$\small\text{BÜCHI}\normalsize (F)&#x3D;\lbrace\alpha\in Q^\omega\mid\text{Inf}(\alpha)\cap F\neq\varnothing\rbrace&#x3D;\lbrace\alpha\in Q^\omega\mid\text{Inf}(\alpha)\in\mathcal{F}\rbrace&#x3D;\small\text{MULLER}\normalsize(\mathcal{F})$$</p>
<h2 id="Translate-Muller-Automata-into-Buchi-Automata"><a href="#Translate-Muller-Automata-into-Buchi-Automata" class="headerlink" title="Translate Muller Automata into Büchi Automata"></a>Translate Muller Automata into Büchi Automata</h2><p>A slightly more difficult construction is to translate the Muller automaton back into a Büchi automaton.</p>
<blockquote>
<p>$\textbf{Construction 10.2. } \text{Let }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\lbrace F_1,\dots,F_n\rbrace))\text{ be a Muller automaton}\newline\text{and }&lt;\text{ some arbitrary total order on }Q.\text{ We construct the Büchi automaton }\mathcal{A’} &#x3D; (\Sigma,Q’,\newline I’,T’,\small\text{BÜCHI} \normalsize(F’))\text{ with }\mathcal{A’}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A’)}\text{ as follows:}$</p>
<p>$\begin{array}{llll}<br>\hspace{1cm} \cdot \ Q’&amp;&#x3D;Q\cup\overset{n}{\underset{i&#x3D;1}{\bigcup}}(\lbrace i\rbrace\times F_i\times F_i)\newline<br>\hspace{1cm} \cdot \ I’&amp;&#x3D;I\newline<br>\hspace{1cm} \cdot \ T’&amp;&#x3D;T\cup\lbrace(q,\sigma,(i,q’,q’))\mid 1\leq i\leq n,(q,\sigma,q’)\in T, q’\in F_i\rbrace\newline<br>&amp;\hspace{0.9cm}{}\cup\lbrace((i,q,p),\sigma,(i,q’,p’))\mid 1\leq i\leq n,(q,\sigma,q’)\in T,\newline<br>&amp;\hspace{1.5cm}p’&#x3D;\left\lbrace\begin{array}{ll} p &amp;\text{if } q\neq p\newline<br>\text{min}(F_i)&amp;\text{if } q&#x3D;p&#x3D;\text{max}(F_i)\newline<br>\text{min}(F_i\setminus\lbrace r\mid r\leq p\rbrace)&amp;\text{if } q&#x3D;p&lt;\text{max}(F_i),\end{array}\right.\newline&amp;\hspace{1.5cm}q,p,q’ \in F_i\rbrace\newline<br>\hspace{1cm} \cdot \ F’&amp;&#x3D;\overset{n}{\underset{i&#x3D;1}{\bigcup}}(\lbrace i\rbrace\times \lbrace\text{min}(F_i)\rbrace\times \lbrace\text{min}(F_i)\rbrace)\newline<br>\end{array}$</p>
</blockquote>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>A run of the Büchi automaton first simply simulates (while in states $Q$) the Muller automaton and then “guesses” the accepting subset of the Muller automaton. The accepting subset is express by the states $(\lbrace i\rbrace\times F_i\times F_i)$, where</p>
<ul>
<li>The first component &#x3D; the <strong>index</strong> $i$ of the accepting subset,</li>
<li>The second component &#x3D; the <strong>currently visited state</strong> of the Muller automaton, and</li>
<li>The third component &#x3D; the <strong>“next” state</strong> (according to the order on the states) we need to see in order to make progress towards accepting the input word.</li>
</ul>
<p>The purpose of the order $&lt;$ on the states is that we can “step” through the states of the accepting subset in order to make sure that all states in the accepting subset actually occur infinitely often. In transitions $T’$, we have the transitions</p>
<ul>
<li><p>Transitions for all states $Q$ are described by $T$, same as in the original Muller Automaton,</p>
</li>
<li><p>Transitions that contains both states in $Q$ and accepting subset $(\lbrace i\rbrace\times F_i\times F_i)$, it stays in the subset,</p>
</li>
<li><p>Transitions inside the subset,</p>
<ul>
<li>the <strong>“next” state</strong> remain unchanged until the <strong>currently visited state</strong> visits it $(p&#x3D;q)$,</li>
<li>if the <strong>currently visited state</strong> visits <strong>“next” state</strong> and it is the last “step” of the subset, it means we visited the entire subset $F_i$ and we should start from the beginning $\text{min}(F_i)$ again.</li>
<li>otherwise, move one step ahead ($p’ &gt; p$ and $p, p’\in F_i$)</li>
</ul>
</li>
</ul>
<p><strong>The Büchi automaton accepts if we step through the states of the accepting subset infinitely often</strong>.<br>Recall that we used a similar trick in the construction of the Büchi automaton for the <code>intersection</code> of two Büchi-recognizable languages in <a href="../agv3-3/">Construction 3.2.</a></p>
<blockquote>
<p>$\textbf{Theorem 10.2. } \newline\textit{For every Muller automaton }\mathcal{A}\textit{ there is a Büchi automaton }\mathcal{A’}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A’)}.$</p>
</blockquote>
<h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><blockquote>
<p>$\mathcal{L(A)}\subseteq\mathcal{L(A’)}$ (all word accepted by $\mathcal{L(A)}$ must also be accepted by $\mathcal{L(A’)}$):</p>
</blockquote>
<p>Let $\alpha\in\mathcal{L(A)}$ and $r&#x3D;q_0q_1q_2\dots$ be an <strong>accepting</strong> run of $\mathcal{A}$ on $\alpha$. As $r$ is accepting, we have that:</p>
<ul>
<li><p>$\text{Inf}(r)\in\mathcal{F}$, so $r$ must be in one of the accepting subset, i.e. $\text{Inf}(r)&#x3D;F_i$ for some $1\leq i\leq n$,</p>
</li>
<li><p>Let $m$ be the first position that visit some accepting state: $q_j\in\text{Inf}(r)$ for all $j\geq m$,</p>
</li>
<li><p>Now consider some run of $\mathcal{A’}$ on $\alpha:\ r’ &#x3D; q_0q_1\dots q_{m−1}(i, q_m, p_0)(i, q_{m+1}, p_1)(i, q_{m+2}, p_2)\dots$</p>
<ul>
<li>it nondeterministically switches to $(i, q_m, p_0)$ at position $m$.</li>
</ul>
</li>
</ul>
<p>For the sake of contradiction, assume that $r$ is <strong>not accepting</strong>:</p>
<ul>
<li>Then there is a position $k\geq 0$ such that $p_j&#x3D;p_k$ for all $j\geq k$ ($q$ never moves to $p_k$,<strong>“next” state</strong> got stuck).</li>
<li>Then also $q_{m+j}\neq p_j$ for all $j\geq k$. However, this contradicts that $p_k\in F_i$.<br>(if q can never reach $p_k$, then it is not an accepting state and thus contradicts with the definition of the subset)</li>
</ul>
<blockquote>
<p>$\mathcal{L(A)}\supseteq\mathcal{L(A’)}$ (all word accepted by $\mathcal{L(A’)}$ must also be accepted by $\mathcal{L(A)}$):</p>
</blockquote>
<p>Let $\alpha\in\mathcal{L(A’)}$, $r’ &#x3D; q_0q_1\dots q_{m−1}(i, q_m, p_0)(i, q_{m+1}, p_1)(i, q_{m+2}, p_2)\dots$ be some accepting run of $\mathcal{A’}$ on $\alpha$:</p>
<ul>
<li>At some position $m$ it switches to some $(i, q_m, p_0)$, otherwise it would not be accepting.</li>
<li>By construction, $q_j\in\text{Inf}(r)$ for all $j\geq m$ (it starts staying in the accepting subset), and</li>
<li>For each $p\in F_i$ there are infinitely many positions $k$ such that $q_k&#x3D;p_k&#x3D;p$.<ul>
<li>($q$ always reach every <strong>“next” state</strong> infinitely often at some positions)</li>
</ul>
</li>
</ul>
<p>Thus, we can construct an accepting run $r&#x3D;q_0q_1q_2\dots$ of $\mathcal{A}$ on $\alpha$ by using every $q$ state in the run $r’$, because every second component in the tuple is accepting, i.e. $\text{Inf}(pr_2(r’))&#x3D;p_k&#x3D;F_i$,</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Now we have proved that we can construct an Muller automaton from Büchi automaton and an Büchi automaton from Muller automaton. Therefore they are interchangably equivalent. In the next section, we will prove that deterministic Muller automata are actually closed.</p>
<hr>
<p>Next chapter: <a href="../agv10-3/">Closure Properties of Muller Automata under Boolean Operations</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-11T16:04:07.000Z" title="11/12/2024, 17:04:07">2024-12-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.405Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">4 minutes read (About 618 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-1/">AGV 10.1 -- The Muller Acceptance Condition</a></p><div class="content"><p>Previous chapter: <a href="../agv9-3/">The Emerson-Lei algorithm</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introdcution"><a href="#Introdcution" class="headerlink" title="Introdcution"></a>Introdcution</h2><p>We already established that while the languages that can be recognized with nondeterministic Büchi automata are exactly the $\omega$-regular languages, the languages that can be recognized with deterministic Büchi automata are a strictly smaller set.</p>
<p>We now repair this deficiency with a more expressive acceptance condition, the <strong>Muller condition</strong>. <strong>McNaughton’s theorem</strong> states that the set of languages recognizable by deterministic Muller automata are again exactly the $\omega$-regular languages.</p>
<p>We will see later that it is very useful to have a deterministic automaton for a given $\omega$-language, for example in synthesis, where we construct the game between the system and the environment from a deterministic automaton that recognizes the winning plays for the system player.</p>
<p>Since the complementation of <strong>deterministic Muller automata</strong> is a very simple operation, McNaughton’s theorem also provides an alternative proof for the result of <a href="../agv5-3/">Section 5</a> that the $\omega$-regular languages are closed under complementation.</p>
<h2 id="Muller-Acceptance-Condition"><a href="#Muller-Acceptance-Condition" class="headerlink" title="Muller Acceptance Condition"></a>Muller Acceptance Condition</h2><blockquote>
<p>$\textbf{Definition 10.1. } \text{The }\textit{Muller Acceptance Condition }\small\text{MULLER} \normalsize(\mathcal{F})\text{ on a set of sets of states }\newline\mathcal{F}\subseteq 2^Q\text{ is the set}$</p>
<p>$$\small\text{MULLER}\normalsize(\mathcal{F})&#x3D;\lbrace\alpha\in Q^\omega\mid\text{Inf}(\alpha)\in\mathcal{F}\rbrace$$</p>
<p>$\text{An automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,Acc) \text{ with }Acc &#x3D; \small\text{MULLER} \normalsize(\mathcal{F})\text{ is called a }\textit{Muller Automaton.}\newline\text{The set }\mathcal{F}\text{ is called the set of }\textit{accepting subsets }(\text{or the }\textit{table})\text{ of }\mathcal{A}.$</p>
</blockquote>
<p>Let’s do a small recap from <a href="../agv2-3/">section 2.3</a>:</p>
<ul>
<li><p><strong>Büchi Condition</strong></p>
<ul>
<li>$\small\text{BÜCHI} \normalsize(F) &#x3D; \lbrace\alpha\in Q^\omega \mid \text{Inf}(\alpha) \cap F \neq \varnothing\rbrace$</li>
<li>word $\alpha$ visit some state in set $F$ infinitely often.</li>
</ul>
</li>
<li><p><strong>Muller Acceptance Condition</strong></p>
<ul>
<li>$\small\text{MULLER}\normalsize(\mathcal{F})$</li>
<li>word $\alpha$ visit some <strong>set of states</strong> in set $\mathcal{F}$ infinitely often.</li>
</ul>
</li>
</ul>
<p>We can see Muller Acceptance Condition are <strong>more expressive</strong> in terms of visiting accepting states, because you can require the word to visit a set of states infinitely often instead just one state out of the whole set.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Consider the deterministic automaton over the alphabet $\Sigma&#x3D;\lbrace a, b\rbrace$ shown below.</p>
<p>For the table $\mathcal{F}&#x3D;\lbrace\lbrace q\rbrace\rbrace$, it means the automaton can only visit $\lbrace q\rbrace$ infinitely often. We obtain the Muller automaton $\mathcal{A}$ recognizing the language $\mathcal{L(A)}&#x3D;(a+b)^\ast b^\omega$;</p>
<p>For the table $\mathcal{F}’&#x3D;\lbrace\lbrace q\rbrace\lbrace p,q\rbrace\rbrace$, it means the automaton has to visit either $\lbrace q\rbrace$ or $\lbrace p,q\rbrace$ infinitely often. We obtain the Muller automaton $\mathcal{A’}$ recognizing $\mathcal{L(A’)}&#x3D;(a^\ast b)^\omega$.</p>
<p><img src="/images/notes/uds/agv/10_1_muller.png"></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>We introduced Muller Acceptance Condition, which is slightly more advanced than the Büchi Acceptance Condition:</p>
<table>
<thead>
<tr>
<th align="left">Aspect</th>
<th align="left">Büchi Acceptance</th>
<th align="left">Muller Acceptance</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Acceptance states</td>
<td align="left">At least one accepting state must appear infinitely often.</td>
<td align="left">The set of states that visited infinitely often must match a subset in $\mathcal{F}$</td>
</tr>
<tr>
<td align="left">Condition Set</td>
<td align="left">$F$ is the set of accepting states</td>
<td align="left">$\mathcal{F}$ is the set of the set of accepting states (subset of the set)</td>
</tr>
<tr>
<td align="left">Expressiveness</td>
<td align="left">Less expressive (<a href="../agv4-1/">example</a>)</td>
<td align="left">Fully expressive</td>
</tr>
<tr>
<td align="left">Complexity</td>
<td align="left">Simpler and easier to implement.</td>
<td align="left">More complex, requires tracking recurring state sets.</td>
</tr>
</tbody></table>
<p>In the following sections, we will discuss about the translation from Büchi automata to Muller automata.</p>
<hr>
<p>Next chapter: <a href="../agv10-2/">From Büchi automata to Muller automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-10T02:56:12.000Z" title="10/12/2024, 03:56:12">2024-12-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 861 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv9-3/">AGV 9.3 -- The Emerson-Lei algorithm</a></p><div class="content"><p>Previous chapter: <a href="../agv9-2/">Nested depth-first search</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>As an alternative algorithm for checking language emptiness of Büchi automata we now discuss a classic algorithm due to Emerson and Lei. Unlike the <a href="../agv9-2/">depth-first search</a> of the previous subsection, the <strong>Emerson-Lei algorithm</strong> is based on a <strong>breadth-first search</strong> implemented as a fixpoint construction over sets of states.</p>
<p>A disadvantage of this algorithm is that its running time is <em>quadratic</em>. Nevertheless, algorithms of this type play a major role in <em>symbolic model checking</em>, because the sets of states can often be represented efficiently<br>using data structures like <em>binary decision diagrams</em>.</p>
<h3 id="Live-states"><a href="#Live-states" class="headerlink" title="Live states"></a>Live states</h3><p>A state $q$ of a Büchi automaton is <code>live</code> if some infinite path starting in $q$ visits accepting states infinitely often. This definition is the opposite of <code>safe</code> states, where it never visits accepting states. The idea of the algorithm is to identify the set of <code>live</code> states.  The language of a Büchi automaton is <strong>non-empty</strong> iff it has a <strong>live initial state</strong>.</p>
<p>The <strong>Emerson-Lei algorithm</strong> is based on the following inductive definition:</p>
<blockquote>
<p>$\textbf{Definition 9.1. } \text{For a Büchi automaton and a number }n\in\mathbb{N}\text{, the set of }\textit{n-live states}\text{ is}\newline\text{defined as follows:}$</p>
<p>$\begin{array}{l}<br>\hspace{1cm}\cdot\ \text{every state is 0-live}\newline<br>\hspace{1cm}\cdot\ \text{a state q is (n + 1)-live if some path containing at least one transition leads from }q\newline\hspace{1.3cm}\text{to an accepting n-live state}\newline<br>\end{array}$</p>
</blockquote>
<h3 id="Fixpoint"><a href="#Fixpoint" class="headerlink" title="Fixpoint"></a>Fixpoint</h3><p>Let $\mathit{live}_n$ denote the set of $n$-live states. It is easy to see that $\mathit{live}_{n} \supseteq \mathit{live}_{n+1}$, because $\mathit{live}_{0}$ represents the set of all states in the automaton, and $\mathit{live}_{1}$ are only those which can reach the accepting states. Then $\mathit{live}_{2}$ are those who can only reach the accepting states through some states in $\mathit{live}_{1}$. Therefore set $\mathit{live}_{n+1}$ can never be larger than its previous set $\mathit{live}_{n}$.</p>
<p>Since the set of states is finite, there exists a <strong>fixpoint</strong> $\mathit{live}_k$ such that $\mathit{live}_k&#x3D;\mathit{live}_{k+1}$. Then the set $\mathit{live}_k$ is the set of live states.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/9_2_dfs.png"></p>
<p>In the example from <a href="../agv9-2/">last section</a>, states $q_0$, $q_1$ and $q_2$ are live; states $q_3$, $q_4$, and $q_5$ are only $0$-$\textit{live}$ (you cannot visit other accepting states starting from $q_3$ even though it is an accepting state).</p>
<p>To describe the algorithm, we first introduce a construction that implements a backward breadth-first search as a least fixpoint. The construction computes all states from which a given set of states is reachable.</p>
<blockquote>
<p>$\textbf{Construction 9.1. } \text{For a Büchi Automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ and a set of states}\newline R\subseteq Q\text{, we compute the set of backwards reachable states from }R\text{ as follows:}$</p>
<p>$\begin{array}{llll}<br>\hspace{1cm} \cdot &amp; \textit{Pre}(R)&amp;&#x3D;&amp;\lbrace q\in Q\mid \exists q’\in R,\sigma\in\Sigma,(q,\sigma,q’)\in T\rbrace\newline<br>\hspace{1cm} \cdot &amp; \textit{BackwardReach}_0(R)&amp;&#x3D;&amp;R\newline<br>\hspace{1cm} \cdot &amp; \textit{BackwardReach}_{n+1}(R)&amp;&#x3D;&amp;\textit{BackwardReach}_{n}(R)\cup\textit{Pre}(\textit{BackwardReach}_{n}(R))\newline<br>\hspace{1cm} \cdot &amp; \textit{BackwardReach}(R)&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcup}\textit{BackwardReach}_{n}(R)\newline<br>\end{array}$</p>
</blockquote>
<p>By this construction, it returns a set of states that can reach some states in $R$. For example, $\lbrace q_0,q_1,q_2\rbrace$ can reach $q_3$. Using this construction as a subroutine, we can compute the live states as a greatest fixpoint:</p>
<blockquote>
<p>$\textbf{Construction 9.2. } \text{For a Büchi Automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ we compute the set}\newline\text{of live states as follows:}$</p>
<p>$\begin{array}{llll}<br>\hspace{1cm} \cdot &amp; \textit{live}_0&amp;&#x3D;&amp;Q\newline<br>\hspace{1cm} \cdot &amp; \textit{live}_{n+1}&amp;&#x3D;&amp;\textit{BackwardReach}(\textit{Pre}(\textit{live}_n\cap F))\newline<br>\hspace{1cm} \cdot &amp; \textit{live}&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcap}\textit{live}_{n}\newline<br>\end{array}$</p>
</blockquote>
<p>The set of $\textit{live}$ is the smallest subset of all $\textit{live}_n$ in any $n\in\mathbb{N}$. Therefore the function will stop when $\mathit{live}_k$ such that $\mathit{live}_k&#x3D;\mathit{live}_{k+1}$, which is the greatest fixpoint of the set of <code>live</code> states.</p>
<p>Then we can verify whether the automaton is non-empty, i.e. $q_0\in\textit{live}$.</p>
<h3 id="Example-cont"><a href="#Example-cont" class="headerlink" title="Example (cont.)"></a>Example (cont.)</h3><p>We compute the live states as follows:</p>
<p>$\begin{array}{llll}<br>\hspace{1cm} \cdot &amp; \textit{live}_0&amp;&#x3D;&amp;\lbrace q_0,q_1,q_2,q_3,q_4,q_5\rbrace\newline<br>\hspace{1cm} \cdot &amp; \textit{live}_1&amp;&#x3D;&amp;\lbrace q_0,q_1,q_2\rbrace\newline<br>\hspace{1cm} \cdot &amp; \textit{live}_2&amp;&#x3D;&amp;\lbrace q_0,q_1,q_2\rbrace\newline<br>\hspace{1cm} \cdot &amp; \textit{live}&amp;&#x3D;&amp;\lbrace q_0,q_1,q_2\rbrace\newline<br>\end{array}$</p>
<p>Since the initial state $q_0$ is <code>live</code>, we have that the language of the automaton is <strong>non-empty</strong>.</p>
<hr>
<p>Next chapter: <a href="../agv10-1/">The Muller Acceptance Condition</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-09T15:52:17.000Z" title="09/12/2024, 16:52:17">2024-12-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 770 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv9-2/">AGV 9.2 -- Nested depth-first search</a></p><div class="content"><p>Previous chapter: <a href="../agv9-1/">Automata-based LTL Model Checking with Sequential Circuits</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now develop an algorithm for checking whether the language of a given Büchi automaton is <code>empty</code>. A natural idea is to use <strong>depth-first search (DFS)</strong> twice.</p>
<p>The language is non-empty $\Leftrightarrow$ it is accepted by some words:</p>
<ol>
<li>there exists an accepting state $q$,</li>
<li>$q$ is reachable from some initial state (discovered by 1st DFS), and</li>
<li>$q$ can again be reached from $q$ (discovered by 2nd DFS),</li>
</ol>
<h2 id="Example-Simple-DFS"><a href="#Example-Simple-DFS" class="headerlink" title="Example (Simple DFS)"></a>Example (Simple DFS)</h2><p>Consider the following Büchi automaton (edge labels do not matter and are omitted).</p>
<p><img src="/images/notes/uds/agv/9_2_dfs.png"></p>
<p><code>Step 1</code>: discovers $q_0$, $q_1$, and $q_3$.<br><code>Step 2</code>: searches from $q_0$ and $q_3$: not successful; searches from $q_1$: discovers the path back to $q_1$ via $q_2$.</p>
<p>The drawback of the algorithm discussed so far is its <strong>quadratic running time</strong>: potentially, each state in $F$ discovered by the first DFS requires a fresh second DFS. The quadratic running time can be avoided by stopping the DFS in <code>Step 2</code> whenever a state is encountered that was already visited during <code>Step 2</code>.</p>
<p>However, this is only sound if the searches in <code>Step 2</code> are executed in the right order. If we first execute the DFS from $q_0$ in Example 9.2, then this search visits all states; in a subsequent search from $q_1$, we would, therefore, no longer discover the successful path back to $q_1$ via $q_2$!</p>
<p>It turns out that it is sound to restrict the searches in <code>Step 2</code> if they are executed in order of <em>increasing finishing times</em> of the DFS in <code>Step 1</code>. The emptiness check with nested DFS therefore uses <code>Step 1</code> to order the reachable accepting states according to their finishing times; in <code>Step 2</code>, a DFS is initiated from each reachable accepting state in this order until a cycle is detected. <code>Step 2</code> marks the visited states and restricts the searches so that no state is visited twice during <code>Step 2</code>.</p>
<h2 id="A-Modified-Example-Nested-DFS"><a href="#A-Modified-Example-Nested-DFS" class="headerlink" title="A Modified Example (Nested DFS)"></a>A Modified Example (Nested DFS)</h2><p>Continue from above, a possible annotation of the states with pairs <em>(discovery, finishing)</em> of discovery and finishing times during the DFS in Step 1 is the following:</p>
<p><img src="/images/notes/uds/agv/9_2_dfs2.png"></p>
<p>Ordering the accepting states according to increasing finishing times, we obtain the order $q_3$, $q_1$, $q_0$. In Step 2, the DFS from $q_3$ visits (unsuccessfully) $q_3$, $q_4$ and $q_5$. The DFS from $q_1$<br>then only visits $q_1$ and $q_2$, upon which it has successfully discovered the path from $q_2$ to $q_2$.</p>
<h2 id="Nested-DFS-and-Buchi-Automaton"><a href="#Nested-DFS-and-Buchi-Automaton" class="headerlink" title="Nested DFS and Büchi Automaton"></a>Nested DFS and Büchi Automaton</h2><blockquote>
<p>$\textbf{Theorem 9.1. }\textit{For a Büchi automaton }\mathcal{A}\textit{, nested DFS is successful iff }\mathcal{L(A)}\textit{ is nonempty.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>$”\Rightarrow”$<br>If the nested DFS is successful then there exists a state $q$ that is reachable from some initial state such that there is a path from $q$ back to $q$. Hence, $\mathcal{L(A)}$ is non-empty.</p>
<p>$”\Leftarrow”$<br>To show that we can safely ignore the states that were visited in previous searches in <code>Step 2</code>, we consider the situation at the beginning of a DFS from some accepting state $q\in F$ in <code>Step 2</code>. Let $T$ be the set of states visited in previous searches in <code>Step 2</code>. We prove that there is no cycle $q_0,q_1,\dots,q_k$ with $q&#x3D;q_0&#x3D;q_k$ such that $\lbrace q_0,q_1,\dots,q_k\rbrace\cap T\neq \varnothing$ i.e., the states in $T$ can be ignored while looking for $q$-cycles.</p>
<p>Assume, by way of contradiction, that there is a state $q$ where this condition is violated for the first time. Let $t\in\lbrace q_0,q_1,\dots,q_k\rbrace\cap T$, and let $u\in F$ be the accepting state such that $t$ has been added to $T$ during the DFS in <code>Step 2</code>. This means that the DFS from $u$ was invoked before the DFS from $q$; hence, $u$ has an earlier finishing time than $q$ in den DFS of <code>Step 1</code>.</p>
<ul>
<li><p>Case 1: $u$ was discovered before $q$ in the DFS of <code>Step 1</code>. This cannot be the case, because $q$ is reachable from $u$, and, thus, the finishing time of $q$ would have been earlier than that of $u$.</p>
</li>
<li><p>Case 2: u was discovered after $q$ in the DFS of <code>Step 1</code>. Then $q$ was still on the stack of the DFS when $u$ was finished. Hence, $u$ is reachable from $q$. Thus, $u$ and $q$ are on a cycle. This cycle (or some other cycle) would have been discovered during the DFS from $u$ in <code>Step 2</code>.</p>
</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv9-3/">The Emerson-Lei algorithm</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-08T15:44:01.000Z" title="08/12/2024, 16:44:01">2024-12-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 809 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv9-1/">AGV 9.1 -- Automata-based LTL Model Checking with Sequential Circuits</a></p><div class="content"><p>Previous chapter: <a href="../agv8-5/">From Linear Arithmetic to Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p><img src="/images/notes/uds/agv/9_1.png"></p>
<h3 id="Right-hand-side-Hondeterministic-Buchi-automata"><a href="#Right-hand-side-Hondeterministic-Buchi-automata" class="headerlink" title="Right hand side: Hondeterministic Büchi automata"></a>Right hand side: Hondeterministic Büchi automata</h3><p>In order to find system executions that violate a given <strong>LTL formula (1)</strong>, we <strong>negate the formula (2)</strong> and build an automaton that is equivent to the negated formula. For this, we can use the translaton from LTL to <strong>alternating automata (3)</strong> from <a href="../agv7-2/">Construction 7.1</a> followed by the Miyano-Hayashi translation from alternating Büchi automata to <strong>nondeterministic Büchi automata (4)</strong> from <a href="../agv7-3/">Construction 7.2</a>.</p>
<h3 id="Left-hand-side-Safety-Automaton"><a href="#Left-hand-side-Safety-Automaton" class="headerlink" title="Left hand side: Safety Automaton"></a>Left hand side: Safety Automaton</h3><p>We represent the <strong>system (1)</strong> executions as a <strong>Safety Automaton (2)</strong>, which is then intersected (using <a href="../agv3-3/">Construction 3.2</a> with the Büchi automaton for the negated LTL formula. The actual search for a violating execution then happens as the emptiness check of the resulting Büchi automaton. In the remainder of this section, we first quickly discuss the representation of the system as a <strong>Safety Automaton</strong>, using <strong>sequential circuits</strong> as an example, and then focus on the emptiness check of Büchi automata.</p>
<h2 id="Model-Checking-Sequential-Circuits"><a href="#Model-Checking-Sequential-Circuits" class="headerlink" title="Model Checking Sequential Circuits"></a>Model Checking Sequential Circuits</h2><p>As an illustration of how automata can be used to represent system behaviors, we consider the representation of sequential circuits to safety automata. For a more general discussion of how to represent different types of systems, such as protocols or software, we refer the reader to textbooks on model checking, such as <a target="_blank" rel="noopener" href="https://is.ifmo.ru/books/_principles_of_model_checking.pdf">Principles of Model Checking</a> by Baier and Katoen.</p>
<h3 id="Sequential-Circuits"><a href="#Sequential-Circuits" class="headerlink" title="Sequential Circuits"></a>Sequential Circuits</h3><blockquote>
<p>$\textbf{Definition 9.1. } \text{A }\textit{sequential circuit }\text{is given as a tuple }S&#x3D;(I,O,R,\theta,\lambda,\delta)\text{, where}$</p>
<p>$\begin{array}{lcl}<br>\hspace{1cm}\cdot&amp;I&amp;\text{is a set of input bits}\newline<br>\hspace{1cm}\cdot&amp;O&amp;\text{is a set of output bits}\newline<br>\hspace{1cm}\cdot&amp;R&amp;\text{is a set of registers}\newline<br>\hspace{1cm}\cdot&amp;\theta\subseteq R&amp;\text{is an initial register evaluation}\newline<br>\hspace{1cm}\cdot&amp;\lambda:O\rightarrow(2^{I\cup R}\rightarrow\mathbb{B})&amp;\text{assigns to each output bit a control function }2^{I\cup R}\rightarrow\mathbb{B}\newline<br>\hspace{1cm}\cdot&amp;\delta:R\rightarrow(2^{I\cup R}\rightarrow\mathbb{B})&amp;\text{assigns to each output bit a update function }2^{I\cup R}\rightarrow\mathbb{B}\newline<br>\end{array}$</p>
</blockquote>
<h3 id="Safety-Automaton"><a href="#Safety-Automaton" class="headerlink" title="Safety Automaton"></a>Safety Automaton</h3><p>A safety automaton is a Büchi automaton where <strong>all states are accepting</strong>. Here, Input $(I)$ and Output $(O)$ are represented as words, and register valuation $(R)$ is represented as states:</p>
<blockquote>
<p>$\text{A sequential circuit can be represented as a safety automaton}\newline\mathcal{A}_S&#x3D;(2^{I\cup O},2^R,I,T,\small\text{BÜCHI} \normalsize (Q))\text{, where}$</p>
<p>$\begin{array}{ll}<br>\cdot\ Q &#x3D; &amp;2^R\hspace{1cm}\text{consist of all valuations of the registers;}\newline<br>\cdot\ I &#x3D;&amp; \lbrace\theta\rbrace\hspace{0.8cm}\text{corresponds to the inital register valuation;}\newline<br>\cdot\ T&#x3D;&amp;\lbrace(q,\sigma,q’)\mid\lbrace\forall y\in O:y\in \sigma\text{ iff }\lambda(y)(q\cup(\sigma\cap I))\rbrace\wedge\lbrace\forall r\in R:r\in q’\text{ iff }\delta(r)(q\cup(\sigma\cap I))\rbrace\rbrace\newline<br>&amp;\hspace{1.5cm}\text{reflect the outputs specified by the control functions, and}\newline<br>&amp;\hspace{1.5cm}\text{the new register valuation specified by the update function}\end{array}$</p>
</blockquote>
<p>We say that a circuit $S$ <em>satisfies</em> an LTL formula $\varphi$ if $\mathcal{L}(\mathcal{A}_S) ⊆ \mathcal{L(\varphi)}$.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>The example circuit shown on the left has input $I &#x3D; \lbrace x\rbrace$, output $O &#x3D; \lbrace y\rbrace$, and a single register $R &#x3D; \lbrace r\rbrace$. The control function of $y$ is $x\text{ XOR }r$, the update function of $r$ is $x\vee r$.</p>
<p>We assume an initial register valuation $\theta &#x3D; \varnothing$. The circuit is then represented as the automaton shown on the right. Note that that accepting state only have transtions $\lbrace x\rbrace, \lbrace y\rbrace$, becasue if $\lbrace x\rbrace$ holds, $\lbrace y\rbrace$ cannot hold because of the $\text{XOR}$ gate and vice versa.</p>
<p><img src="/images/notes/uds/agv/9_1_eg.png"></p>
<p>Suppose now that we wish to verify whether our circuit satisfies the LTL formula $\varphi &#x3D; \square(x\leftrightarrow y)$. We negate $\varphi$, and translate the resulting formula into the nondeterministic Büchi automaton shown on the left:</p>
<p><img src="/images/notes/uds/agv/9_1_auto.png"></p>
<p>The intersection of the languages of the automaton representing the circuit and the automaton representing the negation of $\varphi$ results in the automaton shown above on the right.</p>
<p>Since there are some words that can be accepted by both automaton and their intersections, the language of this automaton is not empty: for example, the word $\lbrace x, y\rbrace(\lbrace x\rbrace)^\omega$. The circuit, hence, does not satisfy $\varphi$.</p>
<hr>
<p>Next chapter: <a href="../agv9-2/">Nested depth-first search</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-07T00:49:11.000Z" title="07/12/2024, 01:49:11">2024-12-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1206 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-5/">AGV 8.5 -- From Linear Arithmetic to Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv8-4/">Homogenous Inequality Testing is Automatic</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>With all the setup in the previous sections, We are now ready to prove the main result of this chapter.</p>
<blockquote>
<p>$\textbf{Theorem 8.1. }\textit{Let }\varphi\textit{ be a linear arithmetic formula. We can effectively construct a Büchi}\newline\textit{Automaton }\mathcal{A}\textit{ such that }\mathcal{L(A)}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models\varphi\rbrace$</p>
</blockquote>
<p>We follow the same strategy as for the analogous result for S1S in <a href="../agv6-7/">Section 6.7</a>.</p>
<ol>
<li>Introduce a logic with a (slightly) <em>restricted syntax</em> from S1S,</li>
<li>Show that the restriction does not come at the cost of expressive power, and</li>
<li>Use structural induction on <em>restricted-syntax formulas</em> to construct our desired automata.</li>
</ol>
<h2 id="Restricted-Linear-Arithmetic"><a href="#Restricted-Linear-Arithmetic" class="headerlink" title="Restricted Linear Arithmetic"></a>Restricted Linear Arithmetic</h2><p>The formulas of syntactically restricted linear arithmetic are defined by the following grammar:</p>
<p>$$\varphi::&#x3D;z&#x3D;1\mid g_1x_1+\dots+g_\ell x_\ell\leq h_1 y_1+\dots+h_m y_m\mid\neg\varphi\mid\varphi\wedge\varphi\mid\exists x.\varphi$$</p>
<p>where $z, x_1,\dots,x_\ell,y_1,\dots,y_m\in V$ are <strong>variables</strong>, and $p_1,\dots,p_\ell,q_1,\dots,q_m$ are <strong>positive constants</strong>. The restriction is that <strong>all inequalities must be homogenous</strong>, except $z&#x3D;1$ being the only <strong>non-homogenous relation</strong>.</p>
<h3 id="homogenous-inequalities-conversion"><a href="#homogenous-inequalities-conversion" class="headerlink" title="homogenous inequalities conversion"></a>homogenous inequalities conversion</h3><p>In fact, <strong>“all inequalities must be homogenous”</strong> is not a semantic restrictionm, since we can always convert non-homogenous inequalities into a homogenous version:</p>
<blockquote>
<p>For a formula $\varphi_0$ contains non-homogenous inequalities, first replace all constants $r$ by $r\cdot z$, where $z$ is a fresh variable to obtain $\varphi’_0$, then replace $\varphi_0$ with $\varphi::&#x3D;\exists z. (z&#x3D;1\wedge\varphi’_0)$.</p>
</blockquote>
<p>For example, $\varphi_0::&#x3D;y\leq2,\varphi_0’::&#x3D;y\leq2\cdot z,$ now we have $\varphi_0::&#x3D;\exists z. (z&#x3D;1\wedge(y\leq2\cdot z)))$</p>
<p>To include all possible expression of the real number $1$, the encoding must be a word of the form $00^\ast(1{$} 0^\omega + {$} 1^\omega)$. It is thus trivial to construct an automaton corresponding to $z&#x3D;1$.</p>
<h2 id="From-Linear-Arithmetic-to-Automata"><a href="#From-Linear-Arithmetic-to-Automata" class="headerlink" title="From Linear Arithmetic to Automata"></a>From Linear Arithmetic to Automata</h2><p>We use <a href="../agv8-4/">Construction 8.1</a> to construct automata for <strong>homogenous inequalities</strong>. Note that the construction works even when one of the sides of the inequality is equal to $0$ (i.e., the empty sum).</p>
<p>Now we start with inductive cases. Recall that for any $k$ we can construct an automaton <a href="../agv8-4/">$\mathcal{L(A_{\textsf{valid},k})}$</a> that checks whether a word $\alpha\in(\lbrace 0,1\rbrace^k\cup\lbrace{$}\rbrace)^k)^\omega$ is a well-formed encoding of some valuation $\sigma$ to $k$ free variables.</p>
<h3 id="Negation-mathcal-A-neg-varphi"><a href="#Negation-mathcal-A-neg-varphi" class="headerlink" title="Negation $\mathcal{A_{\neg\varphi}}$"></a>Negation $\mathcal{A_{\neg\varphi}}$</h3><p>The Büchi automaton $\mathcal{A_{\neg\varphi}}$ is obtained through complementation and intersection of Büchi automata.</p>
<p>Let $\varphi$ have $k$ free variables. For negation, we have</p>
<p>$$\mathcal{L(A_{\neg\varphi})}&#x3D;((\lbrace 0,1\rbrace^k\cup\lbrace{$}\rbrace)^k)^\omega\setminus\mathcal{L(A_\varphi)})\cap\mathcal{L(A_{\textsf{valid},k})}$$</p>
<h3 id="Conjunction-mathcal-A-varphi-1-wedge-varphi-2"><a href="#Conjunction-mathcal-A-varphi-1-wedge-varphi-2" class="headerlink" title="Conjunction $\mathcal{A_{\varphi_1\wedge\varphi_2}}$"></a>Conjunction $\mathcal{A_{\varphi_1\wedge\varphi_2}}$</h3><p>$\mathcal{A_{\varphi_1\wedge\varphi_2}}$ can be obtained similarly straightforward through the intersection of two Büchi automata because</p>
<p>$$\mathcal{L(A_{\varphi_1\wedge\varphi_2})}&#x3D;\mathcal{L(A_{\varphi_1})}\cap\mathcal{L(A_{\varphi_2})}$$</p>
<h3 id="Existential-Quantification"><a href="#Existential-Quantification" class="headerlink" title="Existential Quantification"></a>Existential Quantification</h3><p>To handle projection, i.e. construct $\mathcal{A_{\exists x.\varphi}}$ from $\mathcal{A_{\varphi}}$, we first try to see their difference:</p>
<ul>
<li>$\mathcal{A_{\varphi}}$ runs over the alphabet $\lbrace 0, 1\rbrace^{k+1}\cup\lbrace{$}\rbrace^{k+1}$ and reads the encoding of a valuation of $\lbrace x,y_1,\dots, y_k\rbrace$.</li>
<li>$\mathcal{A_{\exists x.\varphi}}$ runs over the alphabet $\lbrace 0, 1\rbrace^k\cup\lbrace{$}\rbrace^k$ and reads the encoding of a valuation of $\lbrace y_1,\dots, y_k\rbrace$,</li>
</ul>
<p>Same as before, the principle behind the construction is to create a automaton that simulate identical behaviour with the absence of $x$. This is simple for most of the transitions except for the initial transition.</p>
<p>For a automaton that does not contain $x$, it has to “guess” an encoding of $x$ such that $\varphi(x,y_1,\dots, y_k)$ holds. However, the given encoding of the valuation of $\lbrace y_1,\dots, y_k\rbrace$ may not be appropriately padded.</p>
<p>For example, let $y_1 &#x3D; 1$ and we encode it as $01{$}0^\omega$. If we guess $x&#x3D;4$, then two digits of <em>integer part</em> is not enough. The encoding must be “padded” so to synchronize “may be” accepted by $\mathcal{A_{\varphi}}$:</p>
<p>$$\begin{bmatrix}x\newline y_1\end{bmatrix}&#x3D;\begin{bmatrix}0\newline 0\end{bmatrix}<br>\begin{bmatrix}1\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\end{bmatrix}<br>\begin{bmatrix}0\newline 1\end{bmatrix}\begin{bmatrix}{$}\newline{$}\end{bmatrix}\left(\begin{bmatrix}0\newline 0\end{bmatrix}\right)^\omega$$</p>
<p>Therefore, when we convert from $c_y$ to $(c_x, c_y)$, We have to repeat the first letter $c_{y,n}$ as padding:</p>
<p>$$(a_{x,n+j}, a_{y,n})(a_{x,n+j−1}, a_{y,n})\dots(a_{x,n}, a_{y,n}).$$</p>
<p>Since $c_{y,n}$ is simply repeating, creating transition for each letter of $a_x$ unnecessarily enlarge the size of the automaton. Instead, we can make one initial transition that encapsulate the full padding of the first letter of $c_y$.</p>
<p>$$(q,(c_{x,1},c_{y_1},\dots,c_{y_k})\dots(c_{x,n},c_{y_1},\dots,c_{y_k}),q’)\in T’$$</p>
<blockquote>
<p>$\textbf{Construction 8.2. } \text{Let }x,y_1,\dots, y_k\text{ be free variables in the linear arithmetic formula }\varphi,\text{ and}$</p>
<p>$$\mathcal{A_\varphi}&#x3D;(\lbrace 0, 1\rbrace^{k+1}\cup\lbrace{$}\rbrace^{k+1},Q,I,T,\small\text{BÜCHI}\normalsize (F))$$</p>
<p>$\text{be a Büchi Automaton such that }\mathcal{L(A)}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models\varphi\rbrace.\text{ We construct a Büchi Automaton}$</p>
<p>$$\mathcal{A_{\exists x.\varphi}}&#x3D;(\lbrace 0, 1\rbrace^{k}\cup\lbrace{$}\rbrace^{k},Q\cup\textsf{Inits},\textsf{Inits},T’,\small\text{BÜCHI}\normalsize (F))$$</p>
<p>$\text{such that }\mathcal{L(A_{\exists x.\varphi})}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models\exists x.\varphi\rbrace\text{ as follows.}$</p>
<p>$\begin{array}{l}<br>\hspace{1cm} \cdot \ \textsf{Inits}&#x3D;\lbrace(q,\star)\mid q\in I\rbrace\newline<br>\hspace{1cm} \cdot \ (q,(c_{y_1},\dots,c_{y_k}),q’)\in T’\text{ if and only if there exists }c_x\text{ such that }(q,(c_x,c_{y_1},\dots,c_{y_k}),q’)\in T’\newline<br>\hspace{1cm} \cdot \ ((q,\star),(c_{y_1},\dots,c_{y_k}),q’)\in T’\text{ if and only if there exists a word }c_{x,1}\dots c_{x,n}\in\lbrace0,1\rbrace^{+}\newline<br>\hspace{1cm} \  \text{ such that }(q,(c_{x,1},c_{y_1},\dots,c_{y_k})\dots(c_{x,n},c_{y_1},\dots,c_{y_k}),q’)\in T’\end{array}$</p>
</blockquote>
<p>Two remarks are in order:</p>
<ol>
<li><p>We extended the transition relation $T$ to $Q\times\Sigma^+\times Q$: if $(q,u,q’)\in T$ and $(q’,v,q’’)\in T$, then $(q,uv,q’’)\in T$ (where $\Sigma^+ &#x3D; \Sigma\Sigma^\ast$).</p>
</li>
<li><p>The transitions from the freshly added initial states can be readily determined, via, for example, a depth-first search by considering an appropriate subgraph induced by the automaton $\mathcal{A_\varphi}$.</p>
</li>
</ol>
<p>This concludes the final inductive case, and, hence, the proof of Theorem 8.1.</p>
<hr>
<p>Next chapter: <a href="../agv9-1/">Automata-based LTL Model Checking with Sequential Circuits</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Notes/UdS/">Previous</a></div><div class="pagination-next"><a href="/categories/Notes/UdS/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Notes/UdS/">1</a></li><li><a class="pagination-link is-current" href="/categories/Notes/UdS/page/2/">2</a></li><li><a class="pagination-link" href="/categories/Notes/UdS/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/categories/Notes/UdS/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>