<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Category: UdS - GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">Categories</a></li><li><a href="/categories/Notes/">Notes</a></li><li class="is-active"><a href="#" aria-current="page">UdS</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-26T01:33:51.000Z" title="26/11/2024, 02:33:51">2024-11-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.415Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1101 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-4/">AGV 6.4 -- Quantified Propositional Temporal Logic (QPTL)</a></p><div class="content"><p>Previous chapter: <a href="../agv6-3/">LTL and Counting Languages</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the last section, we knew that LTL cannot express <code>counting-languages</code>. QPTL, which extends<br>LTL with <strong>quantification over propositions</strong>, repairs this deficiency.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>We knew $L&#x3D;(\varnothing\varnothing)^\ast\lbrace p\rbrace^\omega$ is not LTL-definable. However, similar language $L’&#x3D;(\varnothing\lbrace q\rbrace)^\ast\lbrace p\rbrace^\omega$ is LTL-definable:</p>
<p>$$\varphi&#x3D;\neg q\wedge(\neg p\wedge(\neg q\leftrightarrow\bigcirc q))\ \mathcal{U}\ (\square(p\wedge\neg q))$$</p>
<p>Intuitively, $L’$ is the same language as $L$, except that there is an additional proposition $q$ that keeps track of odd and even positions. LTL has no means of introducing such “helpful” propositions that are not already present in the language we wish to define. In QPTL, we can introduce the proposition $q$ using a quantifier. The existential quantification $\exists q$. $\varphi$ expresses that there is a way to evaluate the new proposition $q$ such that, in the such extended word, $\varphi$ is true. In the example, the language of $\exists q.\ \varphi$ is thus precisely $L$.</p>
<h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><p>QPTL formulas over a set $AP$ of atomic propositions are generated by the following grammar, where $p\in AP$:</p>
<p>$$\psi ::&#x3D; p\ \mid\ \neg\psi\ \mid\ \psi\wedge\varphi\ \mid\ \bigcirc\psi\ \mid\ \Diamond\psi\ \mid\ \exists p.\ \psi$$</p>
<p>The QPTL connectives have the same semantics and precedence as in LTL, except for propositional quantification, which has lowest precedence and the following semantics:</p>
<p>$$\begin{array}{lcr}\alpha\models\exists p.\ \varphi&amp;\text{ iff }&amp;\text{ there exists }\alpha’\in(2^{AP})^\omega\text{ such that }\alpha&#x3D;_{AP\setminus\lbrace p\rbrace}\alpha’\text{ and }\alpha’\models\varphi\end{array}$$</p>
<p>where $\alpha&#x3D;_P\alpha’$ for some $P\subseteq AP$ iff, for all $i\in\mathbb{N},\alpha(i)\cap P&#x3D;\alpha’(i)\cap P$.</p>
<blockquote>
<p>Every $AP$ in $\alpha$ is same as $\alpha’$, except $\alpha’$ can modify $p$ so that $\varphi$ holds for $\alpha’$</p>
</blockquote>
<h3 id="Until-operator-mathcal-U-in-QPTL"><a href="#Until-operator-mathcal-U-in-QPTL" class="headerlink" title="Until operator $\mathcal{U}$ in QPTL"></a>Until operator $\mathcal{U}$ in QPTL</h3><p>We can express the Until operator $\mathcal{U}$ in the syntax of QPTL with quantifier and the meaning is equivalent:</p>
<blockquote>
<p>$\varphi\ \mathcal{U}\ \psi:$ $\varphi$ must hold $\textit{true}$ until $\psi$ becomes $\textit{true}$.</p>
</blockquote>
<p>$$\exists t.\ t\wedge\square(t\rightarrow(\psi\vee(\varphi\wedge\bigcirc t)))\wedge\Diamond\neg t:$$</p>
<blockquote>
<ul>
<li><p>$\exists t.\ t$: For some proposition $t$, $t$ holds at the beginning;</p>
</li>
<li><p>$\square(t\rightarrow(\psi\vee(\varphi\wedge\bigcirc t)))$: if $t$ holds, we repeatly check the following</p>
<ul>
<li>either $\psi$ becomes $\textit{true}$, or</li>
<li>$\varphi$ must remain $\textit{true}$ and so as $t$ in the next step<br>(so that this if-clause check again in the next step);\</li>
</ul>
</li>
<li><p>$\Diamond\neg t$ : Eventually, $t$ will no longer hold.</p>
<ul>
<li>It enforces $\psi$ must become $\textit{true}$ at some point and then $t$ doesn’t need to hold anymore</li>
<li>If it is weak until $\mathcal{W}$ then this part is not necessarily because we don’t enforce $\psi$ to be $\textit{true}$</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Free-and-Bound-Atomic-Propositions"><a href="#Free-and-Bound-Atomic-Propositions" class="headerlink" title="Free and Bound Atomic Propositions"></a><code>Free</code> and <code>Bound</code> Atomic Propositions</h3><table>
<thead>
<tr>
<th align="left">Atomic Propositions</th>
<th align="left">Defintiion</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Free</code></td>
<td align="left"><strong>NOT in</strong> the <em>scope of a quantifier</em> over the proposition</td>
</tr>
<tr>
<td align="left"><code>Bound</code></td>
<td align="left"><strong>In</strong> the <em>scope of a quantifier</em> over the proposition</td>
</tr>
</tbody></table>
<p>Here, <code>Bounded</code> propositions are internal helpers to help us construct some logical conditions of the formula that do not directly appear in the language. (e.g. we need a counter for <code>counting</code>-language, but it doesn’t belongs to any proposition that refers to the alphabet or language.)</p>
<h2 id="From-QPTL-formula-to-omega-regular-language"><a href="#From-QPTL-formula-to-omega-regular-language" class="headerlink" title="From QPTL formula to $\omega$-regular language"></a>From QPTL formula to $\omega$-regular language</h2><p>Let’s defined the set of <strong>free</strong> atomic propositions as $AP’\subseteq AP$. For every letter in the alphabet, we can describe them in $AP’$.</p>
<p>For exmaple, if $\lbrace a,b,c\rbrace&#x3D;\Sigma$, the word $\lbrace ab\rbrace\in\Sigma$ will be $\lbrace a,b,\neg c\rbrace\in AP’$</p>
<p>Now, the language of QPTL is essentially the language over alphabet $2^{AP’}:\mathcal{L}(\varphi)&#x3D;\lbrace\alpha\in{(2^{AP’})}^{\omega}\mid\alpha\models\varphi\rbrace$</p>
<p>In fact, it is exactly the $\omega$-regular languages that can be expressed in QPTL. And therefore, we can translate a given Büchi automaton with alphabet $2^{AP}$ into a QPTL formula:</p>
<blockquote>
<p>$\textbf{Theorem 6.2. } \textit{For every Büchi automaton }\mathcal{A}\textit{ over }\Sigma&#x3D;2^{AP}\textit{ there exists a QPTL formula }\varphi_{\mathcal{A}}\newline\textit{such that }\mathcal{L}(\varphi)&#x3D;\mathcal{L}(\mathcal{A}).$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Reminder: here the automaton using atomic propositions $2^{AP}$, not the alphabet $\Sigma$. To translate states in automata into atomic proposition in QPTL formula, we introduce <em>auxiliary proposition</em> $at_q$ for each <em>state</em> $q\in Q$, where $Q&#x3D;\lbrace q_1, q_2,\dots,q_n\rbrace$</p>
<p>Then QPTL formula $\varphi_\mathcal{A}$ for the Büchi automaton $\mathcal{A}$ so that $\mathcal{L}(\varphi)&#x3D;\mathcal{L}(\mathcal{A})$ is defined as follows:</p>
<p>$$<br>\begin{array}{rll}<br>\varphi_\mathcal{A}:&#x3D;\exists at_q,\dots,at_{q_n}.&amp;&amp;\underset{q\in I}{\bigvee}at_q\newline<br>&amp;\wedge&amp;\square\left(\underset{(q,A,q’)\in T}{\bigvee}at_q\wedge\bigcirc at_{q’}\wedge\left(\underset{p\in A}{\bigwedge}p\right)\wedge\left(\underset{p\in AP\setminus A}{\bigwedge}\neg p\right)\right)\newline<br>&amp;\wedge&amp;\square\left(\overset{n}{\underset{i&#x3D;1}{\bigwedge}}\underset{j\neq i}{\bigwedge}\neg(at_{q_i}\wedge at_{q_j})\right)\newline<br>&amp;\wedge&amp;\square\Diamond\underset{q\in F}{\bigvee}at_q<br>\end{array}<br>$$</p>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>To express a Büchi automaton in QPTL, we first need to know what features&#x2F;characteristics we need express.</p>
<ul>
<li>Begins with Initial states and reaches the Accepting states infinitely often:</li>
</ul>
<p>$$\textsf{Initial states: }\underset{q\in I}{\bigvee}at_q \hspace{3cm} \textsf{Accepting states: }\square\Diamond\underset{q\in F}{\bigvee}at_q$$</p>
<ul>
<li>There’s always transitions for any states, only using the letters available in the current state defined by set $A$:</li>
</ul>
<p>$$\square\left(\underset{(q,A,q’)\in T}{\bigvee}at_q\wedge\bigcirc at_{q’}\wedge\left(\underset{p\in A}{\bigwedge}p\right)\wedge\left(\underset{p\in AP\setminus A}{\bigwedge}\neg p\right)\right)$$</p>
<ul>
<li>Additionally, we also need to ensure that there’s exactly one current state $q_i$, which is $at_{q_i}$ in propositions:</li>
</ul>
<p>$$\square\left(\overset{n}{\underset{i&#x3D;1}{\bigwedge}}\underset{j\neq i}{\bigwedge}\neg(at_{q_i}\wedge at_{q_j})\right)$$</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>As above, we can see that every feature of a Büchi automaton can be expressed in QPTL. What’s next? Can we use simpler syntax to express same formula?</p>
<hr>
<p>Next chapter: <a href="../agv6-5/">Monadic Second-Order Logic of One Successor (S1S)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-24T23:44:03.000Z" title="25/11/2024, 00:44:03">2024-11-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.415Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1241 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-3/">AGV 6.3 -- LTL and Counting Languages</a></p><div class="content"><p>Previous chapter: <a href="../agv6-2/">Expressing Program Properties using LTL</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h2><p>An LTL formula $\varphi$ over $AP$ defines the following language over the alphabet $2^{AP}$:</p>
<p>$\hspace{1cm} \mathcal{L}(\varphi)&#x3D;\lbrace\alpha\in(2^{AP})^\omega\mid\alpha\models\varphi\rbrace$</p>
<p>where $\models$ is the smallest relation satisfying:</p>
<p>$\begin{array}{lllll}<br>\hspace{1cm} \alpha &amp; \models &amp; p &amp; \text{iff} &amp; p\in\alpha(0) \ \ \ \ (\text{i.e., }\alpha(0)\models p)\newline<br>\hspace{1cm} \alpha &amp; \models &amp; \varphi_1\wedge\varphi_2 &amp; \text{iff} &amp; \alpha\models\varphi_1\ \text{ and }\ \alpha\models\varphi_1\newline<br>\hspace{1cm} \alpha &amp; \models &amp; \neg\varphi &amp; \text{iff} &amp; \alpha\not\models\varphi\newline<br>\hspace{1cm} \alpha &amp; \models &amp; \bigcirc\varphi &amp; \text{iff} &amp; \alpha[1,\infty]&#x3D;\alpha(1)\alpha(2)\alpha(3)\dots\models\varphi\newline<br>\hspace{1cm} \alpha &amp; \models &amp; \varphi_1\ \mathcal{U}\ \varphi_2 &amp; \text{iff} &amp; \exists j\geq0.\ \alpha[j,\infty]\models\varphi_2\ \text{ and }\ \alpha[i,\infty]\models\varphi_1\text{ for all }0\leq i\leq j\newline<br>\end{array}$</p>
<p>For the temporal operators, the semantics can be visualized as below:</p>
<p><img src="/../images/notes/uds/agv/6_3_ltl.png"></p>
<h2 id="From-LTL-to-omega-regular-languages"><a href="#From-LTL-to-omega-regular-languages" class="headerlink" title="From LTL to $\omega$-regular languages"></a>From LTL to $\omega$-regular languages</h2><blockquote>
<p>All LTL-definable properties are $\omega$-regular, but <strong>NOT ALL</strong> $\omega$-regular languages can be defined in LTL.</p>
</blockquote>
<p>Why can’t we? What is the limitation of LTL formula?</p>
<h3 id="Counting-and-Non-counting-Languages"><a href="#Counting-and-Non-counting-Languages" class="headerlink" title="Counting and Non-counting Languages"></a>Counting and Non-counting Languages</h3><p>Let say we want to express:</p>
<blockquote>
<p>An arbitrary <strong>even</strong> sequence of $\varnothing$ symbols, followed by an infinite sequence of $p$ symbols</p>
</blockquote>
<p>In $\omega$-language it is $(\varnothing\varnothing)^\ast\lbrace p\rbrace^\omega$. However, this cannot be defined in LTL, because it is a <code>counting language</code>.</p>
<blockquote>
<p>$\textbf{Definition 6.1. }\text{A Language }L\subseteq\Sigma^\omega\text{ is }\textit{non-counting}\text{ iff}$<br>$$\exists n_0\in\mathbb{N}.\ \forall n\geq n_0.\ \forall v,w\in\Sigma^\ast, \alpha\in\Sigma^\omega.\ vw^n\alpha\in L\Leftrightarrow vw^{n+1}\alpha\in L$$</p>
</blockquote>
<p>For some threshold $n_0$, and a word with prefix $w$ which repeated $n$ times and $n\geq n_0$. For every $n$ we picked, if we can always find a pair of words $vw^{n}\alpha,vw^{n+1}$ that are both accepted by language $L$, then $L$ is <code>non-counting</code>.</p>
<p>For example, in $L_1&#x3D;(\varnothing\varnothing)^\ast\lbrace p\rbrace^\omega$, if $(\varnothing)^n\lbrace p\rbrace^\omega\in L_1$, then $(\varnothing)^{n+1}\lbrace p\rbrace^\omega\not\in L_1$, so $L_1$ is <code>counting</code> with $n_0&#x3D;1$.</p>
<blockquote>
<p>$\textbf{Theorem 6.1. }\textit{ For every LTL-formula }\varphi,\mathcal{L}(\varphi)\textit{ is non-counting.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We prove the theorem by structural induction on $\varphi$, going through its sematics:</p>
<p>$\textbf{Case }\varphi&#x3D;p:$<br>$\hspace{1cm}$  Simply choose the length $n_0&#x3D;1$, (because $\alpha\models p\text{ iff }p\in\alpha(0)$)</p>
<p>$\textbf{Case }\varphi&#x3D;\varphi_1\wedge\varphi_2:$<br>$\hspace{1cm}$ By induction hypothesis, If $\varphi_1$ and $\varphi_2$ are <code>non-counting</code>, then $\mathcal{L}(\varphi_1)$ and $\mathcal{L}(\varphi_2)$ have threshold $n_0’$ and<br>$\hspace{1cm}$ $n’’_0\in\mathbb{N}$ respectively. We can choose $n_0&#x3D;\text{max}\lbrace n’_0,n’’_0\rbrace$ to ensure $\varphi$ is also <code>non-counting</code>. (max. because<br>$\hspace{1cm}$ the larger the $n_0$, less $n$ is required to be <code>non-counting</code>)</p>
<p>$\textbf{Case }\varphi&#x3D;\neg\varphi_1:$<br>$\hspace{1cm}$ If $\varphi_1$ is <code>non-counting</code>, then $\mathcal{L}(\varphi_1)$ has threshold $n_0’\in\mathbb{N}$. We choose $n_0&#x3D;n’_0$</p>
<p>$\textbf{Case }\varphi&#x3D;\bigcirc\varphi_1:$<br>$\hspace{1cm}$ If $\varphi_1$ is <code>non-counting</code>, then $\mathcal{L}(\varphi_1)$ has threshold $n_0’\in\mathbb{N}$. We choose $n_0&#x3D;n’_0+1$ and try to show<br>$$\text{“For }n\geq n_0,\ vw^n\alpha\models\bigcirc\varphi\ \text{ if and only if }\ n\geq n_0,\ vw^{n+1}\alpha\models\bigcirc\varphi”$$</p>
<p>$\hspace{1cm}$ We try to perform operations on the fix length prefix $v$ as it doesn’t affect the finite loop prefix $w$. So we<br>$\hspace{1cm}$ need to consider whether the fix length prefix $v$ is an <em>empty string</em> $(\varepsilon)$, if not, we try to “peel” one cycle of<br>$\hspace{1cm}$ $w$ and make it so-called “fix-length” prefix.</p>
<p>$\hspace{1cm}$ A simple example for the operation: if there’s logic requires $b$ to be reached in the next step, then the same<br>$\hspace{1cm}$ logic without <strong>neXt</strong> operator $\bigcirc$ can be satisfied by removing the first letter. (if $ab\models\bigcirc\varphi$, then $b\models\varphi$)</p>
<p>$\hspace{1cm}\textbf{Case }\ v\neq\varepsilon:$ Thus $v&#x3D;av’$ for some $a\in\Sigma,v’\in\Sigma^\ast$. We have that</p>
<p>$\begin{array}{lrl}<br>\hspace{2cm}&amp;av’w^n\alpha&amp;\models\bigcirc\varphi\newline<br>\hspace{2cm}\text{iff}&amp;v’w^n\alpha&amp;\models\varphi\newline<br>\hspace{2cm}\text{iff}&amp;v’w^{n+1}\alpha&amp;\models\varphi&amp;\text{(induction hypothesis)}\newline<br>\hspace{2cm}\text{iff}&amp;av’w^{n+1}\alpha&amp;\models\bigcirc\varphi\newline<br>\end{array}$</p>
<p>$\hspace{1cm}\textbf{Case }\ v&#x3D;\varepsilon:$ Thus either $w&#x3D;\varepsilon$ (proved trivially), or $w&#x3D;aw’$ for some $a\in\Sigma,w’\in\Sigma^\ast$. It follows that</p>
<p>$\begin{array}{lrl}<br>\hspace{2cm}&amp;(aw’)^n\alpha&amp;\models\bigcirc\varphi\newline<br>\hspace{2cm}\text{iff}&amp;(aw’)(aw’)^{n-1}\alpha&amp;\models\bigcirc\varphi\newline<br>\hspace{2cm}\text{iff}&amp;w’(aw’)^{n-1}\alpha&amp;\models\varphi\newline<br>\hspace{2cm}\text{iff}&amp;w’(aw’)^{n}\alpha&amp;\models\varphi&amp;\text{(induction hypothesis)}\newline<br>\hspace{2cm}\text{iff}&amp;(aw’)^{n+1}\alpha&amp;\models\bigcirc\varphi\newline<br>\end{array}$</p>
<p>$\textbf{Case }\varphi&#x3D;\varphi_1\ \mathcal{U}\ \varphi_2:$<br>$\hspace{1cm}$ If $\varphi_1$ and $\varphi_2$ are <code>non-counting</code>, then $\mathcal{L}(\varphi_1)$ and $\mathcal{L}(\varphi_2)$ have threshold $n_0’$ and $n’’_0\in\mathbb{N}$ respectively. We<br>$\hspace{1cm}$ choose $n_0&#x3D;\text{max}\lbrace n’_0,n’’_0\rbrace+1$ and try to show<br>$$”\text{For }n\geq n_0,\ vw^n\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2\ \text{ if and only if }\ vw^{n+1}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2”$$</p>
<p>$\hspace{1cm}$ By the semantics of $\mathcal{U}$, $\varphi_1$ keeps holding until $\varphi_2$ is satisfied. Let $j$ be the least index when $\varphi_2$ is satisfied,<br>$\hspace{1cm}$ then we have $vw^n\alpha[j,\infty]\models\varphi_2$ and for all $i&lt;j,\ vw^n\alpha[i,\infty]\models\varphi_1$, respectively applies on $vw^{n+1}\alpha$.</p>
<p>$\hspace{1cm}$ $\textbf{1. }\textit{If }\ vw^n\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2\textit{, then }\ vw^{n+1}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2:$<br>$\hspace{2cm}$ Similar to $\bigcirc\varphi$, we try to do the operation with respect to $j$’s position. So we need to consider whether<br>$\hspace{2cm}$ index $j$ lies within the first cycle of the prefix $|v|+|w|$, or lies in the finite loop of the prefix $|w|$.</p>
<p>$\hspace{2cm}\textbf{Case }j\leq|v|+|w|:$<br>$\hspace{3cm}$ By induction hypothesis, we assumed $\varphi_1$ and $\varphi_2$ are <code>non-counting</code>. So<br>$\hspace{3cm}$ if $vww^{n−1}\alpha[j,\infty]\models\varphi_2$, then $vww^{n}\alpha[j,\infty]\models\varphi_2$ and analogously,<br>$\hspace{3cm}$ if $vww^{n−1}\alpha[i,\infty]\models\varphi_1$, then $vww^{n}\alpha[i,\infty]\models\varphi_1$ for $i &lt; j$.<br>$\hspace{3cm}$ Hence, $vw^{n+1}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2$.</p>
<p>$\hspace{2cm}\textbf{Case }j&gt;|v|+|w|:$<br>$\hspace{3cm}$ By adding one more cycle, we can essentially get the same suffix if $j$ is somewhere in the cycle:<br>$\hspace{3cm}$ if $vw^{n}\alpha[j,\infty]\models\varphi_2$, then $vw^{n+1}\alpha[j+|w|,\infty]\models\varphi_2$, and<br>$\hspace{3cm}$ if $vw^{n}\alpha[i,\infty]\models\varphi_1$, then $vw^{n+1}\alpha[i,\infty]\models\varphi_1$, for each position $|v|+|w|\leq i&lt;j+|w|$.<br>$\hspace{3cm}$ Additionally, by induction hypothesis from the above case, we have that</p>
<p>$\begin{array}{lrcccll}<br>\hspace{4cm}&amp;|v|+|w|&amp;\leq&amp;i&amp;&lt;&amp;j+|w|\newline<br>\hspace{4cm}\text{iff}&amp;|v|&amp;\leq&amp;i&amp;&lt;&amp;j\newline<br>\hspace{4cm}\text{iff}&amp;&amp;&amp;i&amp;&lt;&amp;j&amp;&amp;(\text{induction hypothesis: }i&lt;|v|+|w|)\newline<br>\end{array}$</p>
<p>$\hspace{3cm}$ Hence, $vw^{n}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2$.</p>
<p>$\hspace{1cm}$ $\textbf{2. }\textit{If }\ vw^{n+1}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2\textit{, then }\ vw^{n}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2:$<br>$\hspace{2cm}$ Again, we need consider both cases seperately:</p>
<p>$\hspace{2cm}\textbf{Case }j\leq|v|+|w|:$<br>$\hspace{3cm}$ By induction hypothesis, we assumed $\varphi_1$ and $\varphi_2$ are <code>non-counting</code>. So<br>$\hspace{3cm}$ if $vww^{n}\alpha[j,\infty]\models\varphi_2$, then $vww^{n-1}\alpha[j,\infty]\models\varphi_2$ and analogously,<br>$\hspace{3cm}$ if $vww^{n}\alpha[i,\infty]\models\varphi_1$, then $vww^{n-1}\alpha[i,\infty]\models\varphi_1$ for $i &lt; j$.<br>$\hspace{3cm}$ Hence, $vw^{n}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2$.</p>
<p>$\hspace{2cm}\textbf{Case }j&gt;|v|+|w|:$<br>$\hspace{3cm}$ Simliar to above, by subtracting one more cycle, we can essentially get the same suffix:<br>$\hspace{3cm}$ if $vw^{n+1}\alpha[j,\infty]\models\varphi_2$, then $vw^{n}\alpha[j-|w|,\infty]\models\varphi_2$, and<br>$\hspace{3cm}$ if $vw^{n+1}\alpha[i,\infty]\models\varphi_1$, then $vw^{n}\alpha[i,\infty]\models\varphi_1$, for each position $|v|+|w|\leq i&lt;j-|w|$.<br>$\hspace{3cm}$ Again, by induction hypothesis from the above case, we have that</p>
<p>$\begin{array}{lrcccll}<br>\hspace{4cm}&amp;|v|+|w|&amp;\leq&amp;i&amp;&lt;&amp;j-|w|\newline<br>\hspace{4cm}\text{iff}&amp;|v|+2|w|&amp;\leq&amp;i&amp;&lt;&amp;j\newline<br>\hspace{4cm}\text{iff}&amp;&amp;&amp;i&amp;&lt;&amp;j&amp;&amp;(\text{induction hypothesis: }i&lt;|v|+|w|)\newline<br>\end{array}$</p>
<p>$\hspace{3cm}$ Hence, $vw^{n}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2$.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Unfortunately, LTL is not expressive enough to include all $\omega$-regular languages. However, by extending the syntax of LTL, we can also extend the languages it covers.<br>In the next section, we will Quantified Propositional Temporal Logic (QPTL), and see whether it suffices to solve our problem.</p>
<hr>
<p>Next chapter: <a href="../agv6-4/">Quantified Propositional Temporal Logic (QPTL)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-24T04:56:28.000Z" title="24/11/2024, 05:56:28">2024-11-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.424Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">4 minutes read (About 668 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-2/">AGV 6.2 -- Expressing Program Properties using LTL</a></p><div class="content"><p>Previous chapter: <a href="../agv6-1/">Linear-Time Temporal Logic (LTL)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this section, we consider again our concurrent program $\small{\text{TURN}}$ introduced in <a href="../agv1-1/">section 1.1</a>. As discussed before, a major property of interest is <code>mutual exclusion</code>,i.e., at any given point of time, at most one process is in the $\text{critical}$ region. We can express <code>mutual exclusion</code>, as well as other properties of turn, in <code>LTL</code>.</p>
<blockquote>
<p>$\textbf{Example 1.1. }\small{\text{TURN}}:$<br>$$\text{local $t$: boolean where initially $t$ &#x3D; $false$}\newline<br>P_0::\left[ \begin{array}{l}\text{loop forever do}\newline<br>\hspace{1cm}\left[ \begin{array}{l}<br>\ell_0: \text{await }\neg t; \newline<br>\ell_1: \text{critical;} \newline<br>\ell_2: t :&#x3D; true; \newline<br>\end{array} \right]\end{array} \right]<br>\mid\mid P_1::\left[ \begin{array}{l}<br>\text{loop forever do}\newline<br>\hspace{1cm}\left[ \begin{array}{l}<br>m_0: \text{await } t; \newline<br>m_1: \text{critical;} \newline<br>m_2: t :&#x3D; false; \newline<br>\end{array} \right]\end{array} \right]$$</p>
</blockquote>
<h2 id="Properties-of-the-Concurrent-Program-small-text-TURN"><a href="#Properties-of-the-Concurrent-Program-small-text-TURN" class="headerlink" title="Properties of the Concurrent Program $\small{\text{TURN}}$"></a>Properties of the Concurrent Program $\small{\text{TURN}}$</h2><h3 id="Mutual-exclusion-square-neg-ell-1-wedge-m-1"><a href="#Mutual-exclusion-square-neg-ell-1-wedge-m-1" class="headerlink" title="Mutual exclusion : $\square\neg(\ell_1\wedge m_1)$"></a><em>Mutual exclusion</em> : $\square\neg(\ell_1\wedge m_1)$</h3><blockquote>
<p>$\ell_{1}$ and $m_1$ cannot ($\neg$) be true at the same time ($\wedge$) at every point in time ($\square$)</p>
</blockquote>
<p>The property can equivalently be formulated as $\neg(\textit{true}\ \mathcal{U}\ (\ell_1\wedge m_1))$, which means that the system remains true, until the a violation of mutual exclusion, i.e., $\ell_1\wedge m_1$, occurs</p>
<h3 id="Finite-waiting-square-ell-0-rightarrow-Diamond-ell-1-wedge-m-0-rightarrow-Diamond-m-1"><a href="#Finite-waiting-square-ell-0-rightarrow-Diamond-ell-1-wedge-m-0-rightarrow-Diamond-m-1" class="headerlink" title="Finite waiting : $\square((\ell_0\rightarrow\Diamond\ell_1)\wedge(m_0\rightarrow\Diamond m_1))$"></a><em>Finite waiting</em> : $\square((\ell_0\rightarrow\Diamond\ell_1)\wedge(m_0\rightarrow\Diamond m_1))$</h3><blockquote>
<p>If ($\rightarrow$) $\ell_0$ is reached, eventually ($\Diamond$) it moves to $\ell_1$ and so as $m_0$ and $m_1$, this happens forever ($\square$)</p>
</blockquote>
<p>In other words, each process only waits a finite amount of time (in locations $\ell_0$ and $m_0$, respectively) until it enters the $\text{critical}$ region (in locations $\ell_1$ and $m_1$, respectively):</p>
<p>This property is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Safety_and_liveness_properties#Liveness">Liveness</a> conditions, usually involve infinite number of steps. Usually it is only meaningful when it is held under additional assumptions on the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linear_time_property#Fairness_properties">fairness</a> of the <strong>scheduler</strong>.</p>
<h3 id="Finite-waiting-under-Fairness-square-Diamond-P-0-wedge-square-Diamond-P-1-rightarrow-square-ell-0-rightarrow-Diamond-ell-1-wedge-m-0-rightarrow-Diamond-m-1"><a href="#Finite-waiting-under-Fairness-square-Diamond-P-0-wedge-square-Diamond-P-1-rightarrow-square-ell-0-rightarrow-Diamond-ell-1-wedge-m-0-rightarrow-Diamond-m-1" class="headerlink" title="Finite waiting under Fairness : $(\square\Diamond P_0\wedge\square\Diamond P_1)\rightarrow\square((\ell_0\rightarrow\Diamond\ell_1)\wedge(m_0\rightarrow\Diamond m_1))$"></a><em>Finite waiting under Fairness</em> : $(\square\Diamond P_0\wedge\square\Diamond P_1)\rightarrow\square((\ell_0\rightarrow\Diamond\ell_1)\wedge(m_0\rightarrow\Diamond m_1))$</h3><blockquote>
<p><code>Finite waiting</code> is required if both $P_0$ and $P_1$ will always happens (taking turns)</p>
</blockquote>
<p>Let the atomic propositions $P_0$ and $P_1$ denote that the <strong>scheduler</strong> allows the respective process to advance in the current step. The subformula $\square\Diamond P_0$ states that process $P_0$ is scheduled infinitely often (always eventually). The <em>finite waiting property</em> is thus only required to hold if both processes are scheduled infinitely often.</p>
<h3 id="Bounded-overtaking-square-ell-0-rightarrow-neg-m-1-mathcal-U-m-1-mathcal-U-neg-m-1-mathcal-U-ell-1"><a href="#Bounded-overtaking-square-ell-0-rightarrow-neg-m-1-mathcal-U-m-1-mathcal-U-neg-m-1-mathcal-U-ell-1" class="headerlink" title="Bounded overtaking : $\square(\ell_0\rightarrow(\neg m_1\ \mathcal{U}\ (m_1\ \mathcal{U}\ (\neg m_1\ \mathcal{U}\ \ell_1))))$"></a><em>Bounded overtaking</em> : $\square(\ell_0\rightarrow(\neg m_1\ \mathcal{U}\ (m_1\ \mathcal{U}\ (\neg m_1\ \mathcal{U}\ \ell_1))))$</h3><blockquote>
<p>If $\ell_0$ is reached, it must leave the location $m_1$, and wait until $\ell_1$ is reached; when it leaves $\ell_1$, then it is allowed to move back to location $m_1$ again. This repeats infinitely.</p>
</blockquote>
<p>In program $\small{\text{TURN}}$, the shared variable $t$ ensures that the processes <em>take turns</em> in entering their respective $\text{critical}$ regions. <em>Bounded Overtaking</em> refers to once process $P_0$ reaches location $\ell_0$, process $P_1$ can enter location $m_1$ at most once before Process $P_0$ enters location $\ell_1$.</p>
<p>This formulization of <em>bounded overtaking</em> requires that Process $P_1$ will eventually reach $\ell_1$. Sometimes we may also prefer a weaker requirement, where <strong>waiting forever</strong> is fine, as long as Process $P_1$ does not get to enter $m_1$ more than once in the meantime. We can simply change the operator into <code>weak until</code>$(\mathcal{W})$ to allow the processes to wait forever: $\square(\ell_0\rightarrow(\neg m_1\ \mathcal{W}\ (m_1\ \mathcal{W}\ (\neg m_1\ \mathcal{W}\ \ell_1))))$</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In the next section, we will define the semantics of the logic for our automaton.</p>
<hr>
<p>Next chapter: <a href="../agv6-3/">LTL and Counting Languages</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Safety_and_liveness_properties">Safety and liveness properties</a>. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linear_time_property">Linear time property</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-23T12:40:02.000Z" title="23/11/2024, 13:40:02">2024-11-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.414Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1185 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-1/">AGV 6.1 -- Linear-Time Temporal Logic (LTL)</a></p><div class="content"><p>Previous chapter: <a href="../agv5-3/">Complement Büchi Automaton with Odd Ranking</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the following sections, we introduce several logics for the specification of sets of infinite sequences: <strong>LTL</strong>, <strong>QPTL</strong>, and <strong>S1S</strong>, which can be used to describe $\omega$-regular languages: we can translate a given formula into an automaton that recongnizes the models of the formula.</p>
<p>As a result, we can use the automata-theoretic machinery to answer logical questions like <code>satisfiability</code> or <code>validity</code>. We can also use the logics as a much more convenient starting point, compared to a direct specification using automata, for <code>verification</code> and <code>synthesis</code>.</p>
<h2 id="Linear-Time-Temporal-Logic-LTL"><a href="#Linear-Time-Temporal-Logic-LTL" class="headerlink" title="Linear-Time Temporal Logic (LTL)"></a>Linear-Time Temporal Logic (LTL)</h2><p>Linear-time temporal logic (LTL) is a popular logic for the specification of reactive systems. For a given set of <code>atomic propositions</code>$(AP)$, the formulas of <code>LTL</code> define sets of infinite words over the alphabet $2^{AP}$.</p>
<ul>
<li><strong>Atomic Propositions:</strong><br>the interface of a system or a component, such as (a boolean representation of) input and output variables</li>
<li><strong>Words defined by the Formula:</strong><br>the executions of the system that are considered correct (see example in <a href="../agv1-1/">section 1.1</a>).</li>
</ul>
<h3 id="Syntax-of-LTL"><a href="#Syntax-of-LTL" class="headerlink" title="Syntax of LTL"></a>Syntax of LTL</h3><p>φ has to be true until and including the point where ψ first becomes true; if ψ never becomes true, φ must remain true forever.</p>
<p>LTL formulars are constructed from <code>proposition logic</code> with extra <code>temporal operators</code>.</p>
<blockquote>
<p>$\begin{array}{lrl} \ \textit{Propositional logic}\newline\hspace{1cm} \cdot \ p,\varphi,\dots\in AP&amp;&amp; \ \text{(Atomic Propositions)}\newline\hspace{1cm} \cdot \ \neg\varphi,\varphi\wedge\psi,\dots&amp;&amp; \ \text{(Logical Operators)}\newline \ \textit{Temporal Operator}\newline\hspace{1cm} \cdot \bigcirc\varphi \ &#x2F;\  \mathcal{X}\ \varphi&amp; \ \text{Ne}\textbf{X}\text{t: }&amp;\varphi\text{ has to be }\textit{true}\text{ in next state}\newline\hspace{1cm} \cdot \ \Diamond \ \varphi \ &#x2F;\  \mathcal{F}\ \varphi&amp; \ \textbf{F}\text{inally: }&amp;\varphi\text{ has to be }\textit{true}\text{ eventually}\newline\hspace{1cm} \cdot \ \square \ \varphi \ &#x2F;\  \mathcal{G}\ \varphi&amp; \ \textbf{G}\text{lobally: }&amp;\varphi\text{ has to be }\textit{true}\text{ for now and so on}\newline\hspace{1cm} \cdot \ \varphi \ \mathcal{U} \ \psi&amp; \ \textbf{U}\text{ntil: }&amp;\varphi\text{ has to be }\textit{true}\textit{ at least }\text{until }\psi\text{ becomes }\textit{true}\newline\hspace{1cm} \cdot \ \varphi \ \mathcal{R} \ \psi&amp; \ \textbf{R}\text{elease: }&amp;\psi\text{ has to be }\textit{true}\text{ until }\varphi\text{ becomes true (inclusive)}\newline&amp;&amp;\psi\text{ remains }\textit{true}\textit{ forever}\text{ if } \varphi\text{ never becomes }\textit{true}\newline\hspace{1cm} \cdot \ \varphi \ \mathcal{W} \ \psi&amp; \ \textbf{W}\text{eak until: }&amp;\varphi\text{ has to be }\textit{true}\textit{ at least }\text{until }\psi\text{ becomes }\textit{true}\text{, or}\newline&amp;&amp;\varphi\text{ remains }\textit{true}\textit{ forever}\text{ if }\psi\text{ never becomes }\textit{true}\newline\hspace{1cm} \cdot \ \varphi \ \mathcal{M} \ \psi&amp; \ \textbf{M}\text{ighty Release: }&amp;\psi\text{ has to be }\textit{true}\text{ until }\varphi\text{ becomes true (inclusive)}\end{array}$</p>
</blockquote>
<h3 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h3><p>When we determine whether a LTL formula is $\textit{true}$ or $\textit{false}$, it only depends on <strong>current and future</strong> states.</p>
<p>For example, the formula $\varphi\ \mathcal{U}\ \psi$ states that $\varphi$ must remain $\textit{true}$ <strong>UNTIL</strong> $\psi$ become $\textit{true}$. If the current state we have only $\psi&#x3D;\textit{true}$, this formula is still evaluated as $\textit{true}$, even if $\varphi$ never become $\textit{true}$.</p>
<p>We can conclude that, $\varphi\ \mathcal{U}\ \psi &#x3D; \textit{true}$ if:</p>
<ol>
<li>In current state $\psi$ becomes $\textit{true}$ (regardless of $\varphi$’s condition)</li>
<li>Eventually $\psi$ becomes $\textit{true}$ in certain state (not now), and from now <strong>Until</strong> that state, $\varphi$ must remain $\textit{true}$</li>
</ol>
<h2 id="Sematics-of-LTL"><a href="#Sematics-of-LTL" class="headerlink" title="Sematics of LTL"></a>Sematics of LTL</h2><h3 id="Additional-operators"><a href="#Additional-operators" class="headerlink" title="Additional operators"></a>Additional operators</h3><p>$\mathcal{R}$, $\Diamond\ (\mathcal{F})$, $\square\ (\mathcal{G})$ are considered as <em>additional operators</em>, which can be defined by other LTL operators:</p>
<ul>
<li>$\varphi\ \mathcal{R}\ \psi\equiv\neg(\neg\varphi\ \mathcal{U}\ \neg\psi)$</li>
<li>$\square\ \varphi \equiv\neg\ \Diamond\ \neg\ \varphi\equiv\ \textit{false}\ \mathcal{R}\ \varphi$</li>
<li>$\Diamond\ \varphi\equiv\textit{true} \ \mathcal{U}\ \varphi$</li>
</ul>
<h3 id="Weak-until-mathcal-W-and-Mighty-release-mathcal-M"><a href="#Weak-until-mathcal-W-and-Mighty-release-mathcal-M" class="headerlink" title="Weak until $\mathcal{W}$ and Mighty release $\mathcal{M}$"></a>Weak until $\mathcal{W}$ and Mighty release $\mathcal{M}$</h3><p><strong>W</strong>eak Until is <strong>U</strong>ntil that accepts no stop conditions <strong>F</strong>orever, or <strong>R</strong>elease that include itself as the stop conditions:</p>
<ul>
<li>$\varphi\ \mathcal{W}\ \psi\equiv(\varphi\ \mathcal{U}\ \psi) \vee \square\ \psi\equiv\psi\ \mathcal{R}\ (\psi\vee\varphi)$</li>
</ul>
<p><strong>M</strong>ighty release is forced to <strong>R</strong>elease <strong>F</strong>inally, or simply <strong>U</strong>ntil both propositions becomes $\textit{true}$:</p>
<ul>
<li>$\varphi\ \mathcal{W}\ \psi\equiv(\varphi\ \mathcal{R}\ \psi) \wedge \Diamond\ \varphi\equiv\psi\ \mathcal{U}\ (\psi\wedge\varphi)$</li>
</ul>
<h3 id="Distributivity"><a href="#Distributivity" class="headerlink" title="Distributivity"></a>Distributivity</h3><p>$\bigcirc\ (\mathcal{X})$, $\Diamond\ (\mathcal{F})$, $\square\ (\mathcal{G})$, $\mathcal{U}$ satisfied distributivity:</p>
<ul>
<li>$\bigcirc(\varphi\vee\psi)\equiv(\bigcirc\varphi)\vee(\bigcirc\psi)$</li>
<li>$\bigcirc(\varphi\wedge\psi)\equiv(\bigcirc\varphi)\wedge(\bigcirc\psi)$</li>
<li>$\Diamond(\varphi\vee\psi)\equiv(\Diamond\varphi)\vee(\Diamond\psi)$</li>
<li>$\square(\varphi\wedge\psi)\equiv(\square\varphi)\wedge(\square\psi)$</li>
<li>$\rho\ \mathcal{U}\ (\varphi\vee\psi)\equiv(\rho\ \mathcal{U}\ \varphi)\vee(\rho\ \mathcal{U}\ \psi)$</li>
<li>$(\varphi\wedge\psi)\ \mathcal{U}\ \rho\equiv(\varphi\ \mathcal{U}\ \rho)\wedge(\psi\ \mathcal{U}\ \rho)$</li>
<li>$\bigcirc(\varphi\ \mathcal{U}\ \psi)\equiv(\bigcirc\varphi)\ \mathcal{U}\ (\bigcirc\psi)$</li>
</ul>
<h3 id="Negation-Dual"><a href="#Negation-Dual" class="headerlink" title="Negation Dual"></a>Negation Dual</h3><ul>
<li>First of all, Ne<strong>X</strong>t is a self dual:<br>$\neg\bigcirc\varphi\equiv\bigcirc\neg\varphi$ (Not in next step &#x3D; Next step won’t happened)</li>
<li><strong>F</strong>inally and <strong>G</strong>lobally are dual:<br>$\neg\Diamond\varphi\equiv\square\neg\varphi$ (Never happened eventually &#x3D; Forever never happened)<br>$\neg\square\varphi\equiv\Diamond\neg\varphi$ (Won’t happen forever &#x3D; eventually won’t happen anymore)</li>
<li><strong>U</strong>ntil and <strong>R</strong>elease are dual:<br>$\neg(\varphi\ \mathcal{U}\ \psi)\equiv\neg\varphi\ \mathcal{R}\ \neg\psi$ ($\psi$ won’t happen until $\varphi$ stops &#x3D; $\psi$ can’t happen unless $\varphi$ stops)<br>$\neg(\varphi\ \mathcal{R}\ \psi)\equiv\neg\varphi\ \mathcal{U}\ \neg\psi$ (Never stop $\psi$ with $\varphi$ &#x3D; $\varphi$ never happens, if it does, that means $\psi$ has been stopped)</li>
<li>Similarly, <strong>W</strong>eak Until and <strong>M</strong>ighty Release are also dual:<br>$\neg(\varphi\ \mathcal{W}\ \psi)\equiv\neg\varphi\ \mathcal{M}\ \neg\psi$<br>$\neg(\varphi\ \mathcal{M}\ \psi)\equiv\neg\varphi\ \mathcal{W}\ \neg\psi$</li>
</ul>
<h3 id="Special-temporal-properties"><a href="#Special-temporal-properties" class="headerlink" title="Special temporal properties"></a>Special temporal properties</h3><ul>
<li>$\Diamond\varphi\equiv\Diamond\Diamond\varphi$<br>(<strong>F</strong>inally <strong>F</strong>inally $\varphi$ is $\textit{true}$)</li>
<li>$\square\varphi\equiv\square\square\varphi$<br>($\varphi$ is always always $\textit{true}$)</li>
<li>$\varphi\ \mathcal{U}\ \psi\equiv\varphi\ \mathcal{U}\ (\varphi\ \mathcal{U}\ \psi)$<br>($\varphi$ is $\textit{true}$ <strong>U</strong>ntil $\psi$ become $\textit{true}$ &#x3D; $\varphi$ is $\textit{true}$ <strong>U</strong>ntil, if “$\varphi$ is $\textit{true}$ <strong>U</strong>ntil $\psi$ become $\textit{true}$” is $\textit{true}$)</li>
<li>$\Diamond\varphi\equiv\varphi\vee \bigcirc(\Diamond\varphi)$<br>( $\varphi$ <strong>F</strong>inally becomes $\textit{true}$ &#x3D; either now $\varphi$ is $\textit{true}$ or in ne<strong>X</strong>t step $\varphi$ <strong>F</strong>inally becomes $\textit{true}$)</li>
<li>$\square\varphi\equiv\varphi\wedge \bigcirc(\square\varphi)$<br>( $\varphi$ is always $\textit{true}$ &#x3D; now $\varphi$ is $\textit{true}$ and in ne<strong>X</strong>t step $\varphi$ is also always $\textit{true}$)</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this section, we have go through basic sytanx and properties of LTL. In next section we will try to apply the formula to some systems and $\omega$-languages.</p>
<hr>
<p>Next chapter: <a href="../agv6-2/">Expressing Program Properties using LTL</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-22T15:36:01.000Z" title="22/11/2024, 16:36:01">2024-11-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.414Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">9 minutes read (About 1354 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv5-3/">AGV 5.3 -- Complement Büchi Automaton with Odd Ranking</a></p><div class="content"><p>Previous chapter: <a href="../agv5-2/">Ranking of DAG</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In <a href="../agv4-2/">section 4.2</a>, we have shown the complementation construction for <strong>deterministic Büchi Automata</strong>.</p>
<p>Now, by using DAG we can construct complement automaton of any Büchi Automata, with the help of the definition of <code>odd ranking</code> and the new function <strong>Level Ranking</strong>.</p>
<h2 id="Level-Ranking"><a href="#Level-Ranking" class="headerlink" title="Level Ranking"></a>Level Ranking</h2><blockquote>
<p>$\textbf{Definition 5.3. }\text{(Level Ranking). Consider a Büchi Automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize(F)).\newline\text{A level ranking }\ell\text{ is a pair }(S,g)\text{ such that:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ S\subseteq Q,\newline<br>\hspace{1cm} \cdot \ g:S\rightarrow\lbrace 0,\dots,2|Q|\rbrace\text{ with }g(q)\text{ necessarily even if }q\in F.\end{array}\newline \ \newline\text{We also denote: }$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ \textsf{Lvlrks}&amp;&#x3D;&amp;\text{the (finite) set of level ranks, and }\newline<br>\hspace{1cm} \cdot \ \textsf{Initrks}&amp;&#x3D;&amp;\text{the set of level ranks s.t. }S&#x3D;I\end{array}\newline \ \newline<br>\hspace{1cm}\text{We say that a level ranking }\ell’\text{, given by }(S’,g’)\text{ cover }\ell\text{, given by }(S,g)\text{ for }\sigma\in\Sigma,\newline\text{if }S’&#x3D;\lbrace q’\mid(q,\sigma,q’)\in T\rbrace\text{ and for all }q\in S,q’\in S’\text{ with }(q,\sigma,q’)\in T\text{, it holds that } g’(q’)\leq g(q).$</p>
</blockquote>
<p>Here, the <code>level ranking</code> refers to a pair that contains set of states that share the same ranking.</p>
<h3 id="ell’-covers-ell"><a href="#ell’-covers-ell" class="headerlink" title="$\ell’$ covers $\ell$ ?"></a>$\ell’$ covers $\ell$ ?</h3><p>The last part of the definition states that one level ranking is <strong>covering</strong> the other if the following satisfied:</p>
<ul>
<li>Let $\ell’&#x3D;(S’,g’)$ and $\ell&#x3D;(S,g)$ for $\sigma\in\Sigma$</li>
<li>$q$ are the states that in the set $S$, so as $q’$ are in $S’$</li>
<li><strong>All states $q’$ are some successors of some states</strong> $q, \ (S’&#x3D;\lbrace q’\mid(q,\sigma,q’)\in T\rbrace)$</li>
<li>for all $q\in S,q’\in S’, (q,\sigma,q’)\in T$, <strong>the rank of $q’$ is lower than $q, \ (g’(q’)\leq g(q))$</strong></li>
</ul>
<p>That means the whole level’s successors will never have higher rank than itself.</p>
<h2 id="Complement-Automaton-Construction"><a href="#Complement-Automaton-Construction" class="headerlink" title="Complement Automaton Construction"></a>Complement Automaton Construction</h2><p>By <a href="../agv5-2/">lemma 5.1</a>, we know that a word $\alpha$ that is rejected by $\mathcal{A}$ has an <code>odd ranking</code> on the run DAG of $\mathcal{A}$ on $\alpha$.<br>Now our complement will do the opposite: it only accepts the word that has <code>odd ranking</code>.</p>
<p>To achieve this, we construct the <code>odd ranking</code>, level by level, by assigning ranks to vertices.<br>The definition of <code>level ranks</code> and <code>covering</code> for a letter ensure that the requirements of a ranking are satisfied.</p>
<p>Through the acceptance condition, we ensure that the ranking is <code>odd</code>, i.e., there is no infinite path that consists only of even-ranked vertices.</p>
<blockquote>
<p>$\textbf{Construction 5.1. }\text{Given a Büchi Automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ that recognizes}\newline\text{the language }L\text{, we construct a Büchi Automaton}$ $$\newline \mathcal{A’}&#x3D;(\Sigma,\textsf{Lvlrks}\times\textsf{OnEvenPath},I’,T’,\small\text{BÜCHI}\normalsize(F))$$ $\text{that recognizes the language }\Sigma^\omega\setminus L\text{ as follows.}$<br>$\begin{array}{lrl}<br>\hspace{0.5cm} \cdot &amp;\textsf{OnEvenPath} &#x3D; &amp; 2^Q, \text{tracking states in the current level,} \newline<br>\hspace{0.5cm} \cdot &amp;I’&#x3D; &amp; \lbrace (\ell,R) \mid \ell \in \textsf{InitRks, } \ell \text{ is given by } (S,g) \text{, and } R &#x3D; \lbrace q \mid g(q) \text{ is even} \rbrace \rbrace \newline<br>\hspace{0.5cm} \cdot &amp;T’&#x3D; &amp; \textsf{NewEvenPaths} \cup \textsf{ContinueEvenPaths}, \text{ where} \newline<br>\hspace{0.5cm} &amp;&amp; \hspace{0.9cm}\textsf{NewEvenPaths}&#x3D;\lbrace ((\ell,\varnothing),\sigma,(\ell’,R’)) \mid \ell’ \text{ covers } \ell \text{ for } \sigma, \newline<br>\hspace{0.5cm} &amp;&amp; \hspace{4.8cm} \ell’ \text{ is given by } (S’,g’), \newline<br>\hspace{0.5cm} &amp;&amp; \hspace{4.8cm} \text{and } R’ &#x3D; \lbrace q’ \mid g’(q’) \text{ is even} \rbrace \rbrace \newline<br>\hspace{0.5cm} &amp;&amp; \textsf{ContinueEvenPaths} &#x3D; \lbrace ((\ell,R),\sigma,(\ell’,R’)) \mid R \neq \varnothing, \ell’ \text{ covers } \ell \text{ for } \sigma,\newline<br>\hspace{0.5cm} &amp;&amp; \hspace{4.8cm} \ell’ \text{ is given by } (S’,g’)\text{, and}\newline<br>\hspace{0.5cm} &amp;&amp; \hspace{4.8cm} R’ &#x3D; \lbrace q’ \mid (q,\sigma,q’) \in T, q \in R, \text{ and } g’(q’) \text{ is even} \rbrace \rbrace \newline<br>\hspace{0.5cm} \cdot &amp;F’ &#x3D; &amp; \textsf{Lvlrks} \times \lbrace \varnothing \rbrace.<br>\end{array}$</p>
</blockquote>
<h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>$Q’ &#x3D; \textsf{Lvlrks}\times\textsf{OnEvenPath}:$ all states contain their <code>level ranking</code> and set of all states that is tracked currently (states would be dropped if it leads to odd-ranked vertex).</p>
<p>$I’:$ The initial state contains the initial <code>level ranking</code> ($\textsf{Lvlrks}$), and the set of all <code>even ranking</code> states ($R$).</p>
<p>$T’:$ We have transitions $\textsf{NewEvenPaths}$ and $\textsf{ContinueEvenPaths}$. Both share some properties in common.</p>
<ul>
<li>all the states are <code>covered</code> by their successors,</li>
<li>their successors only keep track on <strong>even ranking</strong> states,</li>
<li>$\textsf{ContinueEvenPaths}$ requires that the current states must keep track on <strong>even ranking</strong> states already</li>
</ul>
<p>$F’:$ Accepting states are those has no infinite path that consists only of <code>even-ranked</code> vertices.(<code>odd ranking</code>).</p>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Now we can try to verify the Lemma with our construction:</p>
<blockquote>
<p>$\textbf{Lemma 5.2. }\textit{The automaton of Construction 5.1 has an accepting run on input }\alpha\newline\textit{if and only if the run DAG of }\mathcal{A}\textit{ on }\alpha\textit{ has an odd ranking.}$</p>
</blockquote>
<p>The run of the automaton on the input word builds a potential ranking, level by level. Note that the level-by-level guessing of the ranking is the only source of non-determinism. But if the guess is indeed an <code>odd ranking</code>, then the automaton has a unique run.</p>
<p>In the construction, we used <code>level rankings</code> to ensure the definition of <code>ranking</code> is satisified, so instead of verify whether it is <code>odd ranking</code>, we only need to verify that in the guessed ranking, there is no infinite path of even-ranked vertices.</p>
<p>At any given point, the second component ($\textsf{OnEvenPath}&#x2F;R$) in the state of the constructed automaton tracks a “batch” of paths that traverse <strong>solely through even-ranked vertices</strong>. Paths that hit an <strong>odd-ranked vertex</strong> are dropped from the batch. The <strong>acceptance condition</strong> enforces that every batch that is followed must be eventually be <strong>emptied</strong>.</p>
<blockquote>
<p><em><strong>Odd ranking &#x3D; no infinite path of even-ranked vertices &#x3D; eventually every batch are emptied</strong></em></p>
</blockquote>
<p>So we can rephrase the lemma as “The run is accepting if and only if <strong>eventually every batch are emptied</strong>“.</p>
<h3 id="If-the-run-is-accepting-then-eventually-every-batch-are-emptied"><a href="#If-the-run-is-accepting-then-eventually-every-batch-are-emptied" class="headerlink" title="If the run is accepting, then eventually every batch are emptied"></a>If the run is accepting, then eventually every batch are emptied</h3><p>This condition is clearly necessary for the guessed ranking to be odd: if there is eventually a batch that is never emptied, this corresponds to an infinite path of <code>even-ranked</code> vertices in the run DAG, violating <strong>requirement 3 (The rank cannot increase upon traversing an edge)</strong>.</p>
<p>Why? Because as long as we have one empty batch, the ranking of that batch will definitely be hihger than the those which are not empty (consider the definition of <code>rank</code> function and pruning), and any states will never have high rank than their successors.</p>
<h3 id="If-eventually-every-batch-are-emptied-then-the-run-is-accepting"><a href="#If-eventually-every-batch-are-emptied-then-the-run-is-accepting" class="headerlink" title="If eventually every batch are emptied, then the run is accepting"></a>If eventually every batch are emptied, then the run is accepting</h3><p>Assume we have non accepting run that have emptied batch, which means there is an infinite path of <code>even-ranked</code> vertices in the run DAG.</p>
<p>Now suppose this run has the batch-tracking set $\textsf{OnEvenPath}$ is emptied infinitely often. That means in the infinite path of <code>even-ranked</code> vertices there is an level $n$ so that $\textsf{OnEvenPath}$ is emptied at step $n$.</p>
<p>Because this is an infinite path of even-ranked vertices, once $\textsf{OnEvenPath}$ is emptied at step $n$, the next transition will be $\textsf{NewEvenPath}$. Which means there is a successor in level $n+1$ that has an <code>even rank</code>.</p>
<p>Since the path is infinite, subsequent transitions will be $\textsf{ContinueEvenPaths}$, and the even-rank vertices will be remained in the set of $\textsf{OnEvenPath}$. Which contradicts that the run have emptied batch. Therefore this non accepting run that have emptied batch do not exist.</p>
<hr>
<p>Next chapter: <a href="../agv6-1/">Linear-Time Temporal Logic (LTL)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-21T00:19:18.000Z" title="21/11/2024, 01:19:18">2024-11-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.413Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1245 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv5-2/">AGV 5.2 -- Ranking of DAG</a></p><div class="content"><p>Previous chapter: <a href="../agv5-1/">Infinite Directed Acyclic Graph (DAG)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Ranking"><a href="#Ranking" class="headerlink" title="Ranking"></a>Ranking</h2><p>last section, we have introduced the <strong>DAG</strong> and the <strong>pruning method</strong> to reason about the run of the word on a non-deterministic Büchi automaton. We know that pruning can be use to prove the <strong>non-acceptance</strong> of the word by automaton is we obtains an empty graph eventually.</p>
<p><img src="/../images/notes/uds/agv/5_1_g1.png"></p>
<p>In this section, we will introduce <strong>ranking</strong>, which can formalize our pruning construction.</p>
<blockquote>
<p>$\textbf{Definition 5.2. }\text{(Ranking). A }\textit{ranking}\text{ on a run DAG } G&#x3D;(V,E)\text{ is a function }f:V\rightarrow\newline\lbrace 0,\dots,2|Q|\rbrace\text{ such that:}$<br>$\begin{array}{l}\hspace{1cm} 1. \ \text{ If }q\in F\text{, then }f((q,i))\text{ is even for all }i.\newline\hspace{1cm} 2. \ \text{ If }(v,v’)\in E\text{, we have that }f(v’)\leq f(v).\end{array}\newline$<br>$\text{A ranking } f\text{ is }\textit{odd}\text{ if, for each even }j\text{, there is no infinite path in }G\text{ that consists only }\newline\text{of verticies }v\text{ such that }f(v)&#x3D;j.$</p>
</blockquote>
<p>By the above definition, we can see:</p>
<ol>
<li>All verticies that contains state q (the accepting state) are marked as even rank.</li>
<li>Verticies will never have lower rank than their successors.</li>
</ol>
<p>Most importantly, it introduced a new concept: <strong>Odd Ranking</strong>. Meaning that the run of the DAG is rejected.</p>
<h2 id="From-Ranking-to-Rank"><a href="#From-Ranking-to-Rank" class="headerlink" title="From Ranking to Rank"></a>From Ranking to Rank</h2><p>Now, let’s consider the function $rank:V\rightarrow\lbrace 0,\dots,2|Q|\rbrace$, where</p>
<ul>
<li>$rank(q,i)&#x3D;2j$ iff $(q,i)$ is <strong>endangered</strong> in $G_{2j}$, and</li>
<li>$rank(q,i)&#x3D;2j+1$ iff $(q,i)$ is <strong>safe</strong> in $G_{2j+1}$.</li>
</ul>
<p><img src="/../images/notes/uds/agv/5_2_dag.png"></p>
<p>By tracking our pruning procedure, we can easily identify their rank now.<br>Blue verticies that remove in $G_1$ are <strong>safe</strong>, thus their rank are 1, and so as orange (2), green (3) and red (4).</p>
<h2 id="From-Rank-to-Odd-Ranking"><a href="#From-Rank-to-Odd-Ranking" class="headerlink" title="From Rank to Odd Ranking"></a>From Rank to Odd Ranking</h2><p>Now back to odd ranking, by our new function $rank$, we can prove the following lemma.</p>
<blockquote>
<p>$\textbf{Lemma 5.1. }\newline\textit{A Büchi automaton }\mathcal{A}\textit{ reject the word }\alpha\textit{ iff the run DAG of }\mathcal{A}\textit{ on }\alpha\textit{ has an odd ranking}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><blockquote>
<p><strong>If the run DAG of $\mathcal{A}$ on $\alpha$ has an odd ranking, then $\alpha$ is rejected</strong></p>
</blockquote>
<p>By the definition above, we know that graph with odd ranking has <strong>no infinite path that settles on only even rank $f(v)&#x3D;j$</strong>. Which means:</p>
<ul>
<li>every run of $\mathcal{A}$ on $\alpha$ <strong>gets stuck</strong>, or,</li>
<li>eventually <strong>settles on vertices with a constant odd rank</strong>, since ranks are not increasing.</li>
</ul>
<p>In which case the run eventually only visits states that are not accepting.</p>
<blockquote>
<p><strong>If $\alpha$ is rejected, then the run DAG of $\mathcal{A}$ on $\alpha$ has an odd ranking</strong></p>
</blockquote>
<p>Since we know pruning leads to rejecting with function $rank$. Therefore, instead of using odd ranking directly, we try to show the function $rank$ is the odd ranking. To prove this, we need to show that:</p>
<ol>
<li>All vertices are indeed pruned away, latest by step $2|Q|$.</li>
<li>Accepting vertices must have an even rank</li>
<li>The rank cannot increase upon traversing an edge.</li>
<li>There is no infinite path that consists only of vertices of even rank.</li>
</ol>
<h3 id="Requirement-1-All-vertices-are-indeed-pruned-away-latest-by-step-2-Q"><a href="#Requirement-1-All-vertices-are-indeed-pruned-away-latest-by-step-2-Q" class="headerlink" title="Requirement 1: All vertices are indeed pruned away, latest by step $2|Q|$"></a>Requirement 1: All vertices are indeed pruned away, latest by step $2|Q|$</h3><p>Here, we define the <strong>width</strong> of a level $j$ in a graph $G_i$ as the number of vertices of the form $(q,j)$ in $G_i$.<br><img src="/../images/notes/uds/agv/5_2_width.png"></p>
<p>Assume we are in step $2j$, it removes all <code>endangered</code> vertices from $G_{2j}$. Then how would $G_{2j+1}$ become?</p>
<ol>
<li>become empty (all vertices in $G_{2j}$ are <code>endangered</code>)</li>
<li>still has infinitely many vertices<br>(by definition, vertices that not <code>endangered</code> always have some infinite path, also because $\infty-n&#x3D;\infty$)</li>
</ol>
<p>In scenario <strong>2</strong>, since our <code>premise</code> is that the word is <strong>rejected</strong>, there must exist a <code>safe</code> vertex in $G_{2j+1}$. If there’s no <code>safe</code> vertex, then those vertices are either accepting, or has a path to accepting vertex, which contradicts to our premise.</p>
<blockquote>
<p><em><strong>a) Each iteration there must be at least one <code>safe</code> vertex being removed</strong></em></p>
</blockquote>
<p>Among all the <code>safe</code> vertices in $G_{2j+1}$, consider the vertex $(q,m)$ which has the smallest $m$ (closest to the beginning). All descendants of this vertex in $G_{2j+1}$ are also <code>safe</code> (because <code>safe</code> refers to the whole path).</p>
<p>Therefore, these <code>safe</code> vertices will be pruned away in step $2j+1$. Observe the affect towards the width after these deletions:</p>
<ul>
<li>At the beginning of iteration $0$, each level has width at most $|Q|$ (max. no. of states).</li>
<li>In every iteration $j$, the widths of all levels $i\geq m$ decrease by at least 1.<br>(because vertex $(q,m)$ and all its descendants in $i\geq m$ are removed)</li>
</ul>
<blockquote>
<p><em><strong>b) If one <code>safe</code> vertex is removed, all its descendants will also be removed</strong></em></p>
</blockquote>
<p>By <em><strong>a)</strong></em> and <em><strong>b)</strong></em>, we can ensure that after $|Q|$ iterations of <code>safe</code> vertices removal there must be some level $m$ contains no more vertices, which means now the graph terminate in $m$ and it is a <strong>finite graph</strong>.</p>
<p>By including the iteration of <code>endangered</code> vertices, we can conclude that in step $2|Q|$, $G_{2|Q|}$ must be a finite graph, all vertices are <code>endangered</code>, thus it will prune all vertices away.</p>
<h3 id="Requirement-2-Accepting-vertices-must-have-an-even-rank"><a href="#Requirement-2-Accepting-vertices-must-have-an-even-rank" class="headerlink" title="Requirement 2: Accepting vertices must have an even rank"></a>Requirement 2: Accepting vertices must have an even rank</h3><p>Since accepting vertices are not <code>safe</code>, and our premise it that the word is rejected. That means the path contains accepting verticeis can only be <strong>finite</strong>, which means they are always <code>endangered</code>.</p>
<p>In our rank function, <code>endangered</code> vertices have even rank and thus accepting vertices always have even rank.</p>
<h3 id="Requirement-3-The-rank-cannot-increase-upon-traversing-an-edge"><a href="#Requirement-3-The-rank-cannot-increase-upon-traversing-an-edge" class="headerlink" title="Requirement 3: The rank cannot increase upon traversing an edge"></a>Requirement 3: The rank cannot increase upon traversing an edge</h3><p>Suppose there is a $(q’,i+1)$ that is pruned later than $(q,i)$. Consider the step $j$ at which $(q,i)$ is pruned. The graph $G_j$ would have contained both vertices, along with their edge.</p>
<p>If $j$ is even, it means that $(q,i)$ has even rank, and <code>endangered</code> in $G_j$ , and hence so must be its successor $(q’,i+1)$, meaning that it is pruned at step $j$.</p>
<p>If $j$ is odd, then $(q,i)$ was established to be <code>safe</code> in Gj , implying the safety of its successor too. In both cases, the pruning of $(q’,i+1)$ in the same step is inevitable.</p>
<h3 id="Requirement-4-There-is-no-infinite-path-of-only-even-ranked-vertices"><a href="#Requirement-4-There-is-no-infinite-path-of-only-even-ranked-vertices" class="headerlink" title="Requirement 4: There is no infinite path of only even-ranked vertices"></a>Requirement 4: There is no infinite path of only even-ranked vertices</h3><p>If such a path exists, since ranks do not increase along a path, and there are only finitely many ranks, this path will eventually consist only of vertices of rank $2j$.</p>
<p>However, only <code>endangered</code> verticies will have even rank in $G_{2j}$, and endangered vertices only have finite paths.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>With the above properties and proofs, we know that:</p>
<ul>
<li>the run DAG of $\mathcal{A}$ on $\alpha$ has an odd ranking &#x3D; $\alpha$ is rejected</li>
<li>Pruning method with $rank$ function &#x3D; odd ranking</li>
</ul>
<blockquote>
<p>So if a word is rejected, its run DAG always becomes an empty graph after pruning, and if a run DAG eventually becomes an empty graph after pruning, it must be rejected by $\mathcal{A}$.</p>
</blockquote>
<p>With these definition, we can now construct complementation of Büchi automaton $\mathcal{A}$ using the run DAG of $\mathcal{A}$ and the odd ranking. Let see how is it done in the next section.</p>
<hr>
<p>Next chapter: <a href="../agv5-3/">Complement Büchi Automaton with Odd Ranking</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-20T15:44:16.000Z" title="20/11/2024, 16:44:16">2024-11-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.424Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 893 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv5-1/">AGV 5.1 -- Infinite Directed Acyclic Graph (DAG)</a></p><div class="content"><p>Previous chapter: <a href="../agv4-2/">Complementation of deterministic Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Reasoning-about-all-runs-of-an-automaton"><a href="#Reasoning-about-all-runs-of-an-automaton" class="headerlink" title="Reasoning about all runs of an automaton"></a>Reasoning about all runs of an automaton</h2><p>Since complementation inevitably introduce <strong>nondeterminism</strong>, we need to check whether <strong>all</strong> runs of the automaton on the word are <strong>rejecting</strong> to determine whether a word is in the complement of the language recognized by this Büchi automaton.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Consider the following nondeterministic Büchi automaton $\mathcal{A}$. Its language consists of all infinite words over $\lbrace a,b\rbrace$ with infinitely many <em>b</em>s, i.e., $(a^*b)^\omega$:</p>
<p><img src="/../images/notes/uds/agv/5_1_eg.png"></p>
<blockquote>
<p>$\textbf{Definition 5.1. }\text{Let }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ be a Büchi automaton. The run DAG of }\mathcal{A}\newline\text{on a word }\alpha\in\Sigma^\omega\text{ is the directed acylic graph }G&#x3D;(V,E)\text{, where}$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ V&amp;&#x3D;&amp;\cup_{i\geq0}(Q_i\times\lbrace i\rbrace)\text{ with }Q_0&#x3D;I\text{ and}\newline<br>\hspace{1.1cm} \ Q_{i+1}&amp;&#x3D;&amp;\lbrace q’\mid(q,\alpha(i),q’)\in T\text{ for some }q\in Q\rbrace\newline<br>\hspace{1cm} \cdot \ E&amp;&#x3D;&amp;\lbrace((q,i),(q’,i+1))\mid i\geq 0,(q,\alpha(i),q’)\in T\rbrace.\end{array}$<br>$\text{For a natural number }i\text{, we refer to the set }Q_i\text{ as the }\textit{level }i\text{ of the DAG.}$</p>
</blockquote>
<p>Using <strong>infinite directed acyclic graph (DAG)</strong> to represent the set of all runs on a particular word, e.g., $ababa^\omega$.</p>
<p><img src="/../images/notes/uds/agv/5_1_g1.png"></p>
<p>In the above example: the word $\alpha&#x3D;ababa^\omega$ has only two <em>b</em>‘s and hence must be rejected by $\mathcal{A}$.</p>
<p>Since the automaton is nondeterministic, a single word of $\mathcal{A}$ will have multiple runs on $\alpha$, represented by each <em>path in DAG</em>. The path is called accepting <strong>if and only if</strong> its corresponding run is accepting, i.e., the path visits $F\times\mathcal{A}$ infinitely often.</p>
<h2 id="Graph-Pruning"><a href="#Graph-Pruning" class="headerlink" title="Graph Pruning"></a>Graph Pruning</h2><p>To show the <strong>non-acceptance</strong> of $\alpha$ by $\mathcal{A}$, we can systematically identifying and pruning away vertices of the run DAG that only lead to rejecting paths until the graph is empty using the following definitions:</p>
<table>
<thead>
<tr>
<th align="left">Vertices in DAG</th>
<th align="left">Defintiion</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Endangered</code></td>
<td align="left">when they only have <strong>finitely many descendants</strong></td>
</tr>
<tr>
<td align="left"><code>Safe</code></td>
<td align="left">when they are <strong>not in</strong> $F\times\mathcal{A}$, and <strong>none of its descendants</strong> are in $F\times\mathcal{A}$ either</td>
</tr>
</tbody></table>
<p>We start with a graph $G_0&#x3D;G$. Each iteration $j\geq 0$ of our pruning will consist of two steps:</p>
<ol>
<li>in step $2j$, the graph &#x3D; $G_{2j}$, remove all <code>endangered</code> vertices, graph after removal &#x3D; $G_{2j+1}$</li>
<li>in step $2j+1$, the graph &#x3D; $G_{2j+1}$, remove all <code>safe</code> vertices, graph after removal &#x3D; $G_{2j+2}$</li>
</ol>
<h3 id="Step-0-Remove-endangered-vertices"><a href="#Step-0-Remove-endangered-vertices" class="headerlink" title="Step 0: Remove endangered vertices"></a>Step 0: Remove <code>endangered</code> vertices</h3><ul>
<li>Input: $G_0$ ↑ (using example above), Output: $G_1$ ↓</li>
</ul>
<p>Since there’s no <code>endangered</code> verticies, $G_0$ &#x3D; $G_1$</p>
<p><img src="/../images/notes/uds/agv/5_1_g1.png"></p>
<h3 id="Step-1-Remove-safe-vertices-marked-as-blue"><a href="#Step-1-Remove-safe-vertices-marked-as-blue" class="headerlink" title="Step 1: Remove safe vertices (marked as blue)"></a>Step 1: Remove <code>safe</code> vertices (marked as blue)</h3><ul>
<li>Input: $G_1$ ↑, Output: $G_2$ ↓</li>
</ul>
<p>As we can see all vertices that in state r stay in r forever (accepting state is q). Therefore those path can never be accepted and they are safe.</p>
<p><img src="/../images/notes/uds/agv/5_1_g2.png"></p>
<h3 id="Step-2-Remove-endangered-vertices-marked-as-red"><a href="#Step-2-Remove-endangered-vertices-marked-as-red" class="headerlink" title="Step 2: Remove endangered vertices (marked as red)"></a>Step 2: Remove <code>endangered</code> vertices (marked as red)</h3><ul>
<li>Input: $G_2$ ↑, Output: $G_3$ ↓</li>
</ul>
<p>After <code>safe</code> verticies in r are removed, paths towards r from q become dead end. Therefore they are now <code>endangered</code>.</p>
<p><img src="/../images/notes/uds/agv/5_1_g3.png"></p>
<h3 id="Step-3-Remove-safe-vertices-marked-as-blue"><a href="#Step-3-Remove-safe-vertices-marked-as-blue" class="headerlink" title="Step 3: Remove safe vertices (marked as blue)"></a>Step 3: Remove <code>safe</code> vertices (marked as blue)</h3><ul>
<li>Input: $G_3$ ↑, Output: $G_4$ ↓</li>
</ul>
<p>Now all the vertices starting from (p,3) stay in p forever. Therefore they are <code>safe</code> as well.</p>
<p><img src="/../images/notes/uds/agv/5_1_g4.png"></p>
<h3 id="Step-4-Remove-endangered-vertices-marked-as-red"><a href="#Step-4-Remove-endangered-vertices-marked-as-red" class="headerlink" title="Step 4: Remove endangered vertices (marked as red)"></a>Step 4: Remove <code>endangered</code> vertices (marked as red)</h3><ul>
<li>Input: $G_4$ ↑, Output: $G_5$ ↓</li>
</ul>
<p>Now the graph is finite, meaning all the vertices in the graph are <code>endangered</code>.</p>
<p><img src="/../images/notes/uds/agv/5_1_g5.png"></p>
<p>Therefore, graph $G_5$ will be an empty graph, which means there’s no accepting path and thus the word $ababa^\omega$ is rejected.</p>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>We start from removing <code>endangered</code> verticies in <strong>step 0</strong> because they can never infinitely reach the accepting states. Then we can remove all <code>Safe</code> verticies in <strong>step 1</strong> because they never visit accepting states anymore.</p>
<p>For the subsequent pruning, if a vertex v of the original run DAG is pruned away in step $2j$ because it is <code>endangered</code> in $G_{2j}$, it means that all paths from v in the original run DAG can reach were pruned away in the earlier steps.</p>
<p>Similarly, if a vertex v of the original run DAG is pruned away in step $2j+1$ because it is <code>safe</code> in $G_{2j+1}$, it means that v corresponds to a <strong>non-accepting state</strong>. And furthermore, all paths from v in the original run DAG either avoid accepting vertices, or eventually reach a vertex that was pruned away in the earlier steps.</p>
<p>So we can see that if a vertex is pruned away, all paths from that vertex are rejecting. Hence, if our scheme eventually obtains the empty graph, the pruning is a proof of the non-acceptance of the word by the automaton.</p>
<p>We formalize this type of reasoning as a <code>ranking</code>, which labels the vertices with numbers. We will define <code>ranking</code> in the next chapter. </p>
<hr>
<p>Next chapter: <a href="../agv5-2/">Ranking of DAG</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-19T22:12:02.000Z" title="19/11/2024, 23:12:02">2024-11-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.413Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 984 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv4-2/">AGV 4.2 -- Complementation of deterministic Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv4-1/">Deterministic vs. Nondeterministic Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>For regular languages, Complementation is very simple: one translates a given complete deterministic automaton $\mathcal{A}$ that recognizes some language $L\subseteq\Sigma^*$ into an automaton $\mathcal{A’}$ that recognizes the complement $\Sigma^*\setminus L$ by complementing the set of final states, i.e., $F’&#x3D;Q\setminus F$.</p>
<p>For deterministic Büchi automata, the construction is tricky, because it introduces <strong>nondeterminism</strong></p>
<blockquote>
<p>$\textbf{Construction 4.1. }\text{Let }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ be a complete deterministic Büchi}\newline\text{automaton, where we assume w.l.o.g. that } Q\neq\varnothing. \text{ We construct a Büchi automaton}\newline\mathcal{A’}&#x3D;(\Sigma,Q’,I’,T’,\small\text{BÜCHI} \normalsize (F’))\text{ with }\mathcal{L}(\mathcal{A’})&#x3D;\Sigma^\omega\setminus\mathcal{L}(\mathcal{A})\text{ as follows:}$<br>$\begin{array}{lrll}<br>\hspace{1cm} \cdot &amp;Q’&amp;&#x3D;&amp;(Q\times\lbrace 0\rbrace)\cup((Q\setminus F)\times\lbrace 1\rbrace)\newline<br>\hspace{1cm} \cdot &amp;I’&amp;&#x3D;&amp;I\times\lbrace 0\rbrace\newline<br>\hspace{1cm} \cdot &amp;T’&amp;&#x3D;&amp;\lbrace ((q,0),\sigma,(q’,i))\mid(q,\sigma,q’)\in T,i\in\lbrace 0,1\rbrace,(q’,i)\in Q’\rbrace \cup \newline<br>\hspace{1cm} \ &amp;&amp;&amp;\lbrace ((q,1),\sigma,(q’,1))\mid(q,\sigma,q’)\in T,q’,q’\in Q\setminus F\rbrace\newline<br>\hspace{1cm} \cdot &amp;F’&amp;&#x3D;&amp;(Q\setminus F)\times\lbrace 1\rbrace<br>\end{array}$</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$Q’$</td>
<td align="left">Uses two copies of the given automaton $\mathcal{A}$, mark them seperately using $\lbrace 0\rbrace$ and $\lbrace 1\rbrace$, notice that all <strong>accpeting states</strong> from $\lbrace 1\rbrace$ are eliminated</td>
</tr>
<tr>
<td align="left">$I’$</td>
<td align="left">The complemented automaton starts from initial states from $\lbrace 0\rbrace$.</td>
</tr>
<tr>
<td align="left">$T’$</td>
<td align="left">The switch from $\lbrace 0\rbrace$ and $\lbrace 1\rbrace$ happens nondeterministically. And once you enter the second copy $\lbrace 1\rbrace$, it stays forever.</td>
</tr>
<tr>
<td align="left">$F’$</td>
<td align="left">The automaton $\mathcal{A’}$ accepts if the run ends up in the second copy, which means that, on the unique run of $\mathcal{A}$ on the input word, the accepting states of $\mathcal{A}$ are only visited <strong>finitely often</strong>.</td>
</tr>
</tbody></table>
<p>Note that the resulting automaton is <strong>nondeterministic</strong>. This is, in general, <strong>unavoidable</strong>.</p>
<p>This is because there are languages, such as $L&#x3D;(b^*a)^\omega$ where the language itself is recognizable by a deterministic Buchi automaton, while its complement $\Sigma^\omega\setminus L$ can only be recognized by a nondeterministic Büchi automaton.</p>
<blockquote>
<p>$\textbf{Theorem 4.3. }\textit{For every deterministic Büchi automaton }\mathcal{A}\textit{, there exists a Büchi automaton }\mathcal{A’}\newline\textit{ such that }\mathcal{L}(\mathcal{A’})&#x3D;\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}).$</p>
</blockquote>
<h3 id="Explained-in-Human-Language"><a href="#Explained-in-Human-Language" class="headerlink" title="Explained in Human Language"></a>Explained in Human Language</h3><p>$\mathcal{L}(\mathcal{A’})\subseteq\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}):$</p>
<p>To prove that “If $\alpha$ is accepted by $\mathcal{L}(\mathcal{A’})$, then it is also accepted by the complement of $\mathcal{L}(\mathcal{A})$”, we can show that every state in $\mathcal{A’}$ is same as $\mathcal{A}$, but as long as it switched to $\lbrace 1\rbrace$, it stays forever and there is no accepting states of $\mathcal{A}$.</p>
<p>Therefore, every accepted word in $\mathcal{L}(\mathcal{A’})$ is also accepted in $\Sigma^\omega \setminus\mathcal{L}(\mathcal{A})$.</p>
<p>$\mathcal{L}(\mathcal{A’})\supseteq\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}):$</p>
<p>To prove that “If $\alpha$ is accepted by the complement of $\mathcal{L}(\mathcal{A})$, then it is also accepted by $\mathcal{L}(\mathcal{A’})$”, we assume there’s a word $\alpha$ that is not accepted by $\mathcal{L}(\mathcal{A})$.</p>
<p>Since $\mathcal{A}$ is <strong>complete</strong> and <strong>deterministic</strong>, so the run on $\alpha$ is still infinite, yet <strong>never</strong> visit the accepted states <strong>infinitely often</strong>. i.e. starting from certain position, it will never visit the accepting states anymore.</p>
<p>We can treat that position as the switch from $\lbrace 0\rbrace$ and $\lbrace 1\rbrace$ in $\mathcal{A’}$ occurs. And therefore $\alpha$ is an accepted word in $\mathcal{L}(\mathcal{A’})$.</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>Let $\mathcal{A’}$ be constructed from the given deterministic Büchi automaton $\mathcal{A}$ (which we<br>assume, w.l.o.g., to be complete) by <em>Construction 4.1.</em> We prove that $\mathcal{L}(\mathcal{A’})&#x3D;\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}).$</p>
<p>$\mathcal{L}(\mathcal{A’})\subseteq\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}):$</p>
<p>For every word $\alpha\in\mathcal{L}(\mathcal{A’})$ we have an accepting run: $r’:(q_0,0)(q_1,0)\dots(q_j,0)(q’_0,1)(q_1,1)\dots$ on $\mathcal{A}$. Hence, $r:q_0q_1\dots q_jq_0’q_1’\dots$ is the unique run of $\mathcal{A}$ on $\alpha$. Since $q_0’,q_1’,\dots\in Q\setminus F$, we have that $\text{Inf}(r)\subseteq Q\setminus F$. Hence, $r$ is not accepting and $\alpha\in\Sigma^\omega\setminus\mathcal{L}(\mathcal{A})$.</p>
<p>$\mathcal{L}(\mathcal{A’})\supseteq\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}):$</p>
<p>Let $\alpha\notin\mathcal{L}(\mathcal{A’})$ be some word that is not in the language of $\mathcal{A}$. Since $\mathcal{A}$ is complete and deterministic, there exists a unique run $r:q_0q_1q_2\dots$ of $\mathcal{A}$ on $\alpha$ and  $\text{Inf}(r)\cap F&#x3D;\varnothing$. Thus, there exists a $k\in\mathbb{N}$ such that $q_j\notin F$ for all $j &gt; k$.</p>
<p>This gives us the run: $r’:(q_0,0)(q_1,0)\dots(q_j,0)(q’_0,1)(q_1,1)\dots$ of $\mathcal{A’}$ on $\alpha$ with $\text{Inf}(r)\subseteq ((Q\setminus F)\times\lbrace 1\rbrace)&#x3D;F’$. Hence, $r’$ is accepting and therefore $\alpha\in\mathcal{L}(\mathcal{A’})$.</p>
<h3 id="Example-mathcal-L-mathcal-A-b-ast-a-omega-and-mathcal-L-mathcal-A’-a-b-ast-b-omega"><a href="#Example-mathcal-L-mathcal-A-b-ast-a-omega-and-mathcal-L-mathcal-A’-a-b-ast-b-omega" class="headerlink" title="Example: $\mathcal{L}(\mathcal{A})&#x3D;(b^\ast a)^\omega$ and $\mathcal{L}(\mathcal{A’})&#x3D;(a+b)^\ast b^\omega$"></a>Example: $\mathcal{L}(\mathcal{A})&#x3D;(b^\ast a)^\omega$ and $\mathcal{L}(\mathcal{A’})&#x3D;(a+b)^\ast b^\omega$</h3><p><img src="/../images/notes/uds/agv/4_2_eg.png"></p>
<p>Note that, since not all $\omega$-regular languages can be recognized by deterministic Büchi automata, Construction 4.1 does not provide us with a complementation construction for all $\omega$-regular languages. Such a general construction is the subject of the following section.</p>
<hr>
<p>Next chapter: <a href="../agv5-1/">Infinite Directed Acyclic Graph (DAG)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-17T23:11:57.000Z" title="18/11/2024, 00:11:57">2024-11-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.413Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 809 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv4-1/">AGV 4.1 -- Deterministic vs. Nondeterministic Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv3-5/">Büchi’s Characterization Theorem</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the theory of automata over finite words, we have <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Powerset_construction">Rabin-Scott powerset construction</a>, which converts a <em>nondeterministic automaton</em> over finite words into a <em>deterministic automaton</em> that <strong>recognizes the same language</strong>. This shows that nondeterminism does not make automata over finite words more expressive (but makes it more concise as the construction produces an exponential number of states).</p>
<p>The situation is different for Büchi automata: even though the language $L &#x3D; (a+b)^*b^\omega$ is clearly <em>Büchi-recognizable</em>, there is, as the following theorem shows, <strong>no deterministic Büchi automaton that recognizes L</strong>.</p>
<h2 id="Deterministic-vs-nondeterministic-Buchi-automata"><a href="#Deterministic-vs-nondeterministic-Buchi-automata" class="headerlink" title="Deterministic vs. nondeterministic Büchi automata"></a>Deterministic vs. nondeterministic Büchi automata</h2><blockquote>
<p>$\textbf{Theorem 4.1. }\textit{Language $L&#x3D;(a+b)^*b^\omega$ is not recognizable by deterministic Büchi Automata}$</p>
</blockquote>
<p>Starting a base case $b^\omega$, we add $(a+b)$ as the prefix one by one. Can we express the  <strong>kleene star</strong>?<br>That is, is the automaton only accept <strong>finitely many</strong> $(a+b)$?</p>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Assume, by way of contradiction, that $L$ is recognizable by the deterministic Büchi automaton $\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize(F))$. Since $\alpha_0&#x3D;b^\omega$ is in $L$, there is an unique run</p>
<p>$$r_0&#x3D;r_0(0)r_0(1)r_0(2)\dots$$</p>
<p>of $\mathcal{A}$ on $\alpha_0$ with $r_0(n_0)\in F$ for some $n_0\in\mathbb{N}$. Similarly, $\alpha_1&#x3D;b^{n_0}ab^\omega$ in $L$ and there is a unique run</p>
<p>$$r_1&#x3D;r_0(0)r_0(1)r_0(2)\dots r_0(n_0)r_1(n_0+1)r_1(n_0+2)\dots$$</p>
<p>of $\mathcal{A}$ on $\alpha_1$ with $r_1(n_1)\in F$ for some $n_1&gt;n_0$. Since $\mathcal{A}$ is deterministic, $r_0$ &amp; $r_1$ are identical up to position $n_0$.</p>
<p>By repeating this argument infinitely often, we obtain a word $\alpha&#x3D;b^{n_0}ab^{n_1}ab^{n_2}a\dots$ and a run $r$ with infinitely many visits to $F$. Hence, $\alpha$ is accepted by $\mathcal{A}$. However, $\alpha$ is not an element of $L$. This contradicts $L &#x3D; \mathcal{L}(\mathcal{A})$.</p>
<h2 id="Limit-Operator"><a href="#Limit-Operator" class="headerlink" title="Limit Operator"></a>Limit Operator</h2><p>We start by defining a <em>Limit Operator</em> to generate $\omega$-language using regular language. For the regular language $W$, $\overrightarrow{W}$ contains all the words that they all contain words in $W$ as substrings.</p>
<blockquote>
<p>$\textbf{Definition 4.1. }\text{(Limit). The}\textit{ limit }\overrightarrow{W}\text{ of a language }W\subseteq\Sigma^* \text{ over finite words}\newline\text{is the following language over infinite words:}$ $$\overrightarrow{W}&#x3D;\lbrace\alpha\in\Sigma^\omega\mid\text{there exist infinitely many }n\in\mathbb{N}\text{ s.t. }\alpha[0,n]\in W\rbrace.$$</p>
</blockquote>
<p>And From regular language, now we can define an $\omega$-regular language that is recognizable by deterministic Büchi Automata:</p>
<blockquote>
<p>$\textbf{Theorem 4.2. }\textit{An }\omega\textit{-language }L\subseteq\Sigma^\omega\textit{ is recognizable by a deterministic Büchi Automata}\newline\textit{iff there is a regular langauge }W\subseteq\Sigma^*\textit{ s.t. }L&#x3D;\overrightarrow{W}.$</p>
</blockquote>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>Basically, we are trying to prove $\mathcal{L}(\mathcal{A_B})&#x3D;\overrightarrow{\mathcal{L}(\mathcal{A_F})}$, where $\mathcal{L}(\mathcal{A_B})$ is a deterministic Büchi Automata and $\mathcal{L}(\mathcal{A_F})$ is a a deterministic automaton over finite words.</p>
<p>As we can see, an accepted word $\alpha\in\mathcal{L}(\mathcal{A_B})$ with have substring $\alpha[0,n]$ that is accepted by $\mathcal{L}(\mathcal{A_F})$ with infinitely many $n\in\mathbb{N}$, by the definition of the <em>limit operator</em>.</p>
<p>We can prove regular language $W$ exists if $\alpha$ exists using $\overrightarrow{W}$. Automata that accepts $W$ and $\overrightarrow{W}$ should exist, namely $\mathcal{L}(\mathcal{A_F})$ and $\overrightarrow{\mathcal{L}(\mathcal{A_F})}$ respectively.</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>We claim that the languages of a deterministic Büchi automaton $\mathcal{A}_B$ and of a deterministic<br>automaton over finite words $\mathcal{A}_F$, where the automata $\mathcal{A}_B&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize(F))$ and $\mathcal{A}_F&#x3D;(\Sigma,Q,I,T,F)$, constructed from the same components, are related as follows:</p>
<p>$$\mathcal{L}(\mathcal{A_B})&#x3D;\overrightarrow{\mathcal{L}(\mathcal{A_F})}.$$</p>
<p>Since every regular language is recognized by a deterministic automaton over finite words,<br>the theorem follows. To prove the claim, we consider an infinite word $\alpha\in\Sigma^\omega$.</p>
<p>$\hspace{1cm}\alpha\in\mathcal{L}(\mathcal{A_B})\newline<br>\text{iff} \hspace{0.5cm}\text{for the unique run $r$ of $\mathcal{A_B}$ on $\alpha$, Inf($r$) $\cap$ $F\neq\varnothing$}\newline \text{iff} \hspace{0.5cm} \alpha[0,n]\in\mathcal{L}(\mathcal{A_F})\text{ for infinitely many }n\in\mathbb{N}\newline<br>\text{iff} \hspace{0.5cm} \alpha\in\mathcal{L}(\mathcal{A_F})$</p>
<hr>
<p>Next chapter: <a href="../agv4-2/">Complementation of deterministic Büchi Automata</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Powerset_construction">powerset construction</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-17T16:33:21.000Z" title="17/11/2024, 17:33:21">2024-11-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.425Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 849 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-5/">AGV 3.5 -- Büchi&#039;s Characterization Theorem</a></p><div class="content"><p>Previous chapter: <a href="../agv3-4/">Closure Properties of the Büchi-recognizable languages (Concatenations)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>We are now ready to prove Büchi’s Characterization Theorem, a result from 1962.</p>
<blockquote>
<p>$\textbf{Theorem 3.6. }\text{(Büchi’s Characterization Theorem) }\newline\textit{An $\omega$-language is Büchi-recognizable iff it is $\omega$-regular.}$</p>
</blockquote>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><blockquote>
<p>p.s. Büchi-recognizable means the language can be described by a Büchi automata.</p>
</blockquote>
<p>$”\Leftarrow”$<br>We have to prove if the language is <strong>$\omega$-regular</strong>, then it is <strong>Büchi-recognizable</strong>.<br>In <a href="../agv3-2/">section 3.2</a>, we learn that an $\omega$-regular language contains 3 operators:</p>
<ul>
<li><strong>union</strong> of $\omega$-regular languages, $W_1+W_2$ (proved by Theorem <a href="../agv3-3/">3.2</a>),</li>
<li><strong>infinite concatenation</strong> of a <strong>non-empty</strong> regular language $E^\omega$ (proved by Theorem <a href="../agv3-4/">3.4</a>), and</li>
<li><strong>concatenation</strong> of regular languages and $\omega$-regular language $E\cdot W$ (proved by Theorem <a href="../agv3-4/">3.5</a>)</li>
</ul>
<p>$”\Rightarrow”$<br>We have to prove if the language is <strong>Büchi-recognizable</strong>, then it is <strong>$\omega$-regular</strong>.<br>Here, we try to construct a Büchi-recognizable using all <strong>$\omega$-regular</strong> operators.</p>
<p>We begin by constructing a <strong>regular language</strong> $W_{q,q’}$. <strong>Words</strong> of the language $w$ is accepted by some finite-word automata, with a pair of state $q,q’\in Q$ being the <strong>initial and accepting states</strong> respectively.</p>
<p>Then we try to prove that a <strong>Büchi-recognizable language</strong> $\mathcal{L}(\mathcal{A})$ equals to the regular language <strong>concatenates</strong> (<a href="../agv3-4/">3.5</a>) with the <strong>infinite concatenated</strong>, <strong>non-empty</strong> (<a href="../agv3-4/">3.4</a>) starting from the previous accepting state. That is $W_{q,q’}\cdot(W_{q’,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$.</p>
<p>On top of that, we do a set union (<a href="../agv3-3/">3.2</a>) for each pair of <strong>initial and accepting states</strong> $q,q’\in Q$, that is $\bigcup_{q\in I,q’\in F}$</p>
<blockquote>
<p>Therefore, now we only need to prove that $\mathcal{L}(\mathcal{A})&#x3D;\bigcup_{q\in I,q’\in F}W_{q,q’}\cdot(W_{q,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$.</p>
</blockquote>
<p>For the word $\alpha$ from L.H.S, it reaches $q’\in F$ infinitely often. We can thus seperate into $r:q\xrightarrow{w_0}q’\xrightarrow{w_1}q’\xrightarrow{w_2}\dots$<br>The $w$ here refers the word to reach $q’$. We know that Büchi automata is non-empty so $|w_i|&gt;0$ when $i&gt;0$.<br>Therefore, $w_0$ will be a word from $W_{q,q’}$ and the rest will be words for $(W_{q’,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$ because they reach the accepting state $q’\in F$.</p>
<p>For the word $w_0w_1w_2\dots$ from R.H.S, where $w_0$ refers to $W_{q,q’}$ and the rest refers to $(W_{q’,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$.<br>This is accepted by $\mathcal{L}(\mathcal{A})$ because it reaches the accepting state $q’\in F$ infinitely often.</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>$”\Leftarrow”$<br>Follows from the closure properties of the Büchi-recognizable languages established by Theorems <a href="../agv3-3/">3.2</a>, <a href="../agv3-4/">3.4</a>, <a href="../agv3-4/">3.5</a>.</p>
<p>$”\Rightarrow”$<br>Given a Büchi automaton $\mathcal{A}$, we consider for each pair $q,q’\in Q$ the regular language<br>$$<br>W_{q,q’} &#x3D; \lbrace w\in\Sigma^*\mid \text{finite-word automaton } (\Sigma,Q,\lbrace q\rbrace,T,{q’}) \text{ accepts }w\rbrace.<br>$$<br>We claim that $\mathcal{L}(\mathcal{A})&#x3D;\bigcup_{q\in I,q’\in F}W_{q,q’}\cdot(W_{q,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$. The claim is proven as follows.</p>
<p>$\mathcal{L}(\mathcal{A})\subseteq\bigcup_{q\in I,q’\in F}W_{q,q’}\cdot(W_{q,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$: Let $\alpha\in\mathcal{L}(\mathcal{A})$. Then there is an accpeting run $r$ of $\mathcal{A}$ on $\alpha$, which begins at some $q&#x3D;r(0)\in I$ and visits some $q’\in F$ infinitely often:</p>
<p>$$<br>r:q\xrightarrow{w_0}q’\xrightarrow{w_1}q’\xrightarrow{w_2}\dots<br>$$</p>
<p>where $w_i\in\Sigma^*$ for all $i\ge 0$, $|w_i|&gt;0$ for all $i&gt;0$ and $\alpha&#x3D;w_0w_1w_2\dots$ The notation $q_0\xrightarrow{w}q_{k+1}$ for some finite word $w&#x3D;w(0)w(1)\dots w(k)$ means that there exist states $q_1,\dots,q_k\in Q$ s.t. $(q_i,w(i),q_{i+1})\in T$ for all $0\leq i \leq k$. Since $w_0\in W_{q,q’}$ and $w_k\in W_{q’,q’}$ for $k&gt;0$, we have that $\alpha \in W_{q,q’}\cdot W_{q’,q’}^\omega$ for some $q\in I,q’\in F$.</p>
<p>$\mathcal{L}(\mathcal{A})\supseteq\bigcup_{q\in I,q’\in F}W_{q,q’}\cdot(W_{q,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$: Let $\alpha&#x3D;w_0w_1w_2\dots$ with $w_0\in W_{q,q’}$ and $w_k\in W_{q’,q’}$ for some $q\in I,q’\in F$ and for all $k&gt;0$. Then the run:</p>
<p>$$<br>r:q\xrightarrow{w_0}q’\xrightarrow{w_1}q’\xrightarrow{w_2}\dots<br>$$</p>
<p>exists and is aceepting because $q’\in F$. It follows that $\alpha\in\mathcal{L}(\mathcal{A})$.</p>
<hr>
<p>Next chapter: <a href="../agv4-1/">Deterministic vs. Nondeterministic Büchi Automata</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/Notes/UdS/page/3/">Previous</a></div><div class="pagination-next"><a href="/categories/Notes/UdS/page/5/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/Notes/UdS/">1</a></li><li><a class="pagination-link" href="/categories/Notes/UdS/page/2/">2</a></li><li><a class="pagination-link" href="/categories/Notes/UdS/page/3/">3</a></li><li><a class="pagination-link is-current" href="/categories/Notes/UdS/page/4/">4</a></li><li><a class="pagination-link" href="/categories/Notes/UdS/page/5/">5</a></li><li><a class="pagination-link" href="/categories/Notes/UdS/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>