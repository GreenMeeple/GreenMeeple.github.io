<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-11T16:04:07.000Z" title="11/12/2024, 17:04:07">2024-12-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.405Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">4 minutes read (About 618 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-1/">AGV 10.1 -- The Muller Acceptance Condition</a></p><div class="content"><p>Previous chapter: <a href="../agv9-3/">The Emerson-Lei algorithm</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introdcution"><a href="#Introdcution" class="headerlink" title="Introdcution"></a>Introdcution</h2><p>We already established that while the languages that can be recognized with nondeterministic Büchi automata are exactly the $\omega$-regular languages, the languages that can be recognized with deterministic Büchi automata are a strictly smaller set.</p>
<p>We now repair this deficiency with a more expressive acceptance condition, the <strong>Muller condition</strong>. <strong>McNaughton’s theorem</strong> states that the set of languages recognizable by deterministic Muller automata are again exactly the $\omega$-regular languages.</p>
<p>We will see later that it is very useful to have a deterministic automaton for a given $\omega$-language, for example in synthesis, where we construct the game between the system and the environment from a deterministic automaton that recognizes the winning plays for the system player.</p>
<p>Since the complementation of <strong>deterministic Muller automata</strong> is a very simple operation, McNaughton’s theorem also provides an alternative proof for the result of <a href="../agv5-3/">Section 5</a> that the $\omega$-regular languages are closed under complementation.</p>
<h2 id="Muller-Acceptance-Condition"><a href="#Muller-Acceptance-Condition" class="headerlink" title="Muller Acceptance Condition"></a>Muller Acceptance Condition</h2><blockquote>
<p>$\textbf{Definition 10.1. } \text{The }\textit{Muller Acceptance Condition }\small\text{MULLER} \normalsize(\mathcal{F})\text{ on a set of sets of states }\newline\mathcal{F}\subseteq 2^Q\text{ is the set}$</p>
<p>$$\small\text{MULLER}\normalsize(\mathcal{F})&#x3D;\lbrace\alpha\in Q^\omega\mid\text{Inf}(\alpha)\in\mathcal{F}\rbrace$$</p>
<p>$\text{An automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,Acc) \text{ with }Acc &#x3D; \small\text{MULLER} \normalsize(\mathcal{F})\text{ is called a }\textit{Muller Automaton.}\newline\text{The set }\mathcal{F}\text{ is called the set of }\textit{accepting subsets }(\text{or the }\textit{table})\text{ of }\mathcal{A}.$</p>
</blockquote>
<p>Let’s do a small recap from <a href="../agv2-3/">section 2.3</a>:</p>
<ul>
<li><p><strong>Büchi Condition</strong></p>
<ul>
<li>$\small\text{BÜCHI} \normalsize(F) &#x3D; \lbrace\alpha\in Q^\omega \mid \text{Inf}(\alpha) \cap F \neq \varnothing\rbrace$</li>
<li>word $\alpha$ visit some state in set $F$ infinitely often.</li>
</ul>
</li>
<li><p><strong>Muller Acceptance Condition</strong></p>
<ul>
<li>$\small\text{MULLER}\normalsize(\mathcal{F})$</li>
<li>word $\alpha$ visit some <strong>set of states</strong> in set $\mathcal{F}$ infinitely often.</li>
</ul>
</li>
</ul>
<p>We can see Muller Acceptance Condition are <strong>more expressive</strong> in terms of visiting accepting states, because you can require the word to visit a set of states infinitely often instead just one state out of the whole set.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Consider the deterministic automaton over the alphabet $\Sigma&#x3D;\lbrace a, b\rbrace$ shown below.</p>
<p>For the table $\mathcal{F}&#x3D;\lbrace\lbrace q\rbrace\rbrace$, it means the automaton can only visit $\lbrace q\rbrace$ infinitely often. We obtain the Muller automaton $\mathcal{A}$ recognizing the language $\mathcal{L(A)}&#x3D;(a+b)^\ast b^\omega$;</p>
<p>For the table $\mathcal{F}’&#x3D;\lbrace\lbrace q\rbrace\lbrace p,q\rbrace\rbrace$, it means the automaton has to visit either $\lbrace q\rbrace$ or $\lbrace p,q\rbrace$ infinitely often. We obtain the Muller automaton $\mathcal{A’}$ recognizing $\mathcal{L(A’)}&#x3D;(a^\ast b)^\omega$.</p>
<p><img src="/images/notes/uds/agv/10_1_muller.png"></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>We introduced Muller Acceptance Condition, which is slightly more advanced than the Büchi Acceptance Condition:</p>
<table>
<thead>
<tr>
<th align="left">Aspect</th>
<th align="left">Büchi Acceptance</th>
<th align="left">Muller Acceptance</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Acceptance states</td>
<td align="left">At least one accepting state must appear infinitely often.</td>
<td align="left">The set of states that visited infinitely often must match a subset in $\mathcal{F}$</td>
</tr>
<tr>
<td align="left">Condition Set</td>
<td align="left">$F$ is the set of accepting states</td>
<td align="left">$\mathcal{F}$ is the set of the set of accepting states (subset of the set)</td>
</tr>
<tr>
<td align="left">Expressiveness</td>
<td align="left">Less expressive (<a href="../agv4-1/">example</a>)</td>
<td align="left">Fully expressive</td>
</tr>
<tr>
<td align="left">Complexity</td>
<td align="left">Simpler and easier to implement.</td>
<td align="left">More complex, requires tracking recurring state sets.</td>
</tr>
</tbody></table>
<p>In the following sections, we will discuss about the translation from Büchi automata to Muller automata.</p>
<hr>
<p>Next chapter: <a href="../agv10-2/">From Büchi automata to Muller automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-10T02:56:12.000Z" title="10/12/2024, 03:56:12">2024-12-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 861 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv9-3/">AGV 9.3 -- The Emerson-Lei algorithm</a></p><div class="content"><p>Previous chapter: <a href="../agv9-2/">Nested depth-first search</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>As an alternative algorithm for checking language emptiness of Büchi automata we now discuss a classic algorithm due to Emerson and Lei. Unlike the <a href="../agv9-2/">depth-first search</a> of the previous subsection, the <strong>Emerson-Lei algorithm</strong> is based on a <strong>breadth-first search</strong> implemented as a fixpoint construction over sets of states.</p>
<p>A disadvantage of this algorithm is that its running time is <em>quadratic</em>. Nevertheless, algorithms of this type play a major role in <em>symbolic model checking</em>, because the sets of states can often be represented efficiently<br>using data structures like <em>binary decision diagrams</em>.</p>
<h3 id="Live-states"><a href="#Live-states" class="headerlink" title="Live states"></a>Live states</h3><p>A state $q$ of a Büchi automaton is <code>live</code> if some infinite path starting in $q$ visits accepting states infinitely often. This definition is the opposite of <code>safe</code> states, where it never visits accepting states. The idea of the algorithm is to identify the set of <code>live</code> states.  The language of a Büchi automaton is <strong>non-empty</strong> iff it has a <strong>live initial state</strong>.</p>
<p>The <strong>Emerson-Lei algorithm</strong> is based on the following inductive definition:</p>
<blockquote>
<p>$\textbf{Definition 9.1. } \text{For a Büchi automaton and a number }n\in\mathbb{N}\text{, the set of }\textit{n-live states}\text{ is}\newline\text{defined as follows:}$</p>
<p>$\begin{array}{l}<br>\hspace{1cm}\cdot\ \text{every state is 0-live}\newline<br>\hspace{1cm}\cdot\ \text{a state q is (n + 1)-live if some path containing at least one transition leads from }q\newline\hspace{1.3cm}\text{to an accepting n-live state}\newline<br>\end{array}$</p>
</blockquote>
<h3 id="Fixpoint"><a href="#Fixpoint" class="headerlink" title="Fixpoint"></a>Fixpoint</h3><p>Let $\mathit{live}_n$ denote the set of $n$-live states. It is easy to see that $\mathit{live}_{n} \supseteq \mathit{live}_{n+1}$, because $\mathit{live}_{0}$ represents the set of all states in the automaton, and $\mathit{live}_{1}$ are only those which can reach the accepting states. Then $\mathit{live}_{2}$ are those who can only reach the accepting states through some states in $\mathit{live}_{1}$. Therefore set $\mathit{live}_{n+1}$ can never be larger than its previous set $\mathit{live}_{n}$.</p>
<p>Since the set of states is finite, there exists a <strong>fixpoint</strong> $\mathit{live}_k$ such that $\mathit{live}_k&#x3D;\mathit{live}_{k+1}$. Then the set $\mathit{live}_k$ is the set of live states.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/9_2_dfs.png"></p>
<p>In the example from <a href="../agv9-2/">last section</a>, states $q_0$, $q_1$ and $q_2$ are live; states $q_3$, $q_4$, and $q_5$ are only $0$-$\textit{live}$ (you cannot visit other accepting states starting from $q_3$ even though it is an accepting state).</p>
<p>To describe the algorithm, we first introduce a construction that implements a backward breadth-first search as a least fixpoint. The construction computes all states from which a given set of states is reachable.</p>
<blockquote>
<p>$\textbf{Construction 9.1. } \text{For a Büchi Automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ and a set of states}\newline R\subseteq Q\text{, we compute the set of backwards reachable states from }R\text{ as follows:}$</p>
<p>$\begin{array}{llll}<br>\hspace{1cm} \cdot &amp; \textit{Pre}(R)&amp;&#x3D;&amp;\lbrace q\in Q\mid \exists q’\in R,\sigma\in\Sigma,(q,\sigma,q’)\in T\rbrace\newline<br>\hspace{1cm} \cdot &amp; \textit{BackwardReach}_0(R)&amp;&#x3D;&amp;R\newline<br>\hspace{1cm} \cdot &amp; \textit{BackwardReach}_{n+1}(R)&amp;&#x3D;&amp;\textit{BackwardReach}_{n}(R)\cup\textit{Pre}(\textit{BackwardReach}_{n}(R))\newline<br>\hspace{1cm} \cdot &amp; \textit{BackwardReach}(R)&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcup}\textit{BackwardReach}_{n}(R)\newline<br>\end{array}$</p>
</blockquote>
<p>By this construction, it returns a set of states that can reach some states in $R$. For example, $\lbrace q_0,q_1,q_2\rbrace$ can reach $q_3$. Using this construction as a subroutine, we can compute the live states as a greatest fixpoint:</p>
<blockquote>
<p>$\textbf{Construction 9.2. } \text{For a Büchi Automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ we compute the set}\newline\text{of live states as follows:}$</p>
<p>$\begin{array}{llll}<br>\hspace{1cm} \cdot &amp; \textit{live}_0&amp;&#x3D;&amp;Q\newline<br>\hspace{1cm} \cdot &amp; \textit{live}_{n+1}&amp;&#x3D;&amp;\textit{BackwardReach}(\textit{Pre}(\textit{live}_n\cap F))\newline<br>\hspace{1cm} \cdot &amp; \textit{live}&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcap}\textit{live}_{n}\newline<br>\end{array}$</p>
</blockquote>
<p>The set of $\textit{live}$ is the smallest subset of all $\textit{live}_n$ in any $n\in\mathbb{N}$. Therefore the function will stop when $\mathit{live}_k$ such that $\mathit{live}_k&#x3D;\mathit{live}_{k+1}$, which is the greatest fixpoint of the set of <code>live</code> states.</p>
<p>Then we can verify whether the automaton is non-empty, i.e. $q_0\in\textit{live}$.</p>
<h3 id="Example-cont"><a href="#Example-cont" class="headerlink" title="Example (cont.)"></a>Example (cont.)</h3><p>We compute the live states as follows:</p>
<p>$\begin{array}{llll}<br>\hspace{1cm} \cdot &amp; \textit{live}_0&amp;&#x3D;&amp;\lbrace q_0,q_1,q_2,q_3,q_4,q_5\rbrace\newline<br>\hspace{1cm} \cdot &amp; \textit{live}_1&amp;&#x3D;&amp;\lbrace q_0,q_1,q_2\rbrace\newline<br>\hspace{1cm} \cdot &amp; \textit{live}_2&amp;&#x3D;&amp;\lbrace q_0,q_1,q_2\rbrace\newline<br>\hspace{1cm} \cdot &amp; \textit{live}&amp;&#x3D;&amp;\lbrace q_0,q_1,q_2\rbrace\newline<br>\end{array}$</p>
<p>Since the initial state $q_0$ is <code>live</code>, we have that the language of the automaton is <strong>non-empty</strong>.</p>
<hr>
<p>Next chapter: <a href="../agv10-1/">The Muller Acceptance Condition</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-09T15:52:17.000Z" title="09/12/2024, 16:52:17">2024-12-09</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 770 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv9-2/">AGV 9.2 -- Nested depth-first search</a></p><div class="content"><p>Previous chapter: <a href="../agv9-1/">Automata-based LTL Model Checking with Sequential Circuits</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now develop an algorithm for checking whether the language of a given Büchi automaton is <code>empty</code>. A natural idea is to use <strong>depth-first search (DFS)</strong> twice.</p>
<p>The language is non-empty $\Leftrightarrow$ it is accepted by some words:</p>
<ol>
<li>there exists an accepting state $q$,</li>
<li>$q$ is reachable from some initial state (discovered by 1st DFS), and</li>
<li>$q$ can again be reached from $q$ (discovered by 2nd DFS),</li>
</ol>
<h2 id="Example-Simple-DFS"><a href="#Example-Simple-DFS" class="headerlink" title="Example (Simple DFS)"></a>Example (Simple DFS)</h2><p>Consider the following Büchi automaton (edge labels do not matter and are omitted).</p>
<p><img src="/images/notes/uds/agv/9_2_dfs.png"></p>
<p><code>Step 1</code>: discovers $q_0$, $q_1$, and $q_3$.<br><code>Step 2</code>: searches from $q_0$ and $q_3$: not successful; searches from $q_1$: discovers the path back to $q_1$ via $q_2$.</p>
<p>The drawback of the algorithm discussed so far is its <strong>quadratic running time</strong>: potentially, each state in $F$ discovered by the first DFS requires a fresh second DFS. The quadratic running time can be avoided by stopping the DFS in <code>Step 2</code> whenever a state is encountered that was already visited during <code>Step 2</code>.</p>
<p>However, this is only sound if the searches in <code>Step 2</code> are executed in the right order. If we first execute the DFS from $q_0$ in Example 9.2, then this search visits all states; in a subsequent search from $q_1$, we would, therefore, no longer discover the successful path back to $q_1$ via $q_2$!</p>
<p>It turns out that it is sound to restrict the searches in <code>Step 2</code> if they are executed in order of <em>increasing finishing times</em> of the DFS in <code>Step 1</code>. The emptiness check with nested DFS therefore uses <code>Step 1</code> to order the reachable accepting states according to their finishing times; in <code>Step 2</code>, a DFS is initiated from each reachable accepting state in this order until a cycle is detected. <code>Step 2</code> marks the visited states and restricts the searches so that no state is visited twice during <code>Step 2</code>.</p>
<h2 id="A-Modified-Example-Nested-DFS"><a href="#A-Modified-Example-Nested-DFS" class="headerlink" title="A Modified Example (Nested DFS)"></a>A Modified Example (Nested DFS)</h2><p>Continue from above, a possible annotation of the states with pairs <em>(discovery, finishing)</em> of discovery and finishing times during the DFS in Step 1 is the following:</p>
<p><img src="/images/notes/uds/agv/9_2_dfs2.png"></p>
<p>Ordering the accepting states according to increasing finishing times, we obtain the order $q_3$, $q_1$, $q_0$. In Step 2, the DFS from $q_3$ visits (unsuccessfully) $q_3$, $q_4$ and $q_5$. The DFS from $q_1$<br>then only visits $q_1$ and $q_2$, upon which it has successfully discovered the path from $q_2$ to $q_2$.</p>
<h2 id="Nested-DFS-and-Buchi-Automaton"><a href="#Nested-DFS-and-Buchi-Automaton" class="headerlink" title="Nested DFS and Büchi Automaton"></a>Nested DFS and Büchi Automaton</h2><blockquote>
<p>$\textbf{Theorem 9.1. }\textit{For a Büchi automaton }\mathcal{A}\textit{, nested DFS is successful iff }\mathcal{L(A)}\textit{ is nonempty.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>$”\Rightarrow”$<br>If the nested DFS is successful then there exists a state $q$ that is reachable from some initial state such that there is a path from $q$ back to $q$. Hence, $\mathcal{L(A)}$ is non-empty.</p>
<p>$”\Leftarrow”$<br>To show that we can safely ignore the states that were visited in previous searches in <code>Step 2</code>, we consider the situation at the beginning of a DFS from some accepting state $q\in F$ in <code>Step 2</code>. Let $T$ be the set of states visited in previous searches in <code>Step 2</code>. We prove that there is no cycle $q_0,q_1,\dots,q_k$ with $q&#x3D;q_0&#x3D;q_k$ such that $\lbrace q_0,q_1,\dots,q_k\rbrace\cap T\neq \varnothing$ i.e., the states in $T$ can be ignored while looking for $q$-cycles.</p>
<p>Assume, by way of contradiction, that there is a state $q$ where this condition is violated for the first time. Let $t\in\lbrace q_0,q_1,\dots,q_k\rbrace\cap T$, and let $u\in F$ be the accepting state such that $t$ has been added to $T$ during the DFS in <code>Step 2</code>. This means that the DFS from $u$ was invoked before the DFS from $q$; hence, $u$ has an earlier finishing time than $q$ in den DFS of <code>Step 1</code>.</p>
<ul>
<li><p>Case 1: $u$ was discovered before $q$ in the DFS of <code>Step 1</code>. This cannot be the case, because $q$ is reachable from $u$, and, thus, the finishing time of $q$ would have been earlier than that of $u$.</p>
</li>
<li><p>Case 2: u was discovered after $q$ in the DFS of <code>Step 1</code>. Then $q$ was still on the stack of the DFS when $u$ was finished. Hence, $u$ is reachable from $q$. Thus, $u$ and $q$ are on a cycle. This cycle (or some other cycle) would have been discovered during the DFS from $u$ in <code>Step 2</code>.</p>
</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv9-3/">The Emerson-Lei algorithm</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-08T15:44:01.000Z" title="08/12/2024, 16:44:01">2024-12-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 809 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv9-1/">AGV 9.1 -- Automata-based LTL Model Checking with Sequential Circuits</a></p><div class="content"><p>Previous chapter: <a href="../agv8-5/">From Linear Arithmetic to Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p><img src="/images/notes/uds/agv/9_1.png"></p>
<h3 id="Right-hand-side-Hondeterministic-Buchi-automata"><a href="#Right-hand-side-Hondeterministic-Buchi-automata" class="headerlink" title="Right hand side: Hondeterministic Büchi automata"></a>Right hand side: Hondeterministic Büchi automata</h3><p>In order to find system executions that violate a given <strong>LTL formula (1)</strong>, we <strong>negate the formula (2)</strong> and build an automaton that is equivent to the negated formula. For this, we can use the translaton from LTL to <strong>alternating automata (3)</strong> from <a href="../agv7-2/">Construction 7.1</a> followed by the Miyano-Hayashi translation from alternating Büchi automata to <strong>nondeterministic Büchi automata (4)</strong> from <a href="../agv7-3/">Construction 7.2</a>.</p>
<h3 id="Left-hand-side-Safety-Automaton"><a href="#Left-hand-side-Safety-Automaton" class="headerlink" title="Left hand side: Safety Automaton"></a>Left hand side: Safety Automaton</h3><p>We represent the <strong>system (1)</strong> executions as a <strong>Safety Automaton (2)</strong>, which is then intersected (using <a href="../agv3-3/">Construction 3.2</a> with the Büchi automaton for the negated LTL formula. The actual search for a violating execution then happens as the emptiness check of the resulting Büchi automaton. In the remainder of this section, we first quickly discuss the representation of the system as a <strong>Safety Automaton</strong>, using <strong>sequential circuits</strong> as an example, and then focus on the emptiness check of Büchi automata.</p>
<h2 id="Model-Checking-Sequential-Circuits"><a href="#Model-Checking-Sequential-Circuits" class="headerlink" title="Model Checking Sequential Circuits"></a>Model Checking Sequential Circuits</h2><p>As an illustration of how automata can be used to represent system behaviors, we consider the representation of sequential circuits to safety automata. For a more general discussion of how to represent different types of systems, such as protocols or software, we refer the reader to textbooks on model checking, such as <a target="_blank" rel="noopener" href="https://is.ifmo.ru/books/_principles_of_model_checking.pdf">Principles of Model Checking</a> by Baier and Katoen.</p>
<h3 id="Sequential-Circuits"><a href="#Sequential-Circuits" class="headerlink" title="Sequential Circuits"></a>Sequential Circuits</h3><blockquote>
<p>$\textbf{Definition 9.1. } \text{A }\textit{sequential circuit }\text{is given as a tuple }S&#x3D;(I,O,R,\theta,\lambda,\delta)\text{, where}$</p>
<p>$\begin{array}{lcl}<br>\hspace{1cm}\cdot&amp;I&amp;\text{is a set of input bits}\newline<br>\hspace{1cm}\cdot&amp;O&amp;\text{is a set of output bits}\newline<br>\hspace{1cm}\cdot&amp;R&amp;\text{is a set of registers}\newline<br>\hspace{1cm}\cdot&amp;\theta\subseteq R&amp;\text{is an initial register evaluation}\newline<br>\hspace{1cm}\cdot&amp;\lambda:O\rightarrow(2^{I\cup R}\rightarrow\mathbb{B})&amp;\text{assigns to each output bit a control function }2^{I\cup R}\rightarrow\mathbb{B}\newline<br>\hspace{1cm}\cdot&amp;\delta:R\rightarrow(2^{I\cup R}\rightarrow\mathbb{B})&amp;\text{assigns to each output bit a update function }2^{I\cup R}\rightarrow\mathbb{B}\newline<br>\end{array}$</p>
</blockquote>
<h3 id="Safety-Automaton"><a href="#Safety-Automaton" class="headerlink" title="Safety Automaton"></a>Safety Automaton</h3><p>A safety automaton is a Büchi automaton where <strong>all states are accepting</strong>. Here, Input $(I)$ and Output $(O)$ are represented as words, and register valuation $(R)$ is represented as states:</p>
<blockquote>
<p>$\text{A sequential circuit can be represented as a safety automaton}\newline\mathcal{A}_S&#x3D;(2^{I\cup O},2^R,I,T,\small\text{BÜCHI} \normalsize (Q))\text{, where}$</p>
<p>$\begin{array}{ll}<br>\cdot\ Q &#x3D; &amp;2^R\hspace{1cm}\text{consist of all valuations of the registers;}\newline<br>\cdot\ I &#x3D;&amp; \lbrace\theta\rbrace\hspace{0.8cm}\text{corresponds to the inital register valuation;}\newline<br>\cdot\ T&#x3D;&amp;\lbrace(q,\sigma,q’)\mid\lbrace\forall y\in O:y\in \sigma\text{ iff }\lambda(y)(q\cup(\sigma\cap I))\rbrace\wedge\lbrace\forall r\in R:r\in q’\text{ iff }\delta(r)(q\cup(\sigma\cap I))\rbrace\rbrace\newline<br>&amp;\hspace{1.5cm}\text{reflect the outputs specified by the control functions, and}\newline<br>&amp;\hspace{1.5cm}\text{the new register valuation specified by the update function}\end{array}$</p>
</blockquote>
<p>We say that a circuit $S$ <em>satisfies</em> an LTL formula $\varphi$ if $\mathcal{L}(\mathcal{A}_S) ⊆ \mathcal{L(\varphi)}$.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>The example circuit shown on the left has input $I &#x3D; \lbrace x\rbrace$, output $O &#x3D; \lbrace y\rbrace$, and a single register $R &#x3D; \lbrace r\rbrace$. The control function of $y$ is $x\text{ XOR }r$, the update function of $r$ is $x\vee r$.</p>
<p>We assume an initial register valuation $\theta &#x3D; \varnothing$. The circuit is then represented as the automaton shown on the right. Note that that accepting state only have transtions $\lbrace x\rbrace, \lbrace y\rbrace$, becasue if $\lbrace x\rbrace$ holds, $\lbrace y\rbrace$ cannot hold because of the $\text{XOR}$ gate and vice versa.</p>
<p><img src="/images/notes/uds/agv/9_1_eg.png"></p>
<p>Suppose now that we wish to verify whether our circuit satisfies the LTL formula $\varphi &#x3D; \square(x\leftrightarrow y)$. We negate $\varphi$, and translate the resulting formula into the nondeterministic Büchi automaton shown on the left:</p>
<p><img src="/images/notes/uds/agv/9_1_auto.png"></p>
<p>The intersection of the languages of the automaton representing the circuit and the automaton representing the negation of $\varphi$ results in the automaton shown above on the right.</p>
<p>Since there are some words that can be accepted by both automaton and their intersections, the language of this automaton is not empty: for example, the word $\lbrace x, y\rbrace(\lbrace x\rbrace)^\omega$. The circuit, hence, does not satisfy $\varphi$.</p>
<hr>
<p>Next chapter: <a href="../agv9-2/">Nested depth-first search</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-07T00:49:11.000Z" title="07/12/2024, 01:49:11">2024-12-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1206 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-5/">AGV 8.5 -- From Linear Arithmetic to Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv8-4/">Homogenous Inequality Testing is Automatic</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>With all the setup in the previous sections, We are now ready to prove the main result of this chapter.</p>
<blockquote>
<p>$\textbf{Theorem 8.1. }\textit{Let }\varphi\textit{ be a linear arithmetic formula. We can effectively construct a Büchi}\newline\textit{Automaton }\mathcal{A}\textit{ such that }\mathcal{L(A)}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models\varphi\rbrace$</p>
</blockquote>
<p>We follow the same strategy as for the analogous result for S1S in <a href="../agv6-7/">Section 6.7</a>.</p>
<ol>
<li>Introduce a logic with a (slightly) <em>restricted syntax</em> from S1S,</li>
<li>Show that the restriction does not come at the cost of expressive power, and</li>
<li>Use structural induction on <em>restricted-syntax formulas</em> to construct our desired automata.</li>
</ol>
<h2 id="Restricted-Linear-Arithmetic"><a href="#Restricted-Linear-Arithmetic" class="headerlink" title="Restricted Linear Arithmetic"></a>Restricted Linear Arithmetic</h2><p>The formulas of syntactically restricted linear arithmetic are defined by the following grammar:</p>
<p>$$\varphi::&#x3D;z&#x3D;1\mid g_1x_1+\dots+g_\ell x_\ell\leq h_1 y_1+\dots+h_m y_m\mid\neg\varphi\mid\varphi\wedge\varphi\mid\exists x.\varphi$$</p>
<p>where $z, x_1,\dots,x_\ell,y_1,\dots,y_m\in V$ are <strong>variables</strong>, and $p_1,\dots,p_\ell,q_1,\dots,q_m$ are <strong>positive constants</strong>. The restriction is that <strong>all inequalities must be homogenous</strong>, except $z&#x3D;1$ being the only <strong>non-homogenous relation</strong>.</p>
<h3 id="homogenous-inequalities-conversion"><a href="#homogenous-inequalities-conversion" class="headerlink" title="homogenous inequalities conversion"></a>homogenous inequalities conversion</h3><p>In fact, <strong>“all inequalities must be homogenous”</strong> is not a semantic restrictionm, since we can always convert non-homogenous inequalities into a homogenous version:</p>
<blockquote>
<p>For a formula $\varphi_0$ contains non-homogenous inequalities, first replace all constants $r$ by $r\cdot z$, where $z$ is a fresh variable to obtain $\varphi’_0$, then replace $\varphi_0$ with $\varphi::&#x3D;\exists z. (z&#x3D;1\wedge\varphi’_0)$.</p>
</blockquote>
<p>For example, $\varphi_0::&#x3D;y\leq2,\varphi_0’::&#x3D;y\leq2\cdot z,$ now we have $\varphi_0::&#x3D;\exists z. (z&#x3D;1\wedge(y\leq2\cdot z)))$</p>
<p>To include all possible expression of the real number $1$, the encoding must be a word of the form $00^\ast(1{$} 0^\omega + {$} 1^\omega)$. It is thus trivial to construct an automaton corresponding to $z&#x3D;1$.</p>
<h2 id="From-Linear-Arithmetic-to-Automata"><a href="#From-Linear-Arithmetic-to-Automata" class="headerlink" title="From Linear Arithmetic to Automata"></a>From Linear Arithmetic to Automata</h2><p>We use <a href="../agv8-4/">Construction 8.1</a> to construct automata for <strong>homogenous inequalities</strong>. Note that the construction works even when one of the sides of the inequality is equal to $0$ (i.e., the empty sum).</p>
<p>Now we start with inductive cases. Recall that for any $k$ we can construct an automaton <a href="../agv8-4/">$\mathcal{L(A_{\textsf{valid},k})}$</a> that checks whether a word $\alpha\in(\lbrace 0,1\rbrace^k\cup\lbrace{$}\rbrace)^k)^\omega$ is a well-formed encoding of some valuation $\sigma$ to $k$ free variables.</p>
<h3 id="Negation-mathcal-A-neg-varphi"><a href="#Negation-mathcal-A-neg-varphi" class="headerlink" title="Negation $\mathcal{A_{\neg\varphi}}$"></a>Negation $\mathcal{A_{\neg\varphi}}$</h3><p>The Büchi automaton $\mathcal{A_{\neg\varphi}}$ is obtained through complementation and intersection of Büchi automata.</p>
<p>Let $\varphi$ have $k$ free variables. For negation, we have</p>
<p>$$\mathcal{L(A_{\neg\varphi})}&#x3D;((\lbrace 0,1\rbrace^k\cup\lbrace{$}\rbrace)^k)^\omega\setminus\mathcal{L(A_\varphi)})\cap\mathcal{L(A_{\textsf{valid},k})}$$</p>
<h3 id="Conjunction-mathcal-A-varphi-1-wedge-varphi-2"><a href="#Conjunction-mathcal-A-varphi-1-wedge-varphi-2" class="headerlink" title="Conjunction $\mathcal{A_{\varphi_1\wedge\varphi_2}}$"></a>Conjunction $\mathcal{A_{\varphi_1\wedge\varphi_2}}$</h3><p>$\mathcal{A_{\varphi_1\wedge\varphi_2}}$ can be obtained similarly straightforward through the intersection of two Büchi automata because</p>
<p>$$\mathcal{L(A_{\varphi_1\wedge\varphi_2})}&#x3D;\mathcal{L(A_{\varphi_1})}\cap\mathcal{L(A_{\varphi_2})}$$</p>
<h3 id="Existential-Quantification"><a href="#Existential-Quantification" class="headerlink" title="Existential Quantification"></a>Existential Quantification</h3><p>To handle projection, i.e. construct $\mathcal{A_{\exists x.\varphi}}$ from $\mathcal{A_{\varphi}}$, we first try to see their difference:</p>
<ul>
<li>$\mathcal{A_{\varphi}}$ runs over the alphabet $\lbrace 0, 1\rbrace^{k+1}\cup\lbrace{$}\rbrace^{k+1}$ and reads the encoding of a valuation of $\lbrace x,y_1,\dots, y_k\rbrace$.</li>
<li>$\mathcal{A_{\exists x.\varphi}}$ runs over the alphabet $\lbrace 0, 1\rbrace^k\cup\lbrace{$}\rbrace^k$ and reads the encoding of a valuation of $\lbrace y_1,\dots, y_k\rbrace$,</li>
</ul>
<p>Same as before, the principle behind the construction is to create a automaton that simulate identical behaviour with the absence of $x$. This is simple for most of the transitions except for the initial transition.</p>
<p>For a automaton that does not contain $x$, it has to “guess” an encoding of $x$ such that $\varphi(x,y_1,\dots, y_k)$ holds. However, the given encoding of the valuation of $\lbrace y_1,\dots, y_k\rbrace$ may not be appropriately padded.</p>
<p>For example, let $y_1 &#x3D; 1$ and we encode it as $01{$}0^\omega$. If we guess $x&#x3D;4$, then two digits of <em>integer part</em> is not enough. The encoding must be “padded” so to synchronize “may be” accepted by $\mathcal{A_{\varphi}}$:</p>
<p>$$\begin{bmatrix}x\newline y_1\end{bmatrix}&#x3D;\begin{bmatrix}0\newline 0\end{bmatrix}<br>\begin{bmatrix}1\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\end{bmatrix}<br>\begin{bmatrix}0\newline 1\end{bmatrix}\begin{bmatrix}{$}\newline{$}\end{bmatrix}\left(\begin{bmatrix}0\newline 0\end{bmatrix}\right)^\omega$$</p>
<p>Therefore, when we convert from $c_y$ to $(c_x, c_y)$, We have to repeat the first letter $c_{y,n}$ as padding:</p>
<p>$$(a_{x,n+j}, a_{y,n})(a_{x,n+j−1}, a_{y,n})\dots(a_{x,n}, a_{y,n}).$$</p>
<p>Since $c_{y,n}$ is simply repeating, creating transition for each letter of $a_x$ unnecessarily enlarge the size of the automaton. Instead, we can make one initial transition that encapsulate the full padding of the first letter of $c_y$.</p>
<p>$$(q,(c_{x,1},c_{y_1},\dots,c_{y_k})\dots(c_{x,n},c_{y_1},\dots,c_{y_k}),q’)\in T’$$</p>
<blockquote>
<p>$\textbf{Construction 8.2. } \text{Let }x,y_1,\dots, y_k\text{ be free variables in the linear arithmetic formula }\varphi,\text{ and}$</p>
<p>$$\mathcal{A_\varphi}&#x3D;(\lbrace 0, 1\rbrace^{k+1}\cup\lbrace{$}\rbrace^{k+1},Q,I,T,\small\text{BÜCHI}\normalsize (F))$$</p>
<p>$\text{be a Büchi Automaton such that }\mathcal{L(A)}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models\varphi\rbrace.\text{ We construct a Büchi Automaton}$</p>
<p>$$\mathcal{A_{\exists x.\varphi}}&#x3D;(\lbrace 0, 1\rbrace^{k}\cup\lbrace{$}\rbrace^{k},Q\cup\textsf{Inits},\textsf{Inits},T’,\small\text{BÜCHI}\normalsize (F))$$</p>
<p>$\text{such that }\mathcal{L(A_{\exists x.\varphi})}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models\exists x.\varphi\rbrace\text{ as follows.}$</p>
<p>$\begin{array}{l}<br>\hspace{1cm} \cdot \ \textsf{Inits}&#x3D;\lbrace(q,\star)\mid q\in I\rbrace\newline<br>\hspace{1cm} \cdot \ (q,(c_{y_1},\dots,c_{y_k}),q’)\in T’\text{ if and only if there exists }c_x\text{ such that }(q,(c_x,c_{y_1},\dots,c_{y_k}),q’)\in T’\newline<br>\hspace{1cm} \cdot \ ((q,\star),(c_{y_1},\dots,c_{y_k}),q’)\in T’\text{ if and only if there exists a word }c_{x,1}\dots c_{x,n}\in\lbrace0,1\rbrace^{+}\newline<br>\hspace{1cm} \  \text{ such that }(q,(c_{x,1},c_{y_1},\dots,c_{y_k})\dots(c_{x,n},c_{y_1},\dots,c_{y_k}),q’)\in T’\end{array}$</p>
</blockquote>
<p>Two remarks are in order:</p>
<ol>
<li><p>We extended the transition relation $T$ to $Q\times\Sigma^+\times Q$: if $(q,u,q’)\in T$ and $(q’,v,q’’)\in T$, then $(q,uv,q’’)\in T$ (where $\Sigma^+ &#x3D; \Sigma\Sigma^\ast$).</p>
</li>
<li><p>The transitions from the freshly added initial states can be readily determined, via, for example, a depth-first search by considering an appropriate subgraph induced by the automaton $\mathcal{A_\varphi}$.</p>
</li>
</ol>
<p>This concludes the final inductive case, and, hence, the proof of Theorem 8.1.</p>
<hr>
<p>Next chapter: <a href="../agv9-1/">Automata-based LTL Model Checking with Sequential Circuits</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-06T04:42:27.000Z" title="06/12/2024, 05:42:27">2024-12-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1016 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-4/">AGV 8.4 -- Homogenous Inequality Testing is Automatic</a></p><div class="content"><p>Previous chapter: <a href="../agv8-3/">Translation from Linear Arithmetic to Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the previous <a href="../agv8-3/">section</a>, we used $x+y&#x3D;z$ as an example. By extend that into a more general inequality</p>
<p>$$g_1x_1+\dots+g_\ell x_\ell\leq h_1y_1+\dots +h_my_m$$</p>
<p>where $x_1,\dots,x_\ell,y_1,\dots,y_m$ are <strong>free variables</strong>, and $g_1,\dots,g_\ell,h_1,\dots,h_m$ are <strong>positive integer constants</strong>. Such inequality can be described by a Büchi automaton.</p>
<blockquote>
<p>$\textbf{Lemma 8.1. }\textit{Let }\lbrace x_1,\dots,x_\ell,y_1,\dots,y_m\textit{ be a set of free variables, and let }g_1,\dots,g_\ell,h_1,\dots,h_m\newline\textit{be positive integer constants. There exists a Büchi automaton }\mathcal{A}\textit{ such that}$</p>
<p>$$\mathcal{L(A)}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models g_1x_1+\dots+g_\ell g_\ell\leq h_1 y_1+\dots+h_m y_m\rbrace$$</p>
</blockquote>
<p>It is easy to start with constructing an automaton $\mathcal{A}_{\textsf{valid},\ell+m}$ that checks whether the word $\alpha_\sigma$ is <em>well-formed</em>:</p>
<ol>
<li>checks that the separation symbol $({$},\dots,{$})$ occurs <strong>exactly once</strong>, and</li>
<li>the separation symbol does <strong>not</strong> appear at <strong>the beginning of the word</strong>.</li>
</ol>
<h3 id="A-Generalize-Example"><a href="#A-Generalize-Example" class="headerlink" title="A Generalize Example"></a>A Generalize Example</h3><ul>
<li><p>$D:\sum_{i}g_ix_i-\sum_{j}h_jy_j\leq0$, where $G&#x3D;\sum_{i}g_i$, and $H&#x3D;\sum_{j}h_j$. We define the  </p>
</li>
<li><p>$D_t$ &#x3D; <code>integer part</code>, $[D]_t$ &#x3D; <code>fractional part</code>, and observe that for all $t$:</p>
</li>
</ul>
<p>$$D_1&#x3D;-\sum_{i}g_ic_{x_{i},1}-(-\sum_{j}h_jc_{y_{j},1})&#x3D;\sum_{j}h_jc_{y_{j},1}-\sum_{i}g_ic_{x_{i},1},\newline D_{t+1}&#x3D;2D_t+\sum_{i}g_ic_{x_{i},t+1}-\sum_{j}h_jc_{y_{j},t+1},\newline -H\leq[D]_t\leq G.$$</p>
<p>The trichotomy is also completely analogous.</p>
<ul>
<li>If, for some $t$, we have $D_t&gt;H$, we have that $D&gt;0$, and the formula is violated.</li>
<li>If, for some $t$, we have $D_t&lt;−G$, we have that $D&lt;0$, and the formula is satisfied.</li>
<li>If, for all $t$, we have $−G\leq D_t\leq H$ we have that $D&#x3D;0$, and the formula is satisfied.</li>
</ul>
<p>Our automaton construction keeps track of $D_t$ using the recurrence above. Due to the trichotomy, we only need compute $D_t$ precisely as long as it is <strong>at least $−G$ and at most $H$</strong>.</p>
<p>Thus, we have 3 types of states in the automaton:</p>
<ol>
<li><em>initialization</em> state</li>
<li>Precise value states within $−G,\dots,0,\dots,H$ of $D_t$</li>
<li>trap states ($D_t$ has crossed $−G (−\infty)$ or $H (\infty)$)</li>
</ol>
<blockquote>
<p>$\textbf{Construction 8.1. } \text{Let }x_1,\dots,x_\ell,y_1,\dots,y_m\text{ be free variables, and let }g_1,\dots,g_\ell,\text{ and}\newline h_1,\dots,h_m,\text{ be positive integer constants with }\sum_{i}g_i&#x3D;G\text{ and }\sum_{j}h_j&#x3D;H\text{. We construct a}\newline\text{(deterministic) Büchi Automaton}\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize (F))\text{, such that}$</p>
<p>$$\mathcal{L(A)}&#x3D;\lbrace\alpha_\sigma\mid\sigma\models g_1x_1+\dots+g_\ell g_\ell\leq h_1 y_1+\dots+h_m y_m\rbrace \hspace{1cm}\text{ as follows,}$$</p>
<p>$\begin{array}{l}\hspace{1cm} \cdot \ \Sigma&#x3D;\lbrace {$}^{l+m}\cup(\lbrace0,1\rbrace^\ell\times\lbrace0,1\rbrace^m)\rbrace\hspace{1cm}((\ell\text{+m)-fold Cartesian product)}\newline<br>\hspace{1cm} \cdot \ Q&#x3D;\lbrace\textsf{init},-\infty,-G,-G+1,\dots,-1,0,1,\dots,H,\infty\rbrace\newline<br>\hspace{1cm} \cdot \ I&#x3D;\lbrace\textsf{init}\rbrace\newline<br>\hspace{1cm} \cdot \ F&#x3D;\lbrace-\infty,-G,-G+1,\dots,-1,0,1,\dots,H\rbrace\newline<br>\hspace{1cm} \cdot \ T\text{ is defined as follows:}\newline<br>\hspace{1.5cm} 1. \ (\textsf{init},(c_{x_1},\dots,c_{y_m}),q’))\in T\text{ if and only if }q’\in\sum_{j}h_jc_{y_j}-\sum_{i}g_ic_{x_i}\newline<br>\hspace{1.5cm} 2. \ (q,({$}\dots{$}),q)\in T\text{ for all }q\in Q\setminus\lbrace\textsf{init}\rbrace,\newline<br>\hspace{1.5cm} 3. \ (q_\infty,c,q_\infty)\in T\text{ for all }c\in\Sigma,q_\infty\in\lbrace-\infty,\infty\rbrace,\newline<br>\hspace{1.5cm} 4. \ \text{For }q\in\lbrace-G,\dots,0,\dots,H\rbrace,(q,(c_{x_1},\dots,c_{y_m}),q’)\in T\text{ if and only if }q’&#x3D;\textsf{next}\text{, where}\newline<br>\end{array}$<br>$$\textsf{next}&#x3D;\left\lbrace\begin{array}{cll}<br>2q+\sum_{i}g_ic_{x_{i}}-\sum_{j}h_jc_{y_{j}}&amp;\text{if}&amp;-G\leq2q+\sum_{i}g_ic_{x_{i}}-\sum_{j}h_jc_{y_{j}}\leq H \newline<br>\infty&amp;\text{if}&amp;2q+\sum_{i}g_ic_{x_{i}}-\sum_{j}h_jc_{y_{j}}&gt; H \newline<br>-\infty&amp;\text{if}&amp;2q+\sum_{i}g_ic_{x_{i}}-\sum_{j}h_jc_{y_{j}} &lt;-G \end{array}\right.$$</p>
</blockquote>
<h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>All possible transitions are those the criterion we mentioned above (according to the numbering):</p>
<ol>
<li>$D_1&#x3D;\sum_{j}h_jc_{y_{j},1}-\sum_{i}g_ic_{x_{i},1}$</li>
<li>The separation symbol does <strong>not</strong> appear at <strong>the beginning of the word</strong>.</li>
<li>$D_t$ has crossed $−G (−\infty)$ or $H (\infty)$ move to <em>trap states</em> and cannot leave</li>
<li>According to the trichotomy, we only need compute $D_t$ precisely as long as it is $−G\leq D_t\leq H$.</li>
</ol>
<p>This completes the proof of Lemma 8.1. We remark that the same construction also works to check the following:</p>
<ul>
<li><strong>Strict Inequality:</strong> $g_1x_1+\dots+g_\ell x_\ell &lt; h_1y_1+\dots +h_my_m$ (by setting $F&#x3D;\lbrace−\infty\rbrace$),</li>
<li><strong>Equality:</strong> $g_1x_1+\dots+g_\ell x_\ell &#x3D; h_1y_1+\dots +h_my_m$ (by setting $F&#x3D;\lbrace−G,\dots,H\rbrace$),</li>
<li><strong>Reverse Inequality:</strong> $g_1x_1+\dots+g_\ell x_\ell \geq h_1y_1+\dots +h_my_m$ (by setting $F&#x3D;\lbrace−G,\dots,H,\infty\rbrace$),</li>
<li><strong>Reverse Strict Inequality:</strong> $g_1x_1+\dots+g_\ell x_\ell &gt; h_1y_1+\dots +h_my_m$ (by setting $\infty\rbrace$).</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv8-5/">From Linear Arithmetic to Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-05T02:53:30.000Z" title="05/12/2024, 03:53:30">2024-12-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1170 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-3/">AGV 8.3 -- Translation from Linear Arithmetic to Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv8-2/">Encoding real numbers</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>In this section, we will illustrate the key ideas in the translation from <strong>linear arithmetic</strong> to <strong>automata</strong> through a simple example.</p>
<p>Consider the formula $x+y&#x3D;z$ and the following encoding of the valuation $x\mapsto1$, $y\mapsto1$, $z\mapsto2$:</p>
<p>$$\alpha_\sigma&#x3D;\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}{$}\newline {$}\newline {$}\end{bmatrix}\left(\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\right)^\omega &#x3D; \begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D; \begin{bmatrix}1\newline 1\newline 2\end{bmatrix}$$</p>
<h3 id="Homogeneity"><a href="#Homogeneity" class="headerlink" title="Homogeneity"></a>Homogeneity</h3><p>A equation is <em>homogenous</em> if there are <strong>no constant terms</strong>. The key property of <strong>homogeneity</strong> is that we can simply scaling without being <strong>unbounded</strong>. In other words, for a <em>homogenous</em> equation $D$, we have:</p>
<blockquote>
<p>$D∼0$ (where $∼$ is an arbitrary (in)equality) <strong>if and only if</strong>, for all $k\in\mathbb{Z},2^k\cdot D∼0$. (Scaling behaviour)</p>
</blockquote>
<p>As we can see the equation $x+y&#x3D;z$ is <em>homogenous</em>, i.e., $D: x+y−z &#x3D; 0$ and $2^k\cdot x+2^k\cdot y−2^k\cdot z∼0$</p>
<p>We immediately observe that:</p>
<ul>
<li>$2^k\cdot D$ has <strong>constant sign</strong>,</li>
<li>If $D\neq0$, it is <strong>strictly increasing</strong> in $k$, and thus</li>
<li>For any threshold $N$, we will have that $|2^k\cdot D|&gt;N$ for all sufficiently large $k$.</li>
</ul>
<h3 id="Shifting-the-Delimiter"><a href="#Shifting-the-Delimiter" class="headerlink" title="Shifting the ${$}$ Delimiter"></a>Shifting the ${$}$ Delimiter</h3><p>The key observation is that multiplying by a power of $2$ &#x3D; shifting the ${$}$ delimiter in the binary representation.</p>
<p>$$\begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D;<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}{$}\newline{$}\newline{$}\end{bmatrix}<br>\left(\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\right)^\omega&#x3D;<br>\begin{bmatrix}1\newline 1\newline 2\end{bmatrix},\newline<br>\begin{bmatrix}2^2\cdot x\newline 2^2\cdot y\newline 2^2\cdot z\end{bmatrix} &#x3D;<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\begin{bmatrix}{$}\newline{$}\newline{$}\end{bmatrix}<br>\left(\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\right)^\omega&#x3D;<br>\begin{bmatrix}2^2\cdot 1\newline 2^2\cdot 1\newline 2^2\cdot 2\end{bmatrix}&#x3D;<br>\begin{bmatrix}4\newline 4\newline 8\end{bmatrix},<br>$$</p>
<p>For any variable $z$, and $t\geq1$, we denote by $z_t$ the integer encoded by the leftmost $t$ digits of $z$ (the ${$}$ is ignored):</p>
<p>$$\begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D;<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\dots$$</p>
<p>$<br>\begin{array}{lclc}<br>\hspace{1cm}\cdot\ x_5 &#x3D;&amp; -2^4\cdot0+2^3\cdot0+2^2\cdot0+2^1\cdot1+2^0\cdot1&amp;&#x3D;&amp;3\newline<br>\hspace{1cm}\cdot\ y_3 &#x3D;&amp; -2^2\cdot0+2^1\cdot0+2^0\cdot0&amp;&#x3D;&amp;0\newline<br>\hspace{1cm}\cdot\ z_4 &#x3D;&amp; -2^3\cdot0+2^2\cdot1+2^1\cdot0+2^1\cdot0&amp;&#x3D;&amp;4\newline<br>\hspace{1cm}\cdot\ z_5 &#x3D;&amp; -2^4\cdot0+2^3\cdot1+2^1\cdot0+2^2\cdot0+2^0\cdot0&amp;&#x3D;&amp;8\newline<br>\end{array}<br>$</p>
<h3 id="key-linear-recurrence"><a href="#key-linear-recurrence" class="headerlink" title="key linear recurrence"></a>key linear recurrence</h3><p>We can see the above definition is initialized as $z_1&#x3D;−c_{z,1}$, and <strong>key linear recurrence</strong> holds for any variable: $z_{t+1}&#x3D;2z_t+c_{z,t+1}$, where $c_{z,t+1}$ is the $(t+1)$-th digit from the left in the encoding of $z$.</p>
<p>Now, in our example we can define $D_t&#x3D;x_t+y_t−z_t$, and by <strong>linearity</strong>, the same recurrences hold for $D_t$, too:</p>
<p>$$D_1&#x3D;c_{z,1}-c_{x,1}-c_{y,1}\newline D_{t+1}&#x3D;2D_t+c_{z,t}-c_{x,t}-c_{y,t}$$</p>
<p>Thus, we have $D_1&#x3D;0,D_2&#x3D;−1,D_3&#x3D;−2$, and $D_t&#x3D;−2$ for subsequent $t$.</p>
<h3 id="Fractional-part"><a href="#Fractional-part" class="headerlink" title="Fractional part"></a>Fractional part</h3><p>To account for the digits other than the $t$ leftmost digits, we define the fractional part $\lbrack z\rbrack_t &#x3D; \sum_{i&#x3D;1}^{\infty}2^{-i}\cdot c_{z,t+i}$.</p>
<p>$$\begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D;<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\dots$$</p>
<p>$<br>\begin{array}{lclc}<br>\hspace{1cm}\cdot\ [x]_1 &#x3D;&amp; 2^{-1}\cdot0+2^{-2}\cdot0+2^{-3}\cdot1+2^{-4}\cdot1+\dots&amp;&#x3D;&amp;{1\over4}\newline<br>\hspace{1cm}\cdot\ [y]_2 &#x3D;&amp; 2^{-1}\cdot0+2^{-2}\cdot1+2^{-3}\cdot1+2^{-4}\cdot1+\dots&amp;&#x3D;&amp;{1\over2}\newline<br>\hspace{1cm}\cdot\ [z]_1 &#x3D;&amp; 2^{-1}\cdot1+2^{-2}\cdot0+2^{-3}\cdot0+\dots&amp;&#x3D;&amp;{1\over2}\newline<br>\hspace{1cm}\cdot\ [z]_3 &#x3D;&amp; 2^{-1}\cdot0+2^{-2}\cdot0+2^{-3}\cdot0+\dots&amp;&#x3D;&amp;0\newline<br>\end{array}<br>$</p>
<p>Here, we can see $0\leq[z]_t\leq1$, and that $z_t+[z]_t &#x3D; 2^k\cdot z$ for some $k\in\mathbb{Z}$.</p>
<blockquote>
<p>If the $2^k\cdot z$ doesn’t seem intuitive to you, check this out:<br>let say we have $z&#x3D;011{$}0111\dots &#x3D; 3+{1\over2}&#x3D;3.5$, and we set $t&#x3D;7$, so $z_7&#x3D;-2^6\cdot0+2^5\cdot1+2^4\cdot1+2^3\cdot0+2^2\cdot1+2^1\cdot1+2^0\cdot1&#x3D;55$ and $[z]_7&#x3D;{1\over2}+{1\over4}+{1\over8}+\cdots&#x3D;1$. Thus we have $z_7+[z]_7 &#x3D; 56 &#x3D; 2^4\cdot 3.5$.</p>
</blockquote>
<p>We can then extend the definition of fractional part to $D$ in the obvious way: $[D]_t &#x3D; [x]_t+[y]_t−[z]_t$.<br>We thus have that $−1\leq [D]_t\leq 2$, and that $D_t+[D]_t&#x3D;2^k\cdot D$ for some $k$.</p>
<ol>
<li><p>If $D_t&lt;−2$ for some $t$. then $D_t+[D]_t&lt;0$. For the corresponding $k$, we have that $2^k \cdot D&lt;0$. Therefore $x+y-z&lt;0$ and thus we conclude $x+y&lt;z$.</p>
</li>
<li><p>If $D_t&gt;1$ for some $t$, then $D_t+[D]_t&gt;0$. For the corresponding $k$, we have that $2^k \cdot D&gt;0$. Therefore $x+y-z&gt;0$ and thus we conclude $x+y&gt;z$.</p>
</li>
<li><p>If $−2\leq D_t\leq 1$ for all $t$, then $|D_t+[D]_t|\leq 3$. For arbitrarily large $k$, $|2^k\cdot D|\leq3$. This implies that $x+y&#x3D;z$ (only option left)</p>
</li>
</ol>
<h3 id="From-Linear-Arithmetic-to-Automaton"><a href="#From-Linear-Arithmetic-to-Automaton" class="headerlink" title="From Linear Arithmetic to Automaton"></a>From Linear Arithmetic to Automaton</h3><p>From the above deduction, $x+y&#x3D;z$ holds if and only if $−2\leq D_t\leq 1$. To check whether it holds with an automaton, we use the encoding to compute the sequence $D_t$ <em>term by term</em>, and <strong>accept</strong> if and only if each term is at least $−2$ and at most $1$.</p>
<p>Indeed, in our example, the sequence of terms is $0,−1,−2,−2,\dots$, and we accept.</p>
<p>As an example, we could also consider a different encoding of $x\mapsto1$, $y\mapsto1$, $z\mapsto2$:</p>
<p>$$\alpha’_\sigma&#x3D;\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\begin{bmatrix}1\newline 1\newline 1\end{bmatrix}<br>\begin{bmatrix}{$}\newline {$}\newline {$}\end{bmatrix}\left(\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}\right)^\omega &#x3D; \begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D; \begin{bmatrix}1\newline 1\newline 2\end{bmatrix}$$</p>
<p>In this example the sequence of $D_t$ is $0, 1, 1, 1,\dots$, which is again bounded, and we accept.</p>
<p>On the other hand, a rejecting example may look like this:</p>
<p>$$\alpha_{\sigma’}&#x3D;\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}{$}\newline {$}\newline {$}\end{bmatrix}\left(\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\right)^\omega &#x3D; \begin{bmatrix}x\newline y\newline z\end{bmatrix} &#x3D; \begin{bmatrix}1\newline 1\newline -2\end{bmatrix}$$</p>
<p>The sequence of $D_t$ is $1, 4, 8, 15,\dots$, which is out of bounded, and we reject.</p>
<hr>
<p>Next chapter: <a href="../agv8-4/">Homogenous Inequality Testing is Automatic</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-04T17:14:15.000Z" title="04/12/2024, 18:14:15">2024-12-04</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.419Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">4 minutes read (About 589 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-2/">AGV 8.2 -- Encoding Real Numbers</a></p><div class="content"><p>Previous chapter: <a href="../agv8-1/">Linear Arithmetic (Theory)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In last section, we have seen the definiton of Linera Arithmetic, which is similar to S1S. Let see how we can apply it in math and moreover, the connection between logic and automata.</p>
<h2 id="Encoding-Real-Numbers"><a href="#Encoding-Real-Numbers" class="headerlink" title="Encoding Real Numbers"></a>Encoding Real Numbers</h2><p>We can encode any real number $x\in\mathbb{R}$ into the form $(0+1)(0+1)^\ast{$}(0+1)^\omega$ in two steps:</p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>For a <em>real number</em> $x\in\mathbb{R}$, represent it as a pair $(x_I,x_F)$ so that $x&#x3D;x_I+x_F$.<br><strong>integer part</strong> &#x3D; $x_I\in\mathbb{Z}$, and <strong>fractional part</strong> &#x3D; $x_F\in[0, 1]$, a <em>real number</em> between $0$ and $1$ (both inclusive)</p>
<p>For example, the $1.5 &#x3D; (1, 0.5)$, and $-{2\over 3}&#x3D;(−1, {1\over3})$. Note that <strong>integers</strong> always have two different representations depends on setting the <strong>fractional part</strong> as $0$ or $1$, and <strong>Negative sign</strong> can only be represented using the integer part. For example $3&#x3D;(2,1)$ or $(3,0)$</p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>Then we can further encode $(x_I,x_F)$ as an <strong>infinite word</strong> $w_I{$}\beta_F$,<br>$x_I$ is encoded as $w_I&#x3D;a_na_{n−1}\dots a_0\in\lbrace 0,1\rbrace^\ast$, a <strong>finite nonempty word</strong>, and<br>$x_F$ is encoded as $\beta_F&#x3D;b_1b_2\dots\in\lbrace 0,1\rbrace^\omega$, an <strong>infinite word</strong> such that</p>
<p>$$x_I&#x3D;-a_n\cdot 2^n+  \sum_{i&#x3D;0}^{n-1}a_i\cdot 2^i<br>\hspace{2cm}\text{and}\hspace{2cm}<br>x_F&#x3D; \sum_{i&#x3D;1}^{\infty}b_i\cdot 2^{-i}$$</p>
<p>Note that now every pair has (infinitely) many different encodings because <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=CHbZvyvbu8I&ab_channel=Matt_Parker_2">digits are forever</a>:<br>for example, $(0,{1\over2})$ is encoded by all words in $0^\ast0{$}10^\omega &#x3D; {1\over2}+0+0+\dots$ and $0^\ast0{$}01^\omega&#x3D;0+{1\over4}+{1\over8}+\dots$.</p>
<p>As you may notice, we can always increase the length of the <strong>finite integer part</strong> by ‘padding’ arbitrary finitely long $0$ and $1$ on positive and negative number respectively. This is becasue of the following property of the <strong>geometric-series sum</strong>: for all $a$, $n$, $k$, we have that:</p>
<p>$$-a_n\cdot 2^n&#x3D;-a\cdot 2^{n+k}+  \sum_{j&#x3D;0}^{k}a\cdot 2^{n+j}$$</p>
<p>For example, $110{$}0^\omega&#x3D;-1\ast2^2+1\ast2^1&#x3D;-2$, $11110{$}0^\omega&#x3D;-1\ast2^4+1\ast2^3+1\ast2^2+1\ast2^1&#x3D;-2$,</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><table>
<thead>
<tr>
<th align="left">$x\in\mathbb{R}$</th>
<th align="left">$(x_I,x_F)$</th>
<th align="left">$w_I{$}\beta_F$</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$1$</td>
<td align="left">$(1, 0)$</td>
<td align="left">$0^\ast01{$}0^\omega$ and $0^\ast0{$}1^\omega$</td>
</tr>
<tr>
<td align="left">${4\over 3}$</td>
<td align="left">$(1, {1\over 3})$</td>
<td align="left">$0^\ast01{$}(01)^\omega$</td>
</tr>
<tr>
<td align="left">$-{3\over 2}$</td>
<td align="left">$(-2, {1\over 2})$</td>
<td align="left">$1^\ast10{$}10^\omega$</td>
</tr>
</tbody></table>
<p>$0^\ast&#x2F;1^\ast$ may be empty so make sure there is at least one $0$ or $1$ to ensure it is positive or negative, respectively.</p>
<h2 id="Encoding-Valuations-sigma-V’-rightarrow-mathbb-R"><a href="#Encoding-Valuations-sigma-V’-rightarrow-mathbb-R" class="headerlink" title="Encoding Valuations $\sigma:V’\rightarrow\mathbb{R}$"></a>Encoding Valuations $\sigma:V’\rightarrow\mathbb{R}$</h2><p>Assume there’s an arbitrary ordering of the <em>free</em> variables $V’&#x3D;\lbrace x_0,x_1,\dots,x_k\rbrace$. The valuation is then encoded as a word $\alpha_\sigma$ over the alphabet $\lbrace0,1\rbrace^k\cup\lbrace{$}\rbrace^k$. Each letter of the word $\alpha_\sigma$ is a tuple, where the $i$-th position indicates the encoding of $x_i$. Also, we ensure that the encodings of all $x_i$ synchronize on the separation symbol ${$}$</p>
<p>Continue the example, one possible encoding of the valuation $x_1\mapsto1$, $x_2\mapsto{4\over3}$, $x_3\mapsto-{3\over2}$ is the infinite word</p>
<p>$$\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}<br>\begin{bmatrix}1\newline 1\newline 0\end{bmatrix}\begin{bmatrix}{$}\newline {$}\newline {$}\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 1\end{bmatrix}\left(\begin{bmatrix}0\newline 1\newline 0\end{bmatrix}<br>\begin{bmatrix}0\newline 0\newline 0\end{bmatrix}\right)^\omega$$</p>
<p>In the next section, we will illustrate an example of translation from linear arithmetic to automata.</p>
<hr>
<p>Next chapter: <a href="../agv8-3/">Translation from Linear Arithmetic to Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-03T04:33:32.000Z" title="03/12/2024, 05:33:32">2024-12-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.420Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 481 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv8-1/">AGV 8.1 -- Linear Arithmetic (Theory)</a></p><div class="content"><p>Previous chapter: <a href="../agv7-3/">Translating Alternating to Nondeterministic automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the previous sections, we have seen that the automata machinery can be applied to logical problems by translating formulas into automata. We now study another application of the powerful connection between logic and automata, this time in the setting of real numbers.</p>
<h2 id="Theory-of-Linear-Arithmetic"><a href="#Theory-of-Linear-Arithmetic" class="headerlink" title="Theory of Linear Arithmetic"></a>Theory of Linear Arithmetic</h2><h3 id="Definitions-and-Semantics"><a href="#Definitions-and-Semantics" class="headerlink" title="Definitions and Semantics"></a>Definitions and Semantics</h3><p>Let $V$ be a set of <code>(first-order) variables</code>. The <strong>terms</strong> of linear arithmetic are defined by the following grammar:</p>
<p>$$t::&#x3D;0\mid1\mid x\mid t+t$$</p>
<p>The <strong>formulas</strong> of linear arithmetic are defined by the following grammar, where $x\in V$ is a variable:</p>
<p>$$\varphi::&#x3D;t\leq t\mid\neg\varphi\mid\varphi\wedge\varphi\mid\exists x.\varphi$$</p>
<p>Additionally, we allow the usual <strong>boolean connectives</strong> and introduce the following abbreviations:</p>
<p>$$\begin{array}{lrllllrll}<br>\cdot&amp;n&amp;:&#x3D;&amp;\overbrace{1+1+\dots+1}^{n\text{ times}},&amp;\hspace{2cm}&amp;\cdot&amp;nx&amp;:&#x3D;&amp;\overbrace{x+x+\dots+x}^{n\text{ times}},\newline<br>\cdot&amp;t\geq t’&amp;:&#x3D;&amp;t’\leq t,&amp;\hspace{2cm}&amp;\cdot&amp;t&lt;t’&amp;:&#x3D;&amp;t\leq t’\wedge\neg(t&#x3D;t’)\newline<br>\cdot&amp;t&#x3D;t’&amp;:&#x3D;&amp;t\leq t’\wedge t\geq t’,&amp;\hspace{2cm}&amp;\cdot&amp;t&gt;t’&amp;:&#x3D;&amp;t’&lt;t<br>\end{array}$$</p>
<p>The semantics of a formula is given relative to a valuation $\sigma:V\rightarrow\mathbb{R}$ that assigns to each variable a real number. The value of a term is then defined as follows:</p>
<p>$$\begin{array}{llll}<br>\hspace{1cm}\cdot\ \lbrack 0\rbrack_{\sigma} &#x3D; 0 &amp;<br>\hspace{1cm}\cdot\ \lbrack 1\rbrack_{\sigma} &#x3D; 1 &amp;<br>\hspace{1cm}\cdot\ \lbrack x\rbrack_{\sigma} &#x3D; \sigma(x) &amp;<br>\hspace{1cm}\cdot\ \lbrack t+u\rbrack_{\sigma} &#x3D;\lbrack t\rbrack_{\sigma}+\lbrack u\rbrack_{\sigma}\end{array}$$</p>
<p>$\models$ is the smallest relation that satisfies the following:</p>
<p>$$\begin{array}{lllllllllllll}<br>\cdot&amp;\sigma\models t\leq u&amp;\text{ iff }&amp;\lbrack t\rbrack_{\sigma}\leq\lbrack u\rbrack_{\sigma}\newline<br>\cdot&amp;\sigma\models\neg\varphi&amp;\text{ iff }&amp;\sigma\neg\models\varphi\newline<br>\cdot&amp;\sigma\models\varphi_0\wedge\varphi_1&amp;\text{ iff }&amp;\sigma\models\varphi_0\text{ and }\sigma\models\varphi_1\newline<br>\cdot&amp;\sigma\models\exists x.\varphi&amp;\text{ iff }&amp;\text{there is an }a\in\mathbb{R}\ \text{ s.t. }\ \sigma’\models\varphi\ \text{ and }\ \sigma’(y)&#x3D;\left\lbrace\begin{array}{cll}\sigma(y)&amp;\text{if}&amp;y\neq x\newline a&amp;\text{if}&amp;y&#x3D;x\end{array}\right.<br>\end{array}$$</p>
<p>Let $V’\subseteq V$ be the set of <strong>free</strong> variables occurring in the formula $\varphi$. The solutions of $\varphi$ are the set of all valuations $\sigma$ of $V’$ such that $\sigma\models\varphi$.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><table>
<thead>
<tr>
<th align="left"><strong>formula</strong></th>
<th align="left"><strong>Solution Space</strong></th>
<th align="left"><strong>Explaination</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">$x−1\geq1$</td>
<td align="left">$\lbrace x\mapsto a\in\mathbb{R}\mid a\geq2\rbrace$</td>
<td align="left">$x$ can be any real number, as long as it has to be larger than 2.</td>
</tr>
<tr>
<td align="left">$\exists y.\ x−1\geq y$</td>
<td align="left">$\lbrace x\mapsto a\mid a\in\mathbb{R}\rbrace$</td>
<td align="left">For any real number $y$, we can always find an $x$ that is larger than $y$ after minus 1.</td>
</tr>
</tbody></table>
<hr>
<p>Next chapter: <a href="../agv8-2/">Encoding real numbers</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-02T03:02:13.000Z" title="02/12/2024, 04:02:13">2024-12-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.419Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">17 minutes read (About 2561 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv7-3/">AGV 7.3 -- Translating Alternating to Nondeterministic automata</a></p><div class="content"><p>Previous chapter: <a href="../agv7-2/">From LTL to Alternating Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>The translation from alternating to nondeterministic automata is based on a representation of runs as directed acyclic graphs (DAGs). The idea is similar to the DAG representation we used in the complementation construction for nondeterministic Büchi automata in <a href="../agv5-1/">Section 5</a>.</p>
<p>There the DAG was used to represent the <strong>set of all runs</strong> of the nondeterministic automaton. The complement automaton would then ”guess” the DAG level-by-level. Here, the DAG is used to represent the <strong>branches of a (single) run</strong> of the alternating automaton. The idea is illustrated in the following example.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/7_3_eg.png"></p>
<blockquote>
<p>$\textbf{Definition 7.5. } \text{ A } \textit{run DAG }\text{ of an alternating Büchi automaton }\mathcal{A}\text{ on an infinite word }\alpha\text{ is a}\newline\text{DAG }(V,E)\text{, with }V\subseteq Q\times\mathbb{N}\text{ and }(q_0,0)\in V\text{, where}$</p>
<p>$\begin{array}{ll} \hspace{0.5cm} \cdot &amp; E\subseteq \bigcup_{i\in\mathbb{N}}(Q\times\lbrace i\rbrace)\times(Q\times\lbrace i+1\rbrace) \newline \hspace{0.5cm} \cdot &amp; \forall(q,i)\in V \ . \ \exists Y\subseteq Q\text{ s.t. } \newline &amp; Y\models\delta(q,\alpha(i)),Y\times\lbrace i+1\rbrace\subseteq V\text{ and }\lbrace(q,i)\rbrace\times (Y\times\lbrace i+1\rbrace)\subseteq E.\end{array}$</p>
</blockquote>
<ul>
<li>Every vertices are expressed in (state, letter index)</li>
<li>Edges are all possible paths from current state $q$</li>
</ul>
<p>A run DAG is <strong>accepting</strong> if every infinite path has infinitely many visits to $F\times\mathbb{N}$.</p>
<p>Our construction of the nondeterministic automaton will be <strong>based on run DAGs</strong> rather than trees.<br>However, <strong>not every run tree can be represented as a DAG</strong>. This is illustrated by the following example:</p>
<h3 id="Example-cont"><a href="#Example-cont" class="headerlink" title="Example (cont.)"></a>Example (cont.)</h3><p>The following run tree cannot be represented as a DAG, because there are two nodes that are both labeled with $\mathbf{q}$ has different children (one transits to $p$ and the other to $q$). We say this tree has <strong>memory</strong>.</p>
<p><img src="/images/notes/uds/agv/7_3_bold.png"></p>
<h3 id="Similar-Nodes-and-Memoryless-Tree"><a href="#Similar-Nodes-and-Memoryless-Tree" class="headerlink" title="Similar Nodes and Memoryless Tree"></a>Similar Nodes and Memoryless Tree</h3><p>We call two nodes $x_1, x_2\in\mathcal{T}$ in a run tree $(\mathcal{T},r)$ <strong>similar</strong> if</p>
<ul>
<li>$|x_1| &#x3D; |x_2|$ (same index), and</li>
<li>$r(x_1) &#x3D; r(x_2)$ (same state).</li>
</ul>
<p>We call a run tree <strong>memoryless</strong> if the subtrees starting in <strong>similar</strong> nodes have the <strong>same labels</strong>.<br>Memoryless run trees can be represented as DAGs.</p>
<blockquote>
<p>$\textbf{Definition 7.5. } \text{ A run tree }(\mathcal{T},r)\text{ is }\textit{memoryless }\text{ if for all similar nodes }x_1\text{ and }x_2\text{ and for all}\newline y\in D^\ast\text{ we have that }(x_1\cdot y\in\mathcal{T}\text{ iff }x_2\cdot y\in\mathcal{T} )\text{ and } r(x_1\cdot y) &#x3D; r(x_2\cdot y).$</p>
</blockquote>
<p>The following theorem shows that whenever there is an accepting run tree, there is also an accepting run tree that is memoryless. Hence, we can show some word are accpeted by the automaton by showing the <strong>existence of a memoryless run tree</strong>, or, equivalently, the <strong>existence of an accepting run DAG</strong>.</p>
<blockquote>
<p>$\textbf{Theorem 7.2. } \textit{ If an alternating Büchi automaton }\mathcal{A}\textit{ accepts a word }\alpha\textit{, then there exists a}\newline\textit{memoryless accepting run of }\mathcal{A}\textit{ on }\alpha.$</p>
</blockquote>
<h2 id="Proof-of-Memoryless-Run-exists"><a href="#Proof-of-Memoryless-Run-exists" class="headerlink" title="Proof of Memoryless Run exists"></a>Proof of Memoryless Run exists</h2><p>Let $(\mathcal{T},r)$ be an accepting run tree on $\alpha$ with directions $D$. We construct a memoryless run tree $(\mathcal{T’},r’)$ by copying from $(\mathcal{T},r)$. Inuitively, we pick, whenever there are multiple occurrences of the same state in $(\mathcal{T},r)$, the occurrence where the last visit to the accepting states was the <strong>longest time ago</strong>.</p>
<h3 id="gamma-mathcal-T-rightarrow-mathbb-N-number-of-steps-since-the-last-visit-to-F"><a href="#gamma-mathcal-T-rightarrow-mathbb-N-number-of-steps-since-the-last-visit-to-F" class="headerlink" title="$\gamma:\mathcal{T}\rightarrow\mathbb{N}$: number of steps since the last visit to $F$"></a>$\gamma:\mathcal{T}\rightarrow\mathbb{N}$: number of steps since the last visit to $F$</h3><ul>
<li><p>Initiate the run tree (root) with zero steps:</p>
<ul>
<li>$\gamma(\varepsilon)&#x3D;0$</li>
</ul>
</li>
<li><p>For $n$’s children $d$, it increase one step from $n$, unless $n$ is an accepting state then it resets to zero</p>
<ul>
<li>$\gamma(n\cdot d)&#x3D;\left\lbrace\begin{array}{ll} \gamma(n)+1 &amp; \text{if }r(n)\notin F\newline 0 &amp; \text{if }r(n)\in F\end{array}\right.$</li>
</ul>
</li>
</ul>
<p>Now, we can define the tree node that the last visit to the accepting states was the <strong>longest time ago</strong> based on $\gamma$.</p>
<h3 id="Delta-Q-times-mathbb-N-rightarrow-mathcal-T-mapping-to-return-node-visit-F-longest-time-ago"><a href="#Delta-Q-times-mathbb-N-rightarrow-mathcal-T-mapping-to-return-node-visit-F-longest-time-ago" class="headerlink" title="$\Delta:Q\times\mathbb{N}\rightarrow\mathcal{T}$: mapping to return node visit $F$ longest time ago"></a>$\Delta:Q\times\mathbb{N}\rightarrow\mathcal{T}$: mapping to return node visit $F$ longest time ago</h3><p>For state $q\in Q$ and level $n\in\mathbb{N}$, it returns a tree node $y\in\mathcal{T}$ that is the leftmost and visit $F$ longest time ago:</p>
<p>$$\begin{array}{ll}\Delta(q,n)&#x3D;&amp;\text{the leftmost }y\in\mathcal{T}\text{ with }|y|&#x3D;n\ \text{ s.t. }\ r(y)&#x3D;q\newline &amp; \text{and }\forall z\in\mathcal{T}.\ |z|&#x3D;n\wedge r(z)&#x3D;q\Rightarrow\gamma(z)\leq\gamma(y)\end{array}$$</p>
<h3 id="Construction-of-Memoryless-Run-Tree-mathcal-T’-r’"><a href="#Construction-of-Memoryless-Run-Tree-mathcal-T’-r’" class="headerlink" title="Construction of Memoryless Run Tree $(\mathcal{T’},r’)$"></a>Construction of Memoryless Run Tree $(\mathcal{T’},r’)$</h3><p>We now construct $(\mathcal{T’},r’)$ by copying from the nodes in $(\mathcal{T},r)$ indicated by $\Delta$:</p>
<ul>
<li><p>Both trees have same initial states (root):</p>
<ul>
<li>$\varepsilon\in\mathcal{T’}\text{ and }r’(\varepsilon)&#x3D;r(\varepsilon)$</li>
</ul>
</li>
<li><p>Children node $d$ in $\mathcal{T’}$ are $d$ with longest steps, and of course a child of $n$:</p>
<ul>
<li>$d\in\mathcal{T’}\text{ if and only if }\Delta(r’(n),|n|)\cdot d\in\mathcal{T}\text{ and } r’(n\cdot d)&#x3D;r(\Delta(r’(n),|n|)\cdot d)$</li>
</ul>
</li>
</ul>
<h3 id="mathcal-T’-r’-is-a-run-of-mathcal-A-on-alpha"><a href="#mathcal-T’-r’-is-a-run-of-mathcal-A-on-alpha" class="headerlink" title="$(\mathcal{T’},r’)$ is a run of $\mathcal{A}$ on $\alpha$"></a>$(\mathcal{T’},r’)$ is a run of $\mathcal{A}$ on $\alpha$</h3><ul>
<li>The root is labeled by the initial state: $r’(\varepsilon)&#x3D;r(\varepsilon)&#x3D;q_0$.</li>
<li>For some node $n\in\mathcal{T’}$, let node $q_n&#x3D;\Delta(r’(n),|n|)$ ($q_n$ visits $F$ longest time ago among all $n$)</li>
<li>Then, the set $\lbrace r(q_n\cdot d)\mid d\in D, q_n\cdot d \in \mathcal{T}\rbrace$ satisfies $\delta(r(q_n), \alpha(|q_n|))$ (path of $q_n$ in original tree exists)</li>
<li>Therefore $\lbrace r’(n\cdot d)\mid d\in D, n\cdot d \in \mathcal{T’}\rbrace\models\delta(r’(n), \alpha(|n|))$ (by the construction above)</li>
</ul>
<h3 id="mathcal-T’-r’-is-accepting"><a href="#mathcal-T’-r’-is-accepting" class="headerlink" title="$(\mathcal{T’},r’)$ is accepting"></a>$(\mathcal{T’},r’)$ is accepting</h3><p>First, we show that for every $n\in\mathcal{T’}$, the node obtained from the mapping is indeed the longest path, i.e. $\gamma(n)\leq\gamma(\Delta(r’(n),|n|))$. This is shown by induction on the length of $n$:</p>
<ul>
<li><p>for $n&#x3D;\varepsilon$ we have that $\gamma(n)&#x3D;0$</p>
</li>
<li><p>for $n&#x3D;n’\cdot d$ (where $d\in D$) we have:</p>
<ul>
<li>if $r(n’)\in F$, then $\gamma(n)&#x3D;0$</li>
<li>if $r(n’)\notin F$, then</li>
</ul>
</li>
</ul>
<p>$$\begin{array}{lcl} \gamma(\Delta(r’(n’\cdot d),|n’\cdot d|))&amp;\overset{\text{Def. }\Delta}{\geq}&amp;\gamma(\Delta(r’(n’),|n’|)\cdot d)\overset{\text{Def. }\gamma}{&#x3D;}1+\gamma(\Delta(r’(n’),|n’|))\newline&amp;\overset{\text{IH}}{\geq}&amp;1+\gamma(n’)\overset{\text{Def. }\gamma}{&#x3D;}\gamma(n’\cdot d)\end{array}$$</p>
<p>(Last visit of the Mapping of children of $n’$ $\geq$ Last visit of mapping of $n$’s children. By induction hypothesis, the children of $n’$ through the mapping $\Delta$ is never smaller than any other possible children of $m’$)</p>
<p>Assume $(\mathcal{T’},r’)$ constructed from a accepting $(\mathcal{T},r)$ is not accepting. Then there is an infinite branch that does not visit $F$ infinitely often, i.e. $n_0, n_1, n_2,\dots$ in $\mathcal{T’}$ and $\exists k\in\mathbb{N}$ such that $\forall j\geq k. r’(n_j)\notin F$.</p>
<p>Let $m_i&#x3D;\Delta(r’(n_i), |n_i|)\text{ for }i\geq k$. We have,</p>
<p>$$<br>\begin{array}{ccccc} \gamma(n_k)&amp;&lt;&amp;\gamma(n_{k+1})&amp;&lt;&amp;\dots\newline &#x2F;\mathord{\bigwedge} &amp;&amp; &#x2F;\mathord{\bigwedge}<br>\newline\gamma(m_k)&amp;&lt;&amp;\gamma(m_{k+1})&amp;&lt;&amp;\dots\end{array}<br>$$</p>
<p>So, for any $j\geq k$ it holds that $\gamma(m_j)\geq j−k$ (because there are at least $j-k$ steps without visiting $F$). Since $\mathcal{T}$ is finitely branching, there must be a branch with an infinite suffix of non-$F$ labeled positions. So we can always find the branch in $\mathcal{T}$ identical with the path with $m_i$ This contradicts the assumption $(\mathcal{T},r)$ is accepting.</p>
<blockquote>
<p>$\textbf{Corollary 7.1. }\textit{A word }\alpha\textit{ is accepted by an alternating Büchi automaton }\mathcal{A}\textit{ if and only if}\newline\mathcal{A}\textit{ has an accepting run DAG on }\alpha$</p>
</blockquote>
<h2 id="Translating-alternating-to-nondeterministic-automata"><a href="#Translating-alternating-to-nondeterministic-automata" class="headerlink" title="Translating alternating to nondeterministic automata"></a>Translating alternating to nondeterministic automata</h2><p>We are now ready to translate an alternating Büchi automaton into an equivalent nondeterministic Büchi automaton. The construction is due to Miyano and Hayashi (1984).</p>
<blockquote>
<p>$\textbf{Construction 7.2. }\text{For an alternating Büchi automaton }\mathcal{A}&#x3D;(\Sigma,Q,q_0,\delta,\small\text{BÜCHI} \normalsize(F))\text{, we}\newline\text{construct a nondeterministic Büchi automaton }\mathcal{A’}&#x3D;(\Sigma,Q’,I’,T’,\small\text{BÜCHI} \normalsize(F’))\text{ with }\mathcal{L(A)}&#x3D;\newline\mathcal{L(A’)}\text{ as follows:}$</p>
<p>$\begin{array}{ll}<br>\hspace{0.5cm} \cdot \ Q’&amp;&#x3D; 2^Q\times2^Q \newline<br>\hspace{0.5cm} \cdot \ I’&amp;&#x3D; \lbrace(\lbrace q_0\rbrace,\varnothing)\rbrace\newline<br>\hspace{0.5cm} \cdot \ T’&amp;&#x3D; \lbrace((X,\varnothing),\sigma,(X’,X’\setminus F))\mid X’\models\wedge_{q\in X}\delta(q,\sigma)\rbrace\ \cup\newline<br> &amp;\hspace{0.5cm} \lbrace((X,W),\sigma,(X’,W’\setminus F))\mid W\neq\varnothing,W’\subseteq X’, X’\models\wedge_{q\in X}\delta(q,\sigma),W’\models\wedge_{q\in W}\delta(q,\sigma)\rbrace\newline<br>\hspace{0.5cm} \cdot \ F’&amp;&#x3D; \lbrace(X,\varnothing)\mid X\subseteq Q\rbrace<br>\end{array}$</p>
</blockquote>
<h3 id="Modified-Example-from-section-7-1"><a href="#Modified-Example-from-section-7-1" class="headerlink" title="Modified Example from section 7.1"></a>Modified Example from section 7.1</h3><p><img src="/images/notes/uds/agv/7_3_alt.png"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Example</th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$Q’$</td>
<td align="left">$X&#x3D;\lbrace\lbrace p\rbrace,\lbrace q\rbrace,\lbrace p,q\rbrace\rbrace$ </br>$W &#x3D; \lbrace\varnothing,\lbrace q\rbrace\rbrace$</td>
<td align="left">States Q’ is a tuple consist of two <strong>set of states</strong> in $Q$, first one must be non-empty and the second one does not contain any states $q\in F$</td>
</tr>
<tr>
<td align="left">$I’$</td>
<td align="left">$I’&#x3D;(\lbrace p\rbrace,\varnothing)$</td>
<td align="left">1st element is the initial state while the second element is empty</td>
</tr>
<tr>
<td align="left">$T’$</td>
<td align="left">$(\lbrace p\rbrace,\varnothing)\overset{b}{\longrightarrow}(\lbrace p,q\rbrace,$ $\lbrace \lbrace p,q\rbrace\setminus\lbrace p\rbrace\rbrace)&#x3D;(\lbrace p,q\rbrace,\lbrace q\rbrace)$</td>
<td align="left">$X$ represent the behaviour of the original automata, while $W$ tracks whether the original accepting states are visited after the transition.</td>
</tr>
<tr>
<td align="left">$T’$</td>
<td align="left">$(\lbrace p,q\rbrace,\lbrace q\rbrace) \overset{b}{\longrightarrow}(\lbrace p,q\rbrace,\varnothing)$ $(\delta(p,b)&#x3D;p\wedge q,\delta(q,b)&#x3D;\textit{true}&#x3D;\varnothing$ $\therefore\delta(p\wedge q,b)&#x3D;p\wedge q.)$</td>
<td align="left">If $W$ is empty, it means accepting states is reached and next transition we start again on tracking. If $W$ is non-empty, then its behaviour align with $X$</td>
</tr>
<tr>
<td align="left">$F’$</td>
<td align="left">$F’&#x3D;\lbrace(\lbrace p\rbrace,\varnothing), (\lbrace p,q\rbrace,\varnothing)\rbrace$</td>
<td align="left">The run&#x2F;word is aceepting if $W$ is empty infinite often.</td>
</tr>
</tbody></table>
<blockquote>
<p>$\textbf{Theorem 7.3. } \text{(Miyano and Hayashi, 1984). }\textit{For every alternating Büchi automaton }\mathcal{A}\textit{, we can}\newline\textit{effectively construct a nondeterministic Büchi automaton }\mathcal{A’}\textit{ with }\mathcal{L(A)}&#x3D;\mathcal{L(A’)}.$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><blockquote>
<p>$\mathcal{L(A)}\supseteq\mathcal{L(A’)}$ (all word accepted by $\mathcal{L(A’)}$ must also be accepted by $\mathcal{L(A)}$):</p>
</blockquote>
<p>Let $\alpha\in\mathcal{L(A’)}$ with an accepting run $r’&#x3D;(X_0,W_0)(X_1,W_1)(X_2,W_2)\dots$<br>where $W_0 &#x3D;\varnothing$ and $X_0&#x3D;\lbrace q_0\rbrace$. We construct the run DAG $(V,E)$ for $\mathcal{A}$ on $\alpha$:</p>
<ul>
<li><p>All vertices in DAG in level $i$ come from the tree in level $i$:</p>
<ul>
<li>$V&#x3D;\lbrace (x,i)\mid i\in\mathbb{N}, x\in X_i\rbrace$</li>
</ul>
</li>
<li><p>$X_i$ represent the behaviour of the automaton and $W_i$ is for tracking whether the states are accepting.<br> If the state is not tracked by $W_i$, i.e. $(x\in X_i \setminus W_i)$, that means it is accepted, no extra tracking is needed,<br> If it is tracked, i.e. $(x\in W_i)$, it either moves to some accepting state or it is continue tracked $(F\cup W_{i+1})$:</p>
<ul>
<li>$E&#x3D;\lbrace((x,i),(x’,i+1))\mid i\in\mathbb{N}, x\in X_i \setminus W_i, x’\in X_{i+1}\rbrace\cup\newline\hspace{0.95cm}\lbrace((x, i),(x’,i+1))\mid i\in\mathbb{N}, x\in W_i, x’\in X_{i+1}\cap (F\cup W_{i+1})\rbrace$</li>
</ul>
</li>
</ul>
<p>First, we show that $(V,E)$ is a run DAG: $(q_0,0)\in V$ and for every $(x,i)\in V$:</p>
<ul>
<li>The state is accepted, any transitions from here are valid:<ul>
<li>if $x\in X_i\setminus W_i,\ X_{i+1}\models\delta(x,\alpha(i))$;</li>
</ul>
</li>
<li>The state is tracked, only transitions to accepting state or continue tracked are valid:<ul>
<li>if $x\in W_i, x’\in X_{i+1}\cap (F\cup W_{i+1})\models\delta(x,\alpha(i))$.</li>
</ul>
</li>
</ul>
<p>Since the automata is accepting, so it has $W_i&#x3D;\varnothing$ exist for infinitely many $i$. So the run DAG is accepting, because there is $x\in X_i\setminus W_i$ infinitely often, every path through the run DAG visits $F$ infinitely often.</p>
<blockquote>
<p>$\mathcal{L(A)}\subseteq\mathcal{L(A’)}$ (all word accepted by $\mathcal{L(A)}$ must also be accepted by $\mathcal{L(A’)}$):</p>
</blockquote>
<p>Let $\alpha\in\mathcal{L(A)}$ and $(V,E)$ be an accepting run DAG of $\mathcal{A}$ on $\alpha$.<br>We construct a run $r’&#x3D;(X_0,W_0)(X_1,W_1)(X_2,W_2)\dots$ on $\mathcal{A’}$ as follows:</p>
<ul>
<li><p>$X_0&#x3D;\lbrace q_0\rbrace$ and $W_0&#x3D;\varnothing$</p>
</li>
<li><p>We simulate the behaviour using $X_i$: for $i\geq 0$, let $X_{i+1} &#x3D; \lbrace x’\in Q\mid ((x,i),(x’,i+1))\in E, x\in X_i\rbrace$</p>
<ul>
<li>If the state is accepted, align the behaviour with $X$:<br>$W_{i+1} &#x3D; X_{i+1} \setminus F$ if $W_i&#x3D;\varnothing$</li>
<li>If not, track and see if the accepting condition is fulfiled: $W_{i+1} &#x3D; \lbrace x’\in Q \setminus F \mid\exists(x,i)\in V, ((x,i),(x’,i+1))\in E,x\in W_i\rbrace$.</li>
</ul>
</li>
</ul>
<p>Clearly, $r’$ is a run: it starts with $(\lbrace q_0\rbrace,\varnothing)$ and obeys $T’$. That is, $(X_{i+1},W_{i+1})$ contains states in $\delta(x,\alpha(i))$:</p>
<ul>
<li>For $x\in X_i\setminus W_i$, we have that $X_{i+1}\models\delta(x,\alpha(i))$;</li>
<li>For $x\in W_i$, $X_{i+1}\cap (F\cup W_{i+1})$ satisfies $\delta(x,\alpha(i))$.</li>
</ul>
<p>The run $r’$ is accepting, otherwise some state $(X_{i+1},W_{i+1})$ is rejected, and thus rejects the path in $(V,E)$.</p>
<h3 id="Example-with-the-construction"><a href="#Example-with-the-construction" class="headerlink" title="Example with the construction"></a>Example with the construction</h3><p><img src="/images/notes/uds/agv/7_3_nonde.png"></p>
<blockquote>
<p>$\textbf{Corollary 7.2. }\textit{A language is }\omega\textit{-regular if and only if it is recognizable by an alternating Büchi automaton.}$</p>
</blockquote>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this section, we have proved that any $\omega$-regular language can be recongnized by some alternating Büchi automaton. Let see how it is done.</p>
<ol>
<li><p>Every accepted word in an alternating Büchi automaton has an <strong>Memoryless Accepting Run</strong> (<em>Theorem 7.2</em>).</p>
</li>
<li><p>Every <strong>Memoryless Run Tree</strong> can be represented as a <strong>Run DAG</strong></p>
</li>
<li><p>Thus, Every accepted word in an alternating Büchi automaton has an <strong>Accepting Run DAG</strong> (<em>Corollary 7.1</em>).</p>
</li>
<li><p>For every <strong>Alternating Büchi Automaton</strong> there exists a <strong>Nondeterministic Büchi Automaton</strong> (<em>Theorem 7.3</em>).</p>
</li>
<li><p>An $\omega$-language is Büchi-recognizable iff it is $\omega$-regular (Büchi’s Characterization Theorem) (<em>Theorem 3.6</em>).</p>
</li>
<li><p>An $\omega$-language is <strong>Alternating</strong> Büchi-recognizable iff it is $\omega$-regular (<em>Corollary 7.2</em>).</p>
</li>
</ol>
<hr>
<p>Next chapter: <a href="../agv8-1/">Linear Arithmetic (Theory)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">Previous</a></div><div class="pagination-next"><a href="/page/4/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>