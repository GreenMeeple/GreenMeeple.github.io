<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-11T19:48:34.000Z" title="11/02/2025, 20:48:34">2025-02-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.439Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 974 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv11-2/">AGV 11.2 -- Reachability Games</a></p><div class="content"><p>Previous chapter: <a href="../agv11-1/">Infinite Games (Basic Definitions)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Reachability-Condition"><a href="#Reachability-Condition" class="headerlink" title="Reachability Condition"></a>Reachability Condition</h2><p>We will now analyze infinite games for various types of winning conditions. We start with the simple <strong>reachability</strong> condition.</p>
<p>The reachability condition is given as a set $R$ of positions called the reachability set. The reachability condition is satisfied if the play reaches some position in $R$. Formally, for an infinite word $\alpha$ over $\Sigma$, we use $\text{Occ}(\alpha) :&#x3D; \lbrace\sigma\in\Sigma\mid\exists n\in\mathbb{N}.\ \alpha(n)&#x3D;\sigma\rbrace$ to denote the set of all letters occurring in $\alpha$.</p>
<blockquote>
<p>$\textbf{Definition 11.11. } \text{The }\textit{reachability condition }\small\text{REACH} \normalsize(R)\text{ on a set of positions }R\subseteq V\text{ is the set}$</p>
<p>$$<br>\small\text{REACH} \normalsize(R) &#x3D; \lbrace\rho\in V^\omega\mid\text{Occ}(\rho)\cap R\neq\varnothing\rbrace\newline\newline\text{A game }\mathcal{G}&#x3D;(\mathcal{A},\text{Win})\text{ with Win}&#x3D;\small\text{REACH} \normalsize(R)\text{ is called a }\textit{reachability game}\text{ with reachability set }R<br>$$</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>$$<br>\text{Position of Player 0: Circles;}\ \ \text{Positions of Player 1: rectangles.}$$ </p>
<p><img src="/images/notes/uds/agv/11_2_reachability.png"></p>
<p>$$\mathcal{G}&#x3D;(\mathcal{A},\small\text{REACH} \normalsize(R)),\ R&#x3D;\lbrace v_4,v_5\rbrace<br>$$</p>
<ul>
<li>The winning region for Player 0: $W_0(\mathcal{G})&#x3D;\lbrace v_3,v_4,v_5,v_6,v_7,v_8\rbrace$<ul>
<li>Strategy: $\sigma(v_1) &#x3D; v_2, \sigma(v_3) &#x3D; v_4, \sigma(v_7) &#x3D; v_8, \sigma(v_8) &#x3D; v_5$</li>
</ul>
</li>
</ul>
<h2 id="Attractor-Construction"><a href="#Attractor-Construction" class="headerlink" title="Attractor Construction"></a>Attractor Construction</h2><p>Reachability games can be solved with a simple fixed point construction called the <strong>attractor construction</strong>.</p>
<p>The attractor construction computes the winning region for Player 0 iteratively by the <strong>reachability set</strong>:</p>
<ol>
<li>adds all positions owned by Player 0 that <strong>have an edge</strong> into the winning region,</li>
<li>then adds all positions owned by Player 1 where <strong>all edges</strong> lead into the winning region. (no choices)</li>
<li>Repeats until no more positions can be added.</li>
</ol>
<p>In the following, we give a slightly more general definition of the attractor construction that can be applied also to Player 1. We do this in preparation for the constructions for other winning conditions, which will use the attractor construction as a subroutine.</p>
<blockquote>
<p>$\textbf{Construction 11.1. } \text{Let an arena }\mathcal{A} &#x3D; (V,V_0,V_1,E)\text{ be given. The }\textit{attractor construction}\text{ on}\newline\mathcal{A}\text{ is defined for each Player }i\text{, for all }n\in\mathbb{N}\text{ and }R\subseteq V\text{ as follows.}$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ CPre^{i}(R) &amp;&#x3D;&amp; \lbrace v\in V_i\mid\exists v’\in V.(v, v’)\in E\wedge v’\in R\rbrace\cup\ \newline<br>&amp;&amp;\lbrace v\in V_{1-i}\mid\forall v’\in V.(v, v’)\in E\rightarrow v’\in R\rbrace\newline<br>\hspace{1cm} \cdot \ Attr_{0}^{i}(R)&amp;&#x3D;&amp;R \newline<br>\hspace{1cm} \cdot \ Attr_{n+1}^{i}(R)&amp;&#x3D;&amp;Attr_{n}^{i}(R)\cup CPre^{i}(Attr_{n}^{i}(R)) \newline<br>\hspace{1cm} \cdot \ Attr^{i}(R)&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcup} Attr_{n}^{i}(R)\newline<br>\end{array}$</p>
</blockquote>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/11_2_attractor.png"></p>
<p>In general, the attractor construction solves a game with winning condition $\small\text{REACH} \normalsize(R)$ as follows: $W_0(\mathcal{G})&#x3D;Attr^0(R), W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})$. We can furthermore give a uniform memoryless winning strategy. These results are summarized in the following theorem.</p>
<blockquote>
<p>$\textbf{Theorem 11.1. } \textit{Reachability games are memoryless determined. It holds that}\newline W_0(\mathcal{G})&#x3D;Attr^0(R), W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})\textit{. Both players have a uniform winning strategy.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We show for all positions $v\in V$ that</p>
<p>If $v\in Attr^0(R)$, then $v\in W_0(\mathcal{G})$, with the following uniform memoryless strategy $\sigma$:</p>
<ul>
<li>We fix an arbitrary total ordering on $V$ . For $v\in (Attr^0(R)\setminus R)\cap V_0$, let $n &#x3D; min\lbrace n\in\mathbb{N}\mid v\in Attr_{n}^0(R)\rbrace$. Then, let $\sigma(v)$ be the smallest $v’\in Attr_{n-1}^0(R)$ with $(v, v′)\in E$</li>
<li>For every other position $v\in V_0\setminus(Attr^0(R)\setminus R)$, let $\sigma(v)$ be the smallest $v’\in V$ with $(v, v′)\in E$</li>
<li>We show, by induction on $n\in\mathbb{N}$, that any play that starts in $v\in Attr_{n}^0(R)$<br>and is consistent with $\sigma$ reaches $R$ within at most $n$ steps.</li>
</ul>
<p>If $v\in V\setminus Attr^0(R)$, then $v\in W_1(\mathcal{G})$, with the following uniform memoryless strategy $\tau$:</p>
<ul>
<li>We again fix an arbitrary total ordering on $V$. For $v\in V_1\setminus Attr^0(R)$, let $\tau(v)$ be the smallest $v’\in V\setminus Attr^0(R)$ such that $(v, v′)\in E$. Such a successor $v’$ always exists, because otherwise $v\in Attr^0(R)$.</li>
<li>For every other position $v\in V_1\cap Attr^0(R)$ let $\tau(v)$ be the smallest $v’\in V\setminus Attr^0(R)$ with $(v, v′)\in E$. Now let $\rho$ be an arbitrary play that is consistent with $\tau$.</li>
<li>We show, by induction on $n$, that $\rho(n)\notin Attr^0(R)$ and, hence, $\rho(n)\notin R$, for all $n\in\mathbb{N}$.</li>
</ul>
<h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p><strong>Strategy for Player 0</strong></p>
<ul>
<li>A position $v$ belongs to $Attr_{n}^0(R)\setminus R$, must have edges to $v’\in Attr_{n-1}^0(R)$, then choose the smallest $v’$</li>
<li>If a position $v$ does not belong to $Attr^0(R)\setminus R$, simply choose the smallest $v’$ from its edges.</li>
</ul>
<p><strong>Strategy for Player 1</strong></p>
<ul>
<li>If a position $v$ does not belong to $Attr_{n}^0(R)$, it must have any one edge does not move to $Attr^0(R)$, choose the smallest $v’$ among those.</li>
<li>If a position $v$ belongs to $Attr_{n}^0(R)$, since all its edges move to some positions in $Attr_{n}^0(R)$, simply choose the smallest $v’$ from its edges.</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv11-3/">Büchi Games</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-11T16:11:48.000Z" title="11/02/2025, 17:11:48">2025-02-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.408Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">9 minutes read (About 1375 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv11-1/">AGV 11.1 -- Infinite Games (Basic Definitions)</a></p><div class="content"><p>Previous chapter: <a href="../agv10-5/">From semi-deterministic Büchi to deterministic Muller</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now introduce <em>infinite two-player games on finite graphs</em>. Infinite games are useful to solve the synthesis problem, where we are interested in finding a strategy that guarantees that a given specification is satisfied (cf. <a href="../agv1.2/">Section 1.2</a>). As we will see, games also play a fundamental role in automata theory, in particular for automata over infinite trees.</p>
<h2 id="Basic-Definitions"><a href="#Basic-Definitions" class="headerlink" title="Basic Definitions"></a>Basic Definitions</h2><p>The game is played on a graph, called the <strong>arena</strong>. The vertices of the graph are called <strong>positions</strong> and are partitioned into the positions of Player 0 and the positions of Player 1. </p>
<ul>
<li>A play of the game starts in some initial position</li>
<li>In any positions, the player who <strong>owns the position chooses the edge</strong> on which the play is continued.</li>
<li>Player 0 wins if the play is an element of the <strong>winning condition</strong>.</li>
</ul>
<p>The winner is determined by a winning condition, which, like the acceptance condition of an automaton on infinite words is a subset of the infinite words over the positions. </p>
<blockquote>
<p>$\textbf{Definition 11.1. } \text{A }\textit{game arena}\text{ is a tuple }\mathcal{A} &#x3D; (V,V_0,V_1,E)\text{, where}\newline\begin{array}{l}<br>\hspace{0.5cm} \cdot \ V_0\text{ and }V_1&#x3D;V\setminus V_0\text{ are disjoint sets of positions,}\newline<br>\hspace{1cm} \text{called the positions of Player 0 and Player 1.}\newline<br>\hspace{0.5cm} \cdot \ E\subseteq V\times V\text{ is a set of edges such that every position }v\in V\newline<br>\hspace{1cm} \text{has at least one outgoing edge }(v,v’)\in E.\newline<br>\end{array}$</p>
</blockquote>
<blockquote>
<p>$\textbf{Definition 11.2. } \text{A }\textit{play}\text{ is an infinite sequence }  \rho\in V^\omega\text{ such that}$<br>$$\forall n\in\mathbb{N}.(\rho(n),\rho(n+1))\in E$$</p>
</blockquote>
<p>We say a play $\rho$ starts in a position $v$ iff $v&#x3D;\rho(0)$. We denote the set of all possible plays on $\mathcal{A}$ with $\text{Plays}(\mathcal{A})$ and the set of all possible plays starting in position $v$ with $\text{Plays}(\mathcal{A},v)$.</p>
<blockquote>
<p>$\textbf{Definition 11.3. }\text{A }\textit{game }\mathcal{G}&#x3D;(\mathcal{A},\text{Win})\text{ consists of an arena }\mathcal{A}\text{ and a }\textit{winning condition}\newline\text{Win}\subseteq V^\omega\text{. We call a play }\rho\textit{ winning for Player 0}\text{ iif }\rho\in\text{Win and }\textit{winning for Player 1}\text{ otherwise.}$ </p>
</blockquote>
<p>When it is Player $i$’s turn, the current vertex must be a <strong>position</strong> of Player $i$ ($V_i$), all the prefix of the play seen so far (including current vertex) is called the <strong>history</strong> of the <strong>play</strong>, which is an element of $V^\ast V_i$.</p>
<p>A <strong>strategy</strong> fixes the decisions of a player based on the <strong>history</strong> of the play. A <strong>strategy</strong> for Player $i$ is a function $\sigma:V^\ast V_i\rightarrow V$ that selects for each such history a successor position.</p>
<blockquote>
<p>$\textbf{Definition 11.4. }\text{A }\textit{strategy}\text{ for Player }i\text{ is a function }\sigma:V^\ast V_i\rightarrow V\text{ such that }(v,v’)\in E\newline\text{whenever }\sigma(wv)&#x3D;v’\text{ for some }w\in V^\ast,v\in V_i$ </p>
</blockquote>
<p>In the following, we use $\sigma$ and $\tau$ to denote strategies for Player $i$ and the opponent Player $(1−i)$, respectively.</p>
<blockquote>
<p>$\textbf{Definition 11.5. }\text{A play }\rho\text{ is }\textit{consistent}\text{ with a strategy }\sigma\text{ iff}$<br>$$\forall n\in\mathbb{N}.\text{if }\rho(n)\in V_i\text{ then }\rho(n+1)&#x3D;\sigma(\rho[n])$$</p>
</blockquote>
<p>We denote the set of all plays that begin in some position $v$ and are consistent with strategy $\sigma$ with $\text{Plays}(\mathcal{A}, \sigma, v)$. Note that the strategies $\sigma$ and $\tau$ of the two players together uniquely identify a specific play: $\mid \text{Plays}(\mathcal{A}, \sigma, v)\cap \text{Plays}(\mathcal{A}, \tau, v)\mid &#x3D; 1$. </p>
<p>Our definition of a strategy is very general in the sense that the decisions are based on the entire history of the play. Intuitively, this means that the players have infinite memory. It often suffices to work with simpler strategies, such as <strong>memoryless</strong> strategies. <strong>Memoryless</strong> strategies are often also called <strong>positional</strong>.</p>
<blockquote>
<p>$\textbf{Definition 11.6. }\text{A strategy }\sigma\text{ for Player }i\text{ is }\textit{memoryless}\text{ iff }\sigma(wv)&#x3D;\sigma(v)\text{ for all }w\in V^\ast,v\in V_i.$</p>
</blockquote>
<p>In a slight abuse of notation, memoryless strategies are often given directly as a function $\sigma:V_i\rightarrow V$ that maps the positions owned by Player $i$ to their successor positions. Next, we characterize <strong>winning</strong> strategies:</p>
<blockquote>
<p>$\textbf{Definition 11.7. }\text{A strategy }\sigma\text{ for Player }i\text{ is }\textit{winning}\text{ from a position }v\text{ if all plays that}\newline\text{start in }v\text{ and that are consistent with }\sigma\text{ are winning for Player }i.$</p>
</blockquote>
<p>Note that this definition refers to a specific position $v$ in which we start the play. The set of all positions where the player has a winning strategy is called the <strong>winning region</strong>.</p>
<blockquote>
<p>$\textbf{Definition 11.8. }\text{ The }\textit{winning region }W_i(\mathcal{G})\text{ of Player }i\text{ in a game }\mathcal{G}\text{ is defined as}\newline\text{the set of positions }v\in V\text{ for which there exists a strategy for Player }i\text{ that is winning from }v.$</p>
</blockquote>
<p>Note that the strategies for different positions in the winning region may be different. If a strategy $\sigma$ is winning from all positions of the winning region, we call $\sigma$ a <strong>uniform winning strategy</strong>.</p>
<p>It is easy to see that no position can be in the winning regions of both players. Otherwise there exists a position $v$ and strategies $\sigma$ and $\tau$ that are winning from $v$ for Player 0 and 1, respectively. Then the unique play that is consistent with $\sigma$ and $\tau$ need to be both in Win, because $\sigma$ is winning, and not in Win, because $\tau$ is winning. </p>
<p>A more difficult question is whether all positions are in some winning region, i.e., whether the winning regions form a partition of $V$. This property is called the <strong>determinacy</strong> of a game:</p>
<blockquote>
<p>$\textbf{Definition 11.9. }\text{A }\textit{game }\mathcal{G}\text{ is }\textit{determined }\text{if }V&#x3D;W_0(\mathcal{G})\cup W_1(\mathcal{G})$</p>
</blockquote>
<p>If the winning strategies are in fact memoryless, we say the game is <strong>memoryless</strong> (<strong>positionally</strong>) determined.</p>
<blockquote>
<p>$\textbf{Definition 11.10. }\text{A game is }\textit{memoryless determined }\text{if for every position }v\in V\text{, there exists}\newline\text{a memoryless stratey that is winning for some player from position }v.$</p>
</blockquote>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this section, we have learned:</p>
<ul>
<li><p><strong>Arena</strong>: the graph of the game, expressed as a tuple $\mathcal{A}&#x3D;(V,V_0,V_1,E)$</p>
<ul>
<li><strong>Position</strong>: vertex of Arena $v\in V$</li>
<li><strong>Positions of Player $i$</strong>: a disjoint set of position $V_i$</li>
</ul>
</li>
<li><p><strong>Play</strong>: an infinite sequence of $\rho\in V^\omega$</p>
<ul>
<li><strong>set of all Plays</strong>: $\text{Plays}(\mathcal{A})$</li>
<li><strong>set of all Plays in position $v$</strong>: $\text{Plays}(\mathcal{A},v)$</li>
<li><strong>starting position</strong>: $v &#x3D; \rho(0)$</li>
<li>the player who <strong>owns the position chooses the edge</strong> on which the play is continued ($\rho\in V_i$)</li>
</ul>
</li>
<li><p><strong>Game</strong>: consist of an arena and a winning condition $\mathcal{G}&#x3D;(\mathcal{A},\text{Win})$</p>
<ul>
<li><strong>winning condition</strong>: $\text{Win}\subseteq V^\omega$</li>
<li><strong>winning play for Player 0</strong>: $\rho\in\text{Win}$</li>
<li><strong>winning play for Player 1</strong>: $\rho\notin\text{Win}$</li>
</ul>
</li>
<li><p><strong>history</strong>: all previous positions $V^\ast$</p>
</li>
<li><p><strong>Strategy</strong>: decisions of a player based on history of the play</p>
<ul>
<li><strong>Strategy of Player $i$</strong>: $\sigma:V^\ast V_i\rightarrow V$</li>
<li><strong>Strategy of Player 0</strong>: $\sigma$</li>
<li><strong>Strategy of Player 1</strong>: $\tau$</li>
</ul>
</li>
<li><p><strong>Memoryless (positional) Strategy</strong>: $\sigma(wv)&#x3D;\sigma(v)\text{ for all }w\in V^\ast,v\in V_i$</p>
</li>
<li><p><strong>Winning Region</strong>: set of all positions that Player $i$ has a winning strategy $W_i(\mathcal{G})\in V$  </p>
<ul>
<li><strong>Uniform Winning Strategy</strong>: one strategy that can apply to any position in a winning region.</li>
</ul>
</li>
<li><p><strong>Determinacy</strong>: $\mathcal{G}$ is determined if every position is in some player’s winning region $V&#x3D;W_0(\mathcal{G})\cup W_1(\mathcal{G})$</p>
<ul>
<li>A determined game have winning strategy in every positions.</li>
</ul>
</li>
<li><p><strong>Memoryless Game</strong>: all strategies are memoryless in every position of a determined game</p>
</li>
</ul>
<hr>
<p>Next chapter: <a href="../agv11-2/">Reachability Games</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-02-11T07:41:39.000Z" title="11/02/2025, 08:41:39">2025-02-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.439Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">2 minutes read (About 259 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-5/">AGV 10.5 -- From semi-deterministic Büchi to deterministic Muller</a></p><div class="content"><p>Previous chapter: <a href="../agv10-4/">Semi-Deterministic Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>From the semi-deterministic Büchi automaton we now build a deterministic Muller automaton. The idea of the construction is to continuously simulate, in the deterministic automaton, the nondeterministic part of the semi-deterministic automaton and to ”attempt” a transition into the deterministic part whenever possible.</p>
<p>In the state of the deterministic automaton we maintain an “array” of states that correspond to these attempts. Along each run of the automaton, there may of course be infinitely many such attempts; we only need a finite array, however, because we do not need to keep track of two different attempts to enter the deterministic part, if they both reach the same state (in this case, we simply track the attempt that entered the deterministic part earlier). </p>
<p>We use an array of size $2m$, where m is the number of states of the deterministic part. The factor two allows us to leave a position of the array empty (“␣”) if an attempt is not continued. This is necessary to distinguish a situation where a previously started attempt failed and, at the same time, a new attempt enters the deterministic part, from the situation where the same attempt ran continuously. The deterministic automaton accepts if there is at least one attempt that runs forever after some point and reaches an accepting state infinitely often.</p>
<hr>
<p>Next chapter: <a href="../agv11-1/">Infinite Games (Basic Definitions)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-01-29T14:23:24.000Z" title="29/01/2025, 15:23:24">2025-01-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.407Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">10 minutes read (About 1455 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-4/">AGV 10.4 -- Semi-Deterministic Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv10-3/">Closure Properties of Muller automata Under Boolean Operations</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>To prove McNaughton’s theorem, in this subsection, we will introdue the <strong>semi-deterministic Büchi automata</strong>.</p>
<ol>
<li>translate nondeterministic Büchi automata into semi-deterministic Büchi automata.</li>
<li>translate from semi-deterministic Büchi automata to deterministic Muller automata.</li>
</ol>
<h2 id="Semi-deterministic-Buchi-Automata"><a href="#Semi-deterministic-Buchi-Automata" class="headerlink" title="Semi-deterministic Büchi Automata"></a>Semi-deterministic Büchi Automata</h2><p>A <em>semi-deterministic automaton</em> is a (possibly nondeterministic) automaton where all accepting runs ultimately end up in a <strong>subset of the states</strong> from which all transitions are deterministic.</p>
<blockquote>
<p>$\textbf{Definition 10.2. } \text{A Büchi automata }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ is }\textit{semi-deterministic}\text{ if}\newline Q &#x3D; N \uplus D\text{ is a partition of }Q\text{ such that }F\subseteq D, pr_2(T\cap(D\times\Sigma\times Q))\subseteq D\text{, and }\newline(\Sigma,D,\lbrace d\rbrace,T\cap(D\times\Sigma\times D),\small\text{BÜCHI}\normalsize(F)) \text{ is deterministic for every }d\in D.$</p>
</blockquote>
<h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p>$Q &#x3D; N \uplus D:$ a <em>disjoint union symbol</em> $\uplus$ indicates that $N$ and $D$ are two seperated subset.</p>
<p>$D:$ firstly, set of accepting states in part of $D$ ($F\subseteq D$). Then for all transistion starts from $D$ ($T\cap(D\times\Sigma\times Q)$), their successors are also in $D$ ($pr_2(T\cap(D\times\Sigma\times Q))\subseteq D$).</p>
<p>Therefore, we can split such automaton into nondeterministic part $N$ and determinstic part $D$, and the accepting run will end up stays in $D$.</p>
<h2 id="From-Nondeterministic-to-Semi-deterministic-Buchi-Automata"><a href="#From-Nondeterministic-to-Semi-deterministic-Buchi-Automata" class="headerlink" title="From Nondeterministic to Semi-deterministic Büchi Automata"></a>From Nondeterministic to Semi-deterministic Büchi Automata</h2><p>The translation is based on a <strong>subset construction</strong>, where we collect two sets of states:</p>
<ol>
<li>the states that are reachable on the given input word, and</li>
<li>the states that are reachable on some path through an accepting state.</li>
</ol>
<p>A state of the semi-deterministic automaton is accepting if the <strong>two sets become equal</strong>; when this happens, the second set is reinitialized with the subset of accepting states that appear in the first component.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/10_4_nonde.png"></p>
<p><img src="/images/notes/uds/agv/10_4_subset.png"></p>
<p>The subset construction produces a <em>deterministic</em> automaton that accepts a subset of the words accepted by the original automaton. If the two sets are equal infinitely often, we can construct a run of the original automaton that goes through accepting states infinitely often:</p>
<p>intuitively, we can go “backwards” from each position where the two sets have become equal and select a path segment for the original automaton where an accepting state is visited (in the proof below we give a more precise argument using König’s lemma).</p>
<p>There is no general guarantee that the set of reachable states from some position of an accepting run and the set of states reachable on a path through some accepting state are the same. This is illustrated by the following example.</p>
<p><img src="/images/notes/uds/agv/10_4_counter.png"></p>
<p>Let the input word be $\alpha^\omega$. From the initial position of some run, which starts in the initial state $p$, all states are reachable, but only $r$ and $s$ are reachable on paths from $s$.</p>
<p>Ultimately, however, every accepting run must reach (and remain in) positions where the <strong>set of reachable states</strong> and the <strong>set of states reachable on a path through some accepting state</strong> are the same. This is because the set of reachable states can only become smaller finitely often; hence, at some point, the set of reachable states will remain the same from all subsequent positions, including those (future) positions of the accepting run where the run visits an accepting state.</p>
<p>In our semi-deterministic automaton, we therefore start by simulating the given nondeterministic automaton. At any point we allow a nondeterministic transition into the (from then on) deterministic subset construction.</p>
<blockquote>
<p>$\textbf{Construction 10.5. } \text{For a Büchi automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize (F))\text{, we construct the semi-}\newline\text{deterministic Büchi automaton }\mathcal{A’} &#x3D; (\Sigma,Q’,I’,T’,\small\text{BÜCHI}\normalsize (F’))\text{ with }\mathcal{L}(\mathcal{A’})&#x3D;\mathcal{L}(\mathcal{A})\text{ as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ Q’&#x3D;Q\uplus (2^Q\times2^Q)\newline<br>\hspace{1cm} \cdot \ I’&#x3D;I’ \newline<br>\hspace{1cm} \cdot \ T’&#x3D;T\cup\lbrace(q,\sigma,(\lbrace q’\rbrace,\varnothing))\mid(q,\sigma,q’)\in T\rbrace \newline<br>\hspace{2.85cm}\cup \ \lbrace((L_1,L_2),\sigma,(L’_1,L’_2))\mid L_1\neq L_2\newline<br>\hspace{3.8cm}L’_1&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times Q)\newline<br>\hspace{3.8cm}L’_2&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times F)\cup pr_2(T\cap L_2\times\lbrace\sigma\rbrace\times Q)\rbrace\newline<br>\hspace{2.85cm}\cup \ \lbrace((L_1,L_2),\sigma,(L’_1,L’_2))\mid L_1&#x3D; L_2\newline<br>\hspace{3.8cm}L’_1&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times Q)\newline<br>\hspace{3.8cm}L’_2&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times F)\newline<br>\hspace{1cm} \cdot \ F’&#x3D;\lbrace(L,L)\in(2^Q\times2^Q)\mid L\neq\varnothing\rbrace\newline<br>\end{array}$</p>
</blockquote>
<blockquote>
<p>$\textbf{Lemma 10.1. } \textit{For every Büchi automaton }\mathcal{A}\textit{ there exists a semi-deterministic Büchi}\newline\textit{automaton }\mathcal{A’}\textit{ with }\mathcal{L}(\mathcal{A})&#x3D;\mathcal{L}(\mathcal{A’}).$</p>
</blockquote>
<h2 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h2><p>$\mathcal{L}(\mathcal{A’})\subseteq\mathcal{L}(\mathcal{A})$</p>
<p>Let $\alpha\in\mathcal{L}(\mathcal{A’})$ and let $r’&#x3D;q_0q_1\dots q_{n-1}(L_n,L’<em>n)(L</em>{n+1},L’<em>{n+1})\dots$ be an accepting run of $\mathcal{A’}$ on $\alpha$. Since $r’$ is accepting, there is an infinite sequence $i_0i_1\dots$ of indices such that $i_0&#x3D;n$, and, for all $j\geq1$, $L</em>{i_j} &#x3D; L’<em>{i_j}$ and $L’</em>{i_j}\neq\varnothing$. For every $j\geq1$, and every $q’\in L_{i_j}$ there exists a state $q\in L_{i_{j−1}}$ and a sequence $q &#x3D; q_{i_{j−1}} , q_{i_{j−1}+1},\dots, q_{i_j} &#x3D; q’$ such that $(q_k, \alpha(k), q_{k+1})\in T$ for all $k\in \lbrace i_{j−1},\dots,i_j − 1\rbrace$ and $q_k\in F$ for some $k\in\lbrace i_{j−1}+1,\dots,i_j\rbrace$. We use the following notation: $\textit{predecessor}(q’,i_j) :&#x3D; q, \textit{run}(q’,i_0) &#x3D; q_0q_1\dots q_{n−1}q’$ for $L_{i_0} &#x3D; \lbrace q’\rbrace$, and $\textit{run}(q’,i_j)&#x3D;(q_{i_{j−1}+1})(q_{i_{j−1}+2})\dots q_{i_j}$, for $j\geq1$. </p>
<p>Now consider the  j∈N Lij × {j} -labeled tree where the root is labeled with (q ′ , 0) for Li0 &#x3D; {q ′}, and the parent of each node with a label (q ′ , j) is labeled with (predecessor(q ′ , ij ), j − 1). The tree is infinite and finite-branching, and, hence, by K¨onig’s Lemma, has an infinite branch (qi0 , i0),(qi1 , i1), . . ., corresponding to an accepting run of A: run(qi0 , i0) · run(qi1 , i1) · run(qi2 , i2) · . . . </p>
<p>L(A) ⊆ L(A′ ): Let α ∈ L(A) and let r &#x3D; q0, q1, . . . be an accepting run of A on α. Let i ∈ N be an index s.t. qi ∈ F and for all j ≥ i there exists a k &gt; j, such that {q ∈ Q | qi α[i,k] −−−→ q} &#x3D; {q ∈ Q | qj α[j,k] −−−→ q}. The index i exists: ”⊇” holds for all i, because there is a path through qj . Assume, by way of contradiction, that for all i ∈ N, there is a j ≥ i s.t for all k &gt; j ”⊋” holds. Then there exists an i ′ s.t. {q ∈ Q | qi ′ α[i ′ ,k] −−−−→ q} &#x3D; ∅ for all k &gt; i′ . Contradiction. We define a run r ′ of A′ : r ′ &#x3D; q0 . . . qi−1({qi}, ∅)(L1, L′ 1 )(L2, L′ 2 ). . . where Lj and L ′ j are determined by the definition of A′ . To prove that r ′ is accepting, assume otherwise, and let m ∈ N be an index such that Ln ̸&#x3D; L ′ n for all n ≥ m. Then, let j &gt; m be some index with qj ∈ F; hence qj ∈ L ′ j . There exists a k &gt; j such that L ′ k+1 &#x3D; {q ∈ Q | qj α[j,k] −−−→ q} &#x3D; {q ∈ Q | qi α[i,k] −−−→ q} &#x3D; Lk+1. Contradiction.</p>
<hr>
<p>Next chapter: <a href="../agv10-5/">From semi-deterministic Büchi to deterministic Muller</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2025-01-01T18:36:48.000Z" title="01/01/2025, 19:36:48">2025-01-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.319Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Coding/">Coding</a></span><span class="level-item">2 minutes read (About 294 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/appium/">Appium commands that are commonly used on Mac</a></p><div class="content"><p>In this example, we will use <a target="_blank" rel="noopener" href="https://github.com/appium/appium-inspector">Appium Inspector</a> to start a seesion on your emulator on <a target="_blank" rel="noopener" href="https://developer.android.com/studio">Android Studio</a>.</p>
<h2 id="Start-appium"><a href="#Start-appium" class="headerlink" title="Start appium"></a>Start appium</h2><p><img src="/images/coding/appium/start.png"></p>
<p>First, start the connection with Appium by <code>cmd appium --allow-cors</code>. It also gives you the <code>remote url</code> and the <code>automationName</code> that can be used in the <a target="_blank" rel="noopener" href="https://github.com/appium/appium-inspector">Appium Inspector</a></p>
<p><img src="/images/coding/appium/inspector.png"></p>
<h2 id="Start-Session"><a href="#Start-Session" class="headerlink" title="Start Session"></a>Start Session</h2><ul>
<li><strong>deviceName</strong>:  <code>adb devices</code></li>
<li><strong>platformName</strong> - <code>appium driver list</code></li>
<li><strong>platformVersion</strong> -  <code>adb shell getprop ro.build.version.release</code></li>
</ul>
<p><img src="/images/coding/appium/session.png"></p>
<p><img src="/images/coding/appium/inspector2.png"></p>
<p>Now you can start a session in your emulator, but it always begins from the home page. To directly start a session on certain App, you also need to provide the  <code>appPackage</code> and the <code>appActivity</code>.</p>
<h2 id="Session-with-Apps"><a href="#Session-with-Apps" class="headerlink" title="Session with Apps"></a>Session with Apps</h2><p>If your app is downloaded from the PlayStore. It is possible that the apk file name&#x2F;path is hidden. However, you can You can simply open the app and check its name by <code>adb shell dumpsys window | grep mCurrentFocus</code>.</p>
<p>It returns the <code>appPackage</code> and the current <code>appActivity</code> of the App, which are both necessary for our seesion to start. However, sometimes the current activity may not be directly opened. Then we need to check all the possible activities this App contans and try them out.</p>
<p>To check the activity list, we can use <code>adb shell dumpsys package YOUR_APP_appPackage | grep -i activity</code>.</p>
<p><img src="/images/coding/appium/activity.png"></p>
<p>Now, we can start our emulator, and run the command <code>adb shell am start -n YOUR_APP_appPackage/YOUR_APP_appActivity</code> to see whether it can start the App successfully. If it works we can use it in our inspector.</p>
<p><img src="/images/coding/appium/cici.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><i class="fas fa-thumbtack level-item" title="Pinned"></i><span class="level-item">Posted&nbsp;<time dateTime="2024-12-22T15:35:16.000Z" title="22/12/2024, 16:35:16">2024-12-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.405Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">2 minutes read (About 325 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv/">Automata, Games, and Verification (Portal)</a></p><div class="content"><blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1. Introduction"></a>Chapter 1. Introduction</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv1-1/">1.1. Model Checking</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv1-2/">1.2. Synthesis</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv1-3/">1.3. The Logic-Automata Connection</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-2-Buchi-Automata"><a href="#Chapter-2-Buchi-Automata" class="headerlink" title="Chapter 2. Büchi Automata"></a>Chapter 2. Büchi Automata</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv2-1/">2.1. Preliminaries</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv2-2/">2.2. Automata over Infinite Words</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv2-3/">2.3. The Büchi Acceptance Condition</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-3-Buchi’s-Characterization-Theorem"><a href="#Chapter-3-Buchi’s-Characterization-Theorem" class="headerlink" title="Chapter 3. Büchi’s Characterization Theorem"></a>Chapter 3. Büchi’s Characterization Theorem</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv3-1/">3.1. Kleene’s Theorem</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv3-2/">3.2. $\omega$-regular language</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv3-3/">3.3 Closure Properties of the Büchi-recognizable languages (Intersection and Union)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv3-4/">3.4 Closure Properties of the Büchi-recognizable languages (Concatenations)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv3-5/">3.5 Büchi’s Characterization Theorem</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-4-Deterministic-Buchi-Automata"><a href="#Chapter-4-Deterministic-Buchi-Automata" class="headerlink" title="Chapter 4. Deterministic Büchi Automata"></a>Chapter 4. Deterministic Büchi Automata</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv4-1/">4.1. Deterministic vs. Nondeterministic Büchi Automata</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv4-2/">4.2. Complementation of deterministic Büchi Automata</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-5-Complementation-of-Buchi-automata"><a href="#Chapter-5-Complementation-of-Buchi-automata" class="headerlink" title="Chapter 5. Complementation of Büchi automata"></a>Chapter 5. Complementation of Büchi automata</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv5-1/">5.1. Infinite Directed Acyclic Graph (DAG)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv5-2/">5.2. Ranking of DAG</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv5-3/">5.3. Complement Büchi Automaton with Odd Ranking</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-6-Logics-over-Infinite-Sequences"><a href="#Chapter-6-Logics-over-Infinite-Sequences" class="headerlink" title="Chapter 6. Logics over Infinite Sequences"></a>Chapter 6. Logics over Infinite Sequences</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv6-1/">6.1. Linear-Time Temporal Logic (LTL)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-2/">6.2. Expressing Program Properties using LTL</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-3/">6.3. LTL and Counting Languages</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-4/">6.4. Quantified Propositional Temporal Logic (QPTL)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-5/">6.5. Monadic Second-Order Logic of One Successor (S1S)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-6/">6.6. Express QPTL using S1S</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv6-7/">6.7. S1S$_0$ and Büchi-recognizable LanguageBüchi-recognizable</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-7-Alternating-Buchi-Automata"><a href="#Chapter-7-Alternating-Buchi-Automata" class="headerlink" title="Chapter 7. Alternating Büchi Automata"></a>Chapter 7. Alternating Büchi Automata</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv7-1/">7.1. Alternating Büchi Automata</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv7-2/">7.2. From LTL to Alternating Büchi Automata</a></td>
<td align="left"><a href="../agv7-2/">$\varphi&#x3D;(\Diamond p)\ \mathcal{U}\ (\square q)$</a></td>
</tr>
<tr>
<td align="left"><a href="../agv7-3/">7.3. Translating Alternating to Nondeterministic automata</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-8-Linear-Arithmetic"><a href="#Chapter-8-Linear-Arithmetic" class="headerlink" title="Chapter 8. Linear Arithmetic"></a>Chapter 8. Linear Arithmetic</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv8-1/">8.1. Linear Arithmetic (Theory)</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv8-2/">8.2 Encoding real numbers</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv8-3/">8.3 Translation from Linear Arithmetic to Automata</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv8-4/">8.4 Homogenous Inequality Testing is Automatic</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv8-5/">8.5 From Linear Arithmetic to Automata</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-9-LTL-Model-Checking"><a href="#Chapter-9-LTL-Model-Checking" class="headerlink" title="Chapter 9. LTL Model Checking"></a>Chapter 9. LTL Model Checking</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv9-1/">9.1 Automata-based LTL Model Checking with Sequential Circuits</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv9-2/">9.2 Nested depth-first search</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv9-3/">9.3 The Emerson-Lei algorithm</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Chapter-10-McNaughton’s-Theorem"><a href="#Chapter-10-McNaughton’s-Theorem" class="headerlink" title="Chapter 10. McNaughton’s Theorem"></a>Chapter 10. McNaughton’s Theorem</h2><table>
<thead>
<tr>
<th align="left">Sections</th>
<th align="left">Exercise</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="../agv10-1/">10.1 The Muller Acceptance Condition</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv10-2/">10.2 From Büchi automata to Muller automata</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="../agv10-3/">10.3 Closure Properties of Muller Automata under Boolean Operations</a></td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<p>Next chapter: <a href="../agv/"></a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-19T02:06:12.000Z" title="19/12/2024, 03:06:12">2024-12-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.401Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Cantonese/">Cantonese</a><span> / </span><a class="link-muted" href="/categories/Cantonese/Full-Course/">Full_Course</a></span><span class="level-item">2 minutes read (About 301 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/Canto/canto1-6/">Cantonese Ch.1-6 -- Tones</a></p><div class="content"><blockquote>
<p>Golden Rule of becoming a native Cantonese speaker: <strong>Tones</strong> &gt; Everything!</p>
</blockquote>
<p>In this blog, we use <a target="_blank" rel="noopener" href="https://jyutping.org/en/docs/english/">Jyutping</a> to indicate the pronunciation of Cantonese characters.</p>
<p>Previous lesson: <a href="../canto1-3/">Rimes with e</a></p>
<hr>
<p>In this lesson, we talk about Rimes with <code>u</code>, <code>yu</code>. Here we use <code>u</code> similar to languages like German or Italian.</p>
<p>And <code>yu</code> is equivalent to “ü” in German. Let’s take a look.</p>
<h2 id="Rimes-with-u"><a href="#Rimes-with-u" class="headerlink" title="Rimes with u"></a>Rimes with <code>u</code></h2><p>For <code>u</code>, <code>ui</code>, <code>un</code>, <code>ut</code>, u sounds like “oo” in “foo”.</p>
<p>For <code>ung</code> and <code>uk</code>, u sound like “one” in “tone”.</p>
<table>
<thead>
<tr>
<th align="left">Jyutping</th>
<th align="left">Sounds in English</th>
<th align="left">Cantonese Example</th>
<th align="left">Jyutping</th>
<th align="left">Sounds in English</th>
<th align="left">Cantonese Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left">u</td>
<td align="left">oo in foo</td>
<td align="left"><ruby>夫<rp>(</rp><rt>fu1</rt><rp>)</rp></ruby></td>
<td align="left">ut</td>
<td align="left">oot in boot</td>
<td align="left"><ruby>闊<rp>(</rp><rt>fut3</rt><rp>)</rp></ruby></td>
</tr>
<tr>
<td align="left">ui</td>
<td align="left">ewy in chewy<sup>1</sup></td>
<td align="left"><ruby>灰<rp>(</rp><rt>fui1</rt><rp>)</rp></ruby></td>
<td align="left">ung</td>
<td align="left">one in tone</td>
<td align="left"><ruby>風<rp>(</rp><rt>fung1</rt><rp>)</rp></ruby></td>
</tr>
<tr>
<td align="left">un</td>
<td align="left">oon in cartoon</td>
<td align="left"><ruby>歡<rp>(</rp><rt>fun1</rt><rp>)</rp></ruby></td>
<td align="left">uk</td>
<td align="left">ook in cook</td>
<td align="left"><ruby>福<rp>(</rp><rt>fuk1</rt><rp>)</rp></ruby></td>
</tr>
</tbody></table>
<p><sup>1</sup>“Chewy” is two syllables, but in Cantonese this is a diphthong. So try to blend it into one sound, treat the “ew” as the major sound and the “j” as a small tip at the end of the syllable.</p>
<h2 id="Rimes-with-yu"><a href="#Rimes-with-yu" class="headerlink" title="Rimes with yu"></a>Rimes with <code>yu</code></h2><p>Unfortunately, in English there is no word sound exactly as <code>yu</code>.</p>
<p>But you can imitate it by positioning your tongue more forward, closer to your front teeth (not touching them!), and try to say the word “foo”.</p>
<p>In some accents, when people say the word “o<strong>ccu</strong>py” or “e<strong>du</strong>cation”, they may use the <code>yu</code> sound as well.</p>
<table>
<thead>
<tr>
<th align="left">Jyutping</th>
<th align="left">Sounds in English</th>
<th align="left">Cantonese Example</th>
<th align="left">Jyutping</th>
<th align="left">Sounds in English</th>
<th align="left">Cantonese Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left">yu</td>
<td align="left">u in occupy</td>
<td align="left"><ruby>書<rp>(</rp><rt>syu1</rt><rp>)</rp></ruby></td>
<td align="left">yut</td>
<td align="left">uned in tuned</td>
<td align="left"><ruby>雪<rp>(</rp><rt>syut3</rt><rp>)</rp></ruby></td>
</tr>
<tr>
<td align="left">yun</td>
<td align="left">une in tune</td>
<td align="left"><ruby>酸<rp>(</rp><rt>syun1</rt><rp>)</rp></ruby></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>Next lesson: <a href="../canto1-6/">Tones</a></p>
<hr>
<p>Further reading: <a target="_blank" rel="noopener" href="https://jyutping.org/en/">Jyutping</a>, <a target="_blank" rel="noopener" href="https://lshk.org/">The linguistic Society of Hong Kong</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-17T03:02:09.000Z" title="17/12/2024, 04:02:09">2024-12-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.423Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 513 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv7-2-eg/">AGV -- (Exercise 7.2) LTL to Alternating Büchi Automata</a></p><div class="content"><p>Previous Exercise: <a href=""></a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>This is an example exercise to express LTL formula into Alternating Büchi Automata. For further definitions, you may check <a href="../agv7-2/">Section 7.2</a>.</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Use the <a href="../agv7-2/">construction from the lecture</a> to construct an alternating Büchi automaton $\mathcal{A}$ such that $$\mathcal{L(A)&#x3D;L}((\Diamond p)\ \mathcal{U}\ (\square q))$$</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>we build the following alternating Büchi automaton  $\mathcal{A} &#x3D; (2^{p,q},Q,\varphi,\delta,\small\text{BÜCHI} \normalsize(F))$ which recognizes the models of $\varphi&#x3D;(\Diamond p)\ \mathcal{U}\ (\square q)$. First we consider the transition function $\delta$ for an arbitrary symbol $a\in2^{p,q}:$</p>
<p>$\begin{array}{lll}<br>\hspace{1cm}\bullet &amp;&amp;\delta(\square q,a)\newline<br>&amp;&#x3D;&amp;\delta(\neg(\textit{true}\ \mathcal{U}\ \neg q) ,a)\newline<br>&amp;&#x3D;&amp;\overline{\delta(\textit{true}\ \mathcal{U}\ \neg q ,a)}\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)\vee(\delta(\textit{true},a)\wedge(\textit{true}\ \mathcal{U}\ \neg q))}\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\overline{(\delta(\textit{true},a)\wedge (\textit{true}\ \mathcal{U}\ \neg q))}&amp;(\textit{true}\wedge \psi&#x3D;\psi)\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\overline{(\textit{true}\ \mathcal{U}\ \neg q)}&amp;(\text{Using line 1})\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\square q\newline<br>&amp;&#x3D;&amp;\left\lbrace \begin{array}{lll}<br>\square q&amp;\text{if }q\in a\newline<br>\textit{false}&amp;\text{if }q\notin a\newline<br>\end{array}\right.<br>\end{array}<br>\ \newline \ \newline<br>\begin{array}{lll}<br>\hspace{1cm}\bullet &amp;&amp;\delta(\Diamond p,a)\newline<br>&amp;&#x3D;&amp;\delta(\textit{true}\ \mathcal{U}\ p ,a)\newline<br>&amp;&#x3D;&amp;\delta(p,a)\vee(\delta(\textit{true},a)\wedge\Diamond p)&amp;(\textit{true}\wedge \psi&#x3D;\psi)\newline<br>&amp;&#x3D;&amp;\delta(p,a)\vee\Diamond p\newline<br>&amp;&#x3D;&amp;\left\lbrace \begin{array}{lll}<br>\Diamond p&amp;\text{if }p\notin a\newline<br>\textit{true}&amp;\text{if }p\in a\newline<br>\end{array}\right.<br>\end{array}<br>$</p>
<p>By Substitution above result into $\delta((\Diamond p)\ \mathcal{U}\ (\square q),a)&#x3D;\delta(\square q,a)\vee(\delta(\Diamond p,a)\wedge(\Diamond p)\ \mathcal{U}\ (\square q))$, we have:</p>
<p>$$\delta((\Diamond p)\ \mathcal{U}\ (\square q),a)&#x3D;\left\lbrace<br>\begin{array}{lll}<br>\Diamond p\wedge((\Diamond p)\ \mathcal{U}\ (\square q))&amp;\text{if }a &#x3D;\varnothing &amp;(\vee\ \textit{false}\text{ is omitted.})\newline<br>(\Diamond p)\ \mathcal{U}\ (\square q)&amp;\text{if }a &#x3D;\lbrace p\rbrace&amp;(\wedge\ \textit{true}\text{ is omitted.})\newline<br>\square q\vee(\Diamond p\wedge((\Diamond p)\ \mathcal{U}\ (\square q)))&amp;\text{if }a &#x3D;\lbrace q\rbrace\newline<br>\square q\vee((\Diamond p)\ \mathcal{U}\ (\square q))&amp;\text{if }a &#x3D;\lbrace p,q\rbrace&amp;(\wedge\ \textit{true}\text{ is omitted.})\newline<br>\end{array}\right.$$</p>
<p>For each case, when we see $\vee$, that’s a <strong>nondeterministic transitions</strong>, we need draw two seperate transitions for each successors. On the other hand $\wedge$ is a <strong>universal transitions</strong>, it is a single transition towards both successors, we split the extra branches from the path to indicate that. Thus we have the following automaton $\mathcal{A}$:</p>
<p><img src="/images/notes/uds/agv/7_2_eg.png"></p>
<hr>
<p>Next Exercise: <a href="../agv/"></a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-13T04:02:57.000Z" title="13/12/2024, 05:02:57">2024-12-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.440Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 828 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-3/">AGV 10.3 -- Closure Properties of Muller automata Under Boolean Operations</a></p><div class="content"><p>Previous chapter: <a href="../agv10-2/">From Büchi automata to Muller automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now show that deterministic Muller automata are closed, like nondeterministic Büchi automata, under the Boolean operations (<code>complementation</code>, <code>union</code>, and <code>intersection</code>).</p>
<p>First we introduce the construction of these automaton with operations, then we will prove they are close by the runs under those constructions.</p>
<h2 id="Automata-construction-of-Complementation"><a href="#Automata-construction-of-Complementation" class="headerlink" title="Automata construction of Complementation"></a>Automata construction of Complementation</h2><blockquote>
<p>$\textbf{Construction 10.3. } \text{Let }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F}))\text{ be a complete and deterministic Muller}\newline\text{automaton, where we assume w.l.o.g that }Q\neq\varnothing.\text{ We construct the deterministic Muller}\newline\text{automaton }\mathcal{A}^C &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize(2^Q\setminus\mathcal{F}))\text{ with }\mathcal{L(A^C)}&#x3D;\Sigma\setminus\mathcal{L(A)}.$</p>
</blockquote>
<h2 id="Automata-construction-of-Intersection"><a href="#Automata-construction-of-Intersection" class="headerlink" title="Automata construction of Intersection"></a>Automata construction of Intersection</h2><p>We use the function $pr_n$ for $n\in\mathbb{N}$ to project to the (n+1)th component of a arbitrary length tuple, for example:</p>
<ul>
<li>$pr_0(x, y)&#x3D;x$</li>
<li>$pr_1(x, y)&#x3D;y$</li>
<li>$pr_2(x, y),pr_3(x, y),\dots pr_n(x, y) &#x3D;\text{Undefined}$</li>
</ul>
<p>We can also apply the projection to a set and return a <strong>set of components</strong>: $pr_n(S) &#x3D; \bigcup_{s∈S}{pr_n(s)}.$</p>
<blockquote>
<p>$\textbf{Construction 10.4. } \text{For Muller automata }\mathcal{A_1} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F_1}))\text{ and}\newline\mathcal{A_2} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F_2}))\text{ over the same alphabet }\Sigma.\text{ We construct the Muller Automaton}\newline\mathcal{A}_\cap &#x3D; (\Sigma,Q_1\times Q_2,I_1\times I_2,T_\cap,\small\text{MULLER} \normalsize(\mathcal{F_\cap}))\text{ with }\mathcal{L(A_\cap)}&#x3D;\mathcal{L(A_1)}\cap\mathcal{L(A_2)}\text{ and where }\mathcal{A_\cap}\text{ is}\newline\text{deterministic if }\mathcal{A_1}\text{ and }\mathcal{A_2}\text{ are deterministic, as follows:}$</p>
<p>$\begin{array}{l}\hspace{1cm}\cdot \ T_\cap&#x3D;\lbrace((q_1,q_2),\sigma,(q’_1,q’_2))\mid(q_1,\sigma,q’_1)\in T_1,(q_2,\sigma,q’_2)\in T_2\rbrace\newline\hspace{1cm}\cdot \ \mathcal{F}_\cap &#x3D; \lbrace P\subseteq Q_1\times Q_2\mid pr_0(P)\in\mathcal{F_1},pr_1(P)\in\mathcal{F_2}\rbrace\end{array}$</p>
</blockquote>
<h2 id="Closure-Properties-of-under-Boolean-Operations"><a href="#Closure-Properties-of-under-Boolean-Operations" class="headerlink" title="Closure Properties of under Boolean Operations"></a>Closure Properties of under Boolean Operations</h2><blockquote>
<p>$\textbf{Theorem 10.3. } \textit{The languages recognizable by deterministic Muller automata are closed}\newline\textit{under Boolean operations (complementation, union, intersection).}.$</p>
</blockquote>
<h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-complementation"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-complementation" class="headerlink" title="Proof of Deterministic Muller automata are closed under complementation"></a>Proof of Deterministic Muller automata are closed under complementation</h3><p>For a deterministic Muller automaton $\mathcal{A}$, the automaton $\mathcal{A’}$ of Construction 10.3 recognizes the <code>complement</code> language, because any set $F\notin F$ has to be in the <code>complement</code>, i.e., $F\in2^Q\setminus F$.</p>
<h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-Intersection"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-Intersection" class="headerlink" title="Proof of Deterministic Muller automata are closed under Intersection"></a>Proof of Deterministic Muller automata are closed under Intersection</h3><p>For deterministic Muller automata $\mathcal{A_1}$ and $\mathcal{A_2}$, the automaton $\mathcal{A}_\cap$ of Construction 10.4 recognizes the <code>intersection</code>. Let $r_1 &#x3D; q^1_0q^1_1\dots$ and $r_2 &#x3D; q^2_0q^2_1\dots$ be accepting runs of $\mathcal{A_1}$ and $\mathcal{A_2}$ on some $\alpha$. Then $r&#x3D;(r^1_0,r^2_0)(r^1_1,r^2_1)\dots$ is an accepting run of $\mathcal{A}_\cap$ on $\alpha$ and vice versa.</p>
<h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-Union"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-Union" class="headerlink" title="Proof of Deterministic Muller automata are closed under Union"></a>Proof of Deterministic Muller automata are closed under Union</h3><p>It can be proved by <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s laws</a> if they are closed under <code>complement</code> and <code>intersection</code>:</p>
<p>$$\Sigma\setminus(\mathcal{L(A_1)}\cap\mathcal{L(A_2)})&#x3D;(\Sigma\setminus\mathcal{L(A_1)})\cup(\Sigma\setminus\mathcal{L(A_2)})$$</p>
<h2 id="Regular-language-and-Limit-operator"><a href="#Regular-language-and-Limit-operator" class="headerlink" title="Regular language and Limit operator"></a>Regular language and Limit operator</h2><p>Similar to Büchi automata in <a href="../agv4-1/">section 4.1</a>, we can define an $\omega$-regular language from regular language, which is recognizable by deterministic Muller Automata:</p>
<blockquote>
<p>$\textbf{Theorem 10.4. }\textit{An language }L\textit{ is recognizable by a deterministic Muller Automata if and only}\newline\textit{if }L\textit{ is a Boolean combination of langauges }\overrightarrow{W}\textit{ where }W\subseteq\Sigma^*\text{ is regular.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>$”\Leftarrow”$<br>If $W$ is regular, then $\overrightarrow{W}$ is recognizable by a deterministic Büchi automaton. Hence, $\overrightarrow{W}$ is recognizable by a deterministic Muller automaton. Thus, the boolean combination $\mathcal{L}$ is recognizable by a deterministic Muller automaton.</p>
<p>$”\Rightarrow”$<br>A deterministic Muller automaton $\mathcal{A}$ accepts some word $\alpha$ with a unique run $r$ if for some $F\in\mathcal{F}$ we have that $\text{Inf}(r)&#x3D;F$. Thus, there is some $F\in\mathcal{F}$ such that for all $q\in F$ we have that $\alpha\in\overrightarrow{W_q}$ and for all $q\notin F$ we have that $\alpha\notin\overrightarrow{W_q}$, where $\overrightarrow{W_q}&#x3D;\mathcal{L(A_q)}$ for the finite-word automaton $\mathcal{A}_q&#x3D;(\Sigma,Q,I,T,\lbrace q\rbrace)$. Hence,</p>
<p>$$\alpha\in\underset{F\in\mathcal{F}}{\bigcup}\left(\underset{q\in F}{\bigcap}\overrightarrow{W_q}\cap\underset{q\notin F}{\bigcap}(\Sigma^\omega\setminus\overrightarrow{W_q})\right)$$</p>
<hr>
<p>Next chapter: <a href="../agv10-4/">Semi-Deterministic Büchi Automata</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan’s laws</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-12T22:37:22.000Z" title="12/12/2024, 23:37:22">2024-12-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.407Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1264 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv10-2/">AGV 10.2 -- From Büchi automata to Muller automata</a></p><div class="content"><p>Previous chapter: <a href="../agv10-1/">The Muller Acceptance Condition</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>In this section, we want to prove that Muller automata is equivalent to Büchi Automata.</p>
<h2 id="Translate-Buchi-Automata-into-Muller-Automata"><a href="#Translate-Buchi-Automata-into-Muller-Automata" class="headerlink" title="Translate Büchi Automata into Muller Automata"></a>Translate Büchi Automata into Muller Automata</h2><blockquote>
<p>$\textbf{Construction 10.1. } \text{For a (deterministic) Büchi Automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize (F))\newline\text{ we define the (deterministic) Muller automaton } \mathcal{A’} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F}))\text{ using}$</p>
<p>$$\mathcal{F}&#x3D;\lbrace S\subseteq Q\mid S\cap F\neq\varnothing\rbrace$$</p>
</blockquote>
<p>Since the construction does not modify the transitions, the Muller automaton is again deterministic if the Büchi automaton is deterministic. It is straightforward to see that the automata recognize the same language.</p>
<blockquote>
<p>$\textbf{Theorem 10.1. } \textit{For every (deterministic) Büchi automaton }\mathcal{A}\textit{, there is a (deterministic)}\newline\textit{Muller automaton }\mathcal{A’}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A’)}.$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>The automaton $\mathcal{A’}$ of Construction 10.1 complies with our requirements, according to previous section:</p>
<p>$$\small\text{BÜCHI}\normalsize (F)&#x3D;\lbrace\alpha\in Q^\omega\mid\text{Inf}(\alpha)\cap F\neq\varnothing\rbrace&#x3D;\lbrace\alpha\in Q^\omega\mid\text{Inf}(\alpha)\in\mathcal{F}\rbrace&#x3D;\small\text{MULLER}\normalsize(\mathcal{F})$$</p>
<h2 id="Translate-Muller-Automata-into-Buchi-Automata"><a href="#Translate-Muller-Automata-into-Buchi-Automata" class="headerlink" title="Translate Muller Automata into Büchi Automata"></a>Translate Muller Automata into Büchi Automata</h2><p>A slightly more difficult construction is to translate the Muller automaton back into a Büchi automaton.</p>
<blockquote>
<p>$\textbf{Construction 10.2. } \text{Let }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\lbrace F_1,\dots,F_n\rbrace))\text{ be a Muller automaton}\newline\text{and }&lt;\text{ some arbitrary total order on }Q.\text{ We construct the Büchi automaton }\mathcal{A’} &#x3D; (\Sigma,Q’,\newline I’,T’,\small\text{BÜCHI} \normalsize(F’))\text{ with }\mathcal{A’}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A’)}\text{ as follows:}$</p>
<p>$\begin{array}{llll}<br>\hspace{1cm} \cdot \ Q’&amp;&#x3D;Q\cup\overset{n}{\underset{i&#x3D;1}{\bigcup}}(\lbrace i\rbrace\times F_i\times F_i)\newline<br>\hspace{1cm} \cdot \ I’&amp;&#x3D;I\newline<br>\hspace{1cm} \cdot \ T’&amp;&#x3D;T\cup\lbrace(q,\sigma,(i,q’,q’))\mid 1\leq i\leq n,(q,\sigma,q’)\in T, q’\in F_i\rbrace\newline<br>&amp;\hspace{0.9cm}{}\cup\lbrace((i,q,p),\sigma,(i,q’,p’))\mid 1\leq i\leq n,(q,\sigma,q’)\in T,\newline<br>&amp;\hspace{1.5cm}p’&#x3D;\left\lbrace\begin{array}{ll} p &amp;\text{if } q\neq p\newline<br>\text{min}(F_i)&amp;\text{if } q&#x3D;p&#x3D;\text{max}(F_i)\newline<br>\text{min}(F_i\setminus\lbrace r\mid r\leq p\rbrace)&amp;\text{if } q&#x3D;p&lt;\text{max}(F_i),\end{array}\right.\newline&amp;\hspace{1.5cm}q,p,q’ \in F_i\rbrace\newline<br>\hspace{1cm} \cdot \ F’&amp;&#x3D;\overset{n}{\underset{i&#x3D;1}{\bigcup}}(\lbrace i\rbrace\times \lbrace\text{min}(F_i)\rbrace\times \lbrace\text{min}(F_i)\rbrace)\newline<br>\end{array}$</p>
</blockquote>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>A run of the Büchi automaton first simply simulates (while in states $Q$) the Muller automaton and then “guesses” the accepting subset of the Muller automaton. The accepting subset is express by the states $(\lbrace i\rbrace\times F_i\times F_i)$, where</p>
<ul>
<li>The first component &#x3D; the <strong>index</strong> $i$ of the accepting subset,</li>
<li>The second component &#x3D; the <strong>currently visited state</strong> of the Muller automaton, and</li>
<li>The third component &#x3D; the <strong>“next” state</strong> (according to the order on the states) we need to see in order to make progress towards accepting the input word.</li>
</ul>
<p>The purpose of the order $&lt;$ on the states is that we can “step” through the states of the accepting subset in order to make sure that all states in the accepting subset actually occur infinitely often. In transitions $T’$, we have the transitions</p>
<ul>
<li><p>Transitions for all states $Q$ are described by $T$, same as in the original Muller Automaton,</p>
</li>
<li><p>Transitions that contains both states in $Q$ and accepting subset $(\lbrace i\rbrace\times F_i\times F_i)$, it stays in the subset,</p>
</li>
<li><p>Transitions inside the subset,</p>
<ul>
<li>the <strong>“next” state</strong> remain unchanged until the <strong>currently visited state</strong> visits it $(p&#x3D;q)$,</li>
<li>if the <strong>currently visited state</strong> visits <strong>“next” state</strong> and it is the last “step” of the subset, it means we visited the entire subset $F_i$ and we should start from the beginning $\text{min}(F_i)$ again.</li>
<li>otherwise, move one step ahead ($p’ &gt; p$ and $p, p’\in F_i$)</li>
</ul>
</li>
</ul>
<p><strong>The Büchi automaton accepts if we step through the states of the accepting subset infinitely often</strong>.<br>Recall that we used a similar trick in the construction of the Büchi automaton for the <code>intersection</code> of two Büchi-recognizable languages in <a href="../agv3-3/">Construction 3.2.</a></p>
<blockquote>
<p>$\textbf{Theorem 10.2. } \newline\textit{For every Muller automaton }\mathcal{A}\textit{ there is a Büchi automaton }\mathcal{A’}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A’)}.$</p>
</blockquote>
<h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><blockquote>
<p>$\mathcal{L(A)}\subseteq\mathcal{L(A’)}$ (all word accepted by $\mathcal{L(A)}$ must also be accepted by $\mathcal{L(A’)}$):</p>
</blockquote>
<p>Let $\alpha\in\mathcal{L(A)}$ and $r&#x3D;q_0q_1q_2\dots$ be an <strong>accepting</strong> run of $\mathcal{A}$ on $\alpha$. As $r$ is accepting, we have that:</p>
<ul>
<li><p>$\text{Inf}(r)\in\mathcal{F}$, so $r$ must be in one of the accepting subset, i.e. $\text{Inf}(r)&#x3D;F_i$ for some $1\leq i\leq n$,</p>
</li>
<li><p>Let $m$ be the first position that visit some accepting state: $q_j\in\text{Inf}(r)$ for all $j\geq m$,</p>
</li>
<li><p>Now consider some run of $\mathcal{A’}$ on $\alpha:\ r’ &#x3D; q_0q_1\dots q_{m−1}(i, q_m, p_0)(i, q_{m+1}, p_1)(i, q_{m+2}, p_2)\dots$</p>
<ul>
<li>it nondeterministically switches to $(i, q_m, p_0)$ at position $m$.</li>
</ul>
</li>
</ul>
<p>For the sake of contradiction, assume that $r$ is <strong>not accepting</strong>:</p>
<ul>
<li>Then there is a position $k\geq 0$ such that $p_j&#x3D;p_k$ for all $j\geq k$ ($q$ never moves to $p_k$,<strong>“next” state</strong> got stuck).</li>
<li>Then also $q_{m+j}\neq p_j$ for all $j\geq k$. However, this contradicts that $p_k\in F_i$.<br>(if q can never reach $p_k$, then it is not an accepting state and thus contradicts with the definition of the subset)</li>
</ul>
<blockquote>
<p>$\mathcal{L(A)}\supseteq\mathcal{L(A’)}$ (all word accepted by $\mathcal{L(A’)}$ must also be accepted by $\mathcal{L(A)}$):</p>
</blockquote>
<p>Let $\alpha\in\mathcal{L(A’)}$, $r’ &#x3D; q_0q_1\dots q_{m−1}(i, q_m, p_0)(i, q_{m+1}, p_1)(i, q_{m+2}, p_2)\dots$ be some accepting run of $\mathcal{A’}$ on $\alpha$:</p>
<ul>
<li>At some position $m$ it switches to some $(i, q_m, p_0)$, otherwise it would not be accepting.</li>
<li>By construction, $q_j\in\text{Inf}(r)$ for all $j\geq m$ (it starts staying in the accepting subset), and</li>
<li>For each $p\in F_i$ there are infinitely many positions $k$ such that $q_k&#x3D;p_k&#x3D;p$.<ul>
<li>($q$ always reach every <strong>“next” state</strong> infinitely often at some positions)</li>
</ul>
</li>
</ul>
<p>Thus, we can construct an accepting run $r&#x3D;q_0q_1q_2\dots$ of $\mathcal{A}$ on $\alpha$ by using every $q$ state in the run $r’$, because every second component in the tuple is accepting, i.e. $\text{Inf}(pr_2(r’))&#x3D;p_k&#x3D;F_i$,</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Now we have proved that we can construct an Muller automaton from Büchi automaton and an Büchi automaton from Muller automaton. Therefore they are interchangably equivalent. In the next section, we will prove that deterministic Muller automata are actually closed.</p>
<hr>
<p>Next chapter: <a href="../agv10-3/">Closure Properties of Muller Automata under Boolean Operations</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">Previous</a></div><div class="pagination-next"><a href="/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>