<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-12-01T02:08:48.000Z" title="01/12/2024, 03:08:48">2024-12-01</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.418Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 850 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv7-2/">AGV 7.2 -- From LTL to Alternating Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv7-1/">Alternating Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>It is usually much simpler to translate a logical formula into an alternating automaton than into a nondeterministic automaton. We illustrate this with the translation of LTL formulas into equivalent alternating Büchi automata. The states are simply the subformulas of the given formula and their negations (this set is called the <em>closure</em> of the formula). The transition function is derived from the <em>expansion laws</em> of the logic.</p>
<p>For example, an <code>Until</code> formula $\varphi_1\ \mathcal{U}\ \varphi_2$ holds if:</p>
<ul>
<li>$\varphi_2$ holds <strong>or</strong></li>
<li>$\varphi_1$ holds <strong>and</strong> the entire formula holds in the next step.</li>
</ul>
<p>The boolean formula produced by the transition function from the state $\varphi_1\ \mathcal{U}\ \varphi_2$ is therefore:</p>
<ul>
<li>a <code>disjunction</code> $(\wedge)$ between the transition function for $\varphi_2$ and</li>
<li>a <code>conjunction</code> $(\vee)$ between the transition function for $\varphi_1$ and the state $\varphi_1\ \mathcal{U}\ \varphi_2$.</li>
</ul>
<h2 id="From-LTL-to-Alternating-Automata"><a href="#From-LTL-to-Alternating-Automata" class="headerlink" title="From LTL to Alternating Automata"></a>From LTL to Alternating Automata</h2><blockquote>
<p>$\textbf{Construction 7.1. }\text{Let }\varphi\text{ be an LTL formula. We construct the alternating Büchi automaton }\newline\mathcal{A_\varphi}&#x3D;(\Sigma,Q,\varphi,\delta,\small\text{BÜCHI} \normalsize(F))\text{ using:}$<br>$\begin{array}{ll}<br>\hspace{0.5cm} \cdot \ Q &#x3D; \text{closure}(\varphi):&#x3D;\lbrace\psi,\neg\psi\mid\psi\text{ is subformula of }\varphi\rbrace \newline<br>\hspace{0.5cm} \cdot \ \delta(p,a)&#x3D;  \left\lbrace \begin{array}{ll}\textit{true}&amp;\text{if }p\in a\newline \textit{false}&amp;\text{if }p\not\in a\end{array}\right. &amp;\cdot \ \delta(\neg\psi,a)&#x3D;\overline{\delta(\psi,a)}\newline<br>\hspace{0.5cm} \cdot \ \delta(\psi_1\wedge\psi_2,a)&#x3D;\delta(\psi_1,a)\wedge\delta(\psi_2,a) &amp;\cdot \ \delta(\psi_1\vee\psi_2,a)&#x3D;\delta(\psi_1,a)\vee\delta(\psi_2,a)\newline<br>\hspace{0.5cm} \cdot \ \delta(\psi_1\ \mathcal{U}\ \psi_2,a)&#x3D;\delta(\psi_2,a)\vee(\delta(\psi_1,a)\wedge\psi_1\ \mathcal{U}\ \psi_2)&amp;\cdot \ \delta(\bigcirc\psi,a)&#x3D;\psi\newline<br>\hspace{0.5cm} \cdot \ F &#x3D; \lbrace\neg(\psi_1\ \mathcal{U}\ \psi_2)\in\text{clousure}(\varphi)\rbrace<br>\end{array}\newline$<br>$\text{where we define }\overline{\varphi}&#x3D;\neg\varphi\text{ for all other }\psi\in Q\text{ and }\overline{\ \cdot\ }\text{ for }\psi,\psi_1,\psi_2\in Q\text{ via:}$<br>$\begin{array}{ll}<br>\hspace{0.5cm} \cdot \ \overline{\neg\varphi}&#x3D;\varphi<br>\hspace{0.5cm} \cdot \ \overline{\psi_1\wedge\psi_2}&#x3D;\overline{\psi_1}\vee\overline{\psi_2}<br>\hspace{0.5cm} \cdot \ \overline{\psi_1\vee\psi_2}&#x3D;\overline{\psi_1}\wedge\overline{\psi_2}<br>\hspace{0.5cm} \cdot \ \overline{\textit{true}}&#x3D;\overline{\textit{false}}<br>\hspace{0.5cm} \cdot \ \overline{\textit{false}}&#x3D;\overline{\textit{true}}<br>\end{array}$</p>
</blockquote>
<h2 id="Explanation-and-Examples-in-Human-language"><a href="#Explanation-and-Examples-in-Human-language" class="headerlink" title="Explanation and Examples in Human language"></a>Explanation and Examples in Human language</h2><p>Remember that $\delta$ function returns <em>set of states</em>.</p>
<p>As we can see most of the function here don’t actually have a designated successor except for <strong>atomic proposition</strong> $p$, <strong>neXt</strong> $\bigcirc$, and <strong>Until</strong> $\mathcal{U}$.</p>
<p>For example, here are simple steps to construct a automaton for a formula $p\wedge\bigcirc q$:</p>
<ol>
<li><p>List of all possible atomic propositions input: $\sigma&#x3D;\lbrace\lbrace\varnothing\rbrace,\lbrace p\rbrace,\lbrace q\rbrace,\lbrace p,q\rbrace\rbrace$</p>
</li>
<li><p>Write a truth table basic on the formula and its corresponding function $\delta$:<br>$\ \newline\hspace{1cm}\delta(p\wedge\bigcirc q,\sigma) &#x3D; \delta(p,\sigma)\wedge\delta(\bigcirc q,\sigma)&#x3D;\delta(p,\sigma)\wedge q<br>\newline\ \newline<br>\hspace{1cm}\cdot \ \delta(\bigcirc q,\sigma)&#x3D;\left\lbrace \begin{array}{ll}<br>q&amp;\text{if }\sigma&#x3D;\lbrace\varnothing\rbrace,\lbrace q\rbrace,\lbrace p\rbrace,\lbrace p,q\rbrace\end{array} \right. \newline\ \newline<br>\hspace{1cm}\cdot \ \delta(p,\sigma)&#x3D;\left\lbrace\begin{array}{ll}<br>\textit{false}&amp;\text{if }\sigma&#x3D;\lbrace\varnothing\rbrace,\lbrace q\rbrace\newline<br>\textit{true}&amp;\text{if }\sigma&#x3D;\lbrace p\rbrace,\lbrace p,q\rbrace\end{array}\right.<br>\hspace{1cm}\cdot \ \delta(q,\sigma)&#x3D;\left\lbrace\begin{array}{ll}<br>\textit{false}&amp;\text{if }\sigma&#x3D;\lbrace\varnothing\rbrace,\lbrace p\rbrace\newline<br>\textit{true}&amp;\text{if }\sigma&#x3D;\lbrace q\rbrace,\lbrace p,q\rbrace\end{array}\right.<br>\newline\ \newline\hspace{1cm}\therefore\ \delta(p\wedge\bigcirc q,\sigma)&#x3D;\left\lbrace\begin{array}{ll}<br>\textit{false}\wedge q &#x3D; \textit{false}&amp;\text{if }\sigma&#x3D;\lbrace\varnothing\rbrace,\lbrace q\rbrace\newline<br>\textit{true}\wedge q &#x3D; q&amp;\text{if }\sigma&#x3D;\lbrace p\rbrace,\lbrace p,q\rbrace\end{array}\right.<br>$</p>
</li>
<li><p><strong>Initial state</strong> is always the orginal formula, then we add extra state according to the truth table we constructed. Here, our graph have no <strong>universal</strong> or <strong>nondeterministic</strong> transitions:</p>
</li>
</ol>
<p><img src="/images/notes/uds/agv/7_2_next.png"></p>
<p>For a more complicated example, i.e. $((\Diamond p)\ \mathcal{U}\ (\square q))$, check <a href="../agv7-2-eg/">here</a> as an extra material</p>
<blockquote>
<p>$\textbf{Theorem 7.1. } \textit{For every LTL formula }\varphi\textit{, there is an alternating Büchi automaton }\mathcal{A_\varphi}\newline\textit{with }\mathcal{L(A_\varphi)} &#x3D; \mathcal{L(\varphi)}.$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We can simply prove this by induction. First, any LTL formula $\varphi$ can be recursively seperate into smaller subformula, namely $\psi$.</p>
<p>Similarly we can construct automaton $\mathcal{A^\psi_\varphi}$ from $\mathcal{A_\varphi}$ according to above construction 7.1. By structural induction on $\psi$, we can then prove that $\mathcal{L(A^\psi_\varphi)&#x3D;L(A_\varphi)}$.</p>
<hr>
<p>Next chapter: <a href="../agv7-3/">Translating Alternating to Nondeterministic automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-30T01:25:22.000Z" title="30/11/2024, 02:25:22">2024-11-30</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.418Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 953 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv7-1/">AGV 7.1 -- Alternating Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv6-7/">S1S$_0$ and Büchi-recognizable Language</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Logics are often significantly more concise than automata. For example, in the translation from S1S to Büchi automata in the proof of <a href="../agv6-7/">Theorem 6.4</a>, each negation increases the size of the Büchi automaton exponentially, resulting in a non-elementary number of states. The blow-up when translating LTL formulas is less dramatic, but still exponential. In this section, we show that the conciseness of the logic and the automata can be brought closer together when the automata are equipped with both <strong>nondeterministic</strong> and <strong>universal</strong> choices.</p>
<h2 id="Alternating-Automata"><a href="#Alternating-Automata" class="headerlink" title="Alternating Automata"></a>Alternating Automata</h2><h3 id="Nondeterministic-and-Universal"><a href="#Nondeterministic-and-Universal" class="headerlink" title="Nondeterministic and Universal"></a>Nondeterministic and Universal</h3><p>In previous sections, we discussed a lot about <strong>Nondeterministic</strong> transitions. Here we introduce a new concept <strong>Universal</strong> transitions for our new automaton called alternating automaton. We allow for both types of choices by defining, for each state and input letter, a <strong>positive Boolean formula</strong> over the successor states.</p>
<table>
<thead>
<tr>
<th align="left">Choices</th>
<th align="left">Symbol</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Nondeterministic</strong></td>
<td align="left">disjunction $(\vee)$</td>
<td align="left">the suffix of an input word is <strong>accepted by SOME</strong> successor state</td>
</tr>
<tr>
<td align="left"><strong>Universal</strong></td>
<td align="left">conjunction $(\wedge)$</td>
<td align="left">the suffix of an input word is <strong>accepted by ALL</strong> successor states</td>
</tr>
</tbody></table>
<h3 id="Positive-Boolean-Formulas-mathbb-B-X"><a href="#Positive-Boolean-Formulas-mathbb-B-X" class="headerlink" title="Positive Boolean Formulas $\ \mathbb{B}^+(X)$"></a>Positive Boolean Formulas $\ \mathbb{B}^+(X)$</h3><blockquote>
<p>$\textbf{Definition 7.1. } \text{The }\textit{positive Boolean formulas }\text{over a set }X\text{, denoted }\mathbb{B}^+(X)\text{, are the formulas}\newline\text{built from elements of }X\text{, conjunction }\wedge\text{, disjunction }\vee,\textit{ true}\text{ and }\textit{false.}$</p>
</blockquote>
<p>In our automata construction, elements of $X$ will be <strong>states</strong>. Let say we have a set of states $Y\subseteq X$.<br>We denote $Y\models\varphi$ if $Y$ satisfies a formula $\varphi\in\mathbb{B^+}(X)$. In other words:</p>
<ul>
<li>all states in $Y$ will be assigned as $\textit{true}$ by $\varphi$, and</li>
<li>all states in $X\setminus Y$ will be assigned as $\textit{false}$ by $\varphi$.</li>
</ul>
<h3 id="Trees-and-Runs"><a href="#Trees-and-Runs" class="headerlink" title="Trees and Runs"></a>Trees and Runs</h3><blockquote>
<p>$\textbf{Definition 7.2. } \text{ An } \textit{Alternating automaton over infinite words }\mathcal{A}\newline\text{ is a tuple }\mathcal{A} &#x3D; (\Sigma,Q,q_0,\delta,Acc)\text{, where}\newline\begin{array}{ll}<br>\hspace{1cm} \cdot \ Q &amp;\text{ is a finite set of states} \newline<br>\hspace{1cm} \cdot \ q_0 \in Q&amp; \text{ is the initial states} \newline<br>\hspace{1cm} \cdot \ \delta:Q\times\Sigma\rightarrow\mathbb{B^+}(Q)&amp; \text{ is the } \textit{transition functions}\text{, and} \newline<br>\hspace{1cm} \cdot \ Acc \subseteq Q^\omega&amp; \text{ is an accepting condition.}<br>\end{array}$</p>
</blockquote>
<p>For alternating automata, runs generalize from sequences to <strong>trees</strong>. Here we define a tree as a <strong>prefix-closed subset</strong>, guarantees that all nodes must be able to trace all the back the <strong>root</strong> of the tree.</p>
<blockquote>
<p><strong>prefix-closed subset</strong>:<br>If a word $w&#x3D;\lbrace ab\rbrace^\omega$ is in the set, then all its prefix (i.e. $\lbrace ab\rbrace,\lbrace aba\rbrace,\lbrace abab\rbrace,\dots$) must also be in the set.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Symbol&#x2F;Functions</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Set of Squences</strong></td>
<td align="left">$D^\ast$</td>
<td align="left">All possible sequence of every word by direction $D$</td>
</tr>
<tr>
<td align="left"><strong>Set of Directions</strong></td>
<td align="left">$D$</td>
<td align="left">Branches possible in each node</td>
</tr>
<tr>
<td align="left"><strong>Tree</strong></td>
<td align="left">$\mathcal{T}$</td>
<td align="left">Sequence of ONE word, a prefix-closed subset of $D^*$</td>
</tr>
<tr>
<td align="left"><strong>Root</strong></td>
<td align="left">$\varepsilon$</td>
<td align="left">The Empty Sequence</td>
</tr>
<tr>
<td align="left"><strong>Node</strong></td>
<td align="left">$n\in\mathcal{T}$</td>
<td align="left">Depends on the label, it may be the states or the letters</td>
</tr>
<tr>
<td align="left"><strong>Children of $n$</strong></td>
<td align="left">$\text{children}(n)&#x3D;\lbrace n\cdot d\in \mathcal{T}\mid d\in D\rbrace$</td>
<td align="left">Succssor states of $n$ over direction $d$</td>
</tr>
<tr>
<td align="left"><strong>$Q$-labeled tree</strong></td>
<td align="left">$(\mathcal{T},\ell)$</td>
<td align="left">A tree that labels nodes with the states</td>
</tr>
<tr>
<td align="left"><strong>$\Sigma$-labeled tree</strong></td>
<td align="left">$(\mathcal{T},\ell)$</td>
<td align="left">A tree that labels nodes with the input letters</td>
</tr>
<tr>
<td align="left"><strong>Labeling Function</strong></td>
<td align="left">$\ell:\mathcal{T}\rightarrow\Sigma$</td>
<td align="left">Label each node of the tree with the input letters for $\Sigma$-labeled tree</td>
</tr>
</tbody></table>
<p>Below, we define a <strong>run</strong> of an alternating autoamton using <strong>$Q$-labeled tree</strong>:</p>
<blockquote>
<p>$\textbf{Definition 7.3. } \text{ A } \textit{run }\text{of an alternating automaton on a word }\alpha\in\Sigma^\omega\newline\text{ is a Q-labeled tree (T , r) with the following properties:}\newline<br>\begin{array}{l}<br>\hspace{1cm} \cdot \ r(\varepsilon)&#x3D;q_0\text{ and}\newline<br>\hspace{1cm} \cdot \ \text{for all }n\in\mathcal{T}\text{, if }r(n)&#x3D;q\text{, then }\lbrace r(n’)\mid n’\in\text{children}(n)\rbrace\ \text{ satisfies }\delta(q,\alpha(|n|)).<br>\end{array}$</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>The following alternating Büchi automaton recognizes the language $L&#x3D;((a+b)^\ast b)^\omega$. Universal choice $(\wedge)$ are depicted by connecting the edges with a small arc $(\blacksquare)$. The transition function $(\delta)$ is given as follows:</p>
<ul>
<li>$\delta(p,a)&#x3D;p\wedge q$,</li>
<li>$\delta(p,b)&#x3D;p$,</li>
<li>$\delta(q,a)&#x3D;q$,</li>
<li>$\delta(q,b)&#x3D;\textit{true}$.</li>
</ul>
<p><img src="/images/notes/uds/agv/7_1_alt.png"></p>
<p>On the input word $\alpha&#x3D;(aab)^\omega$, our automaton has the following run. Note that, in general, an alternating automaton may have more than one run on a particular word, or also no run at all. We use a <strong>dotted line</strong> to indicate that the subtree repeats infinitely often.</p>
<p><img src="/images/notes/uds/agv/7_1_tree.png"></p>
<p>Similar to DAG, we can apply the <strong>acceptance condition</strong> only on <strong>all infinite branches</strong> of the run tree. A <em>branch</em> of a tree $\mathcal{T}$ is a <strong>maximal sequence</strong> of words $n_0n_1n_2\dots$ such that $n_0&#x3D;\varepsilon$ and $n_{i+1}$ is a child of $n_i$ for $i\geq0$.</p>
<p>Obviously, if every infinite branch is accepting, then the entire tree is thus accepting, i.e. there’s no way to pick a non-accepting path for to be the run.</p>
<blockquote>
<p>$\textbf{Definition 7.4. } \text{A run }(\mathcal{T},r)\text{ is }\textit{accepting }\text{iff, for every infinite branch }n_0n_1n_2\dots,$<br>$$r(n_0)r(n_1)r(n_2)\dots\in Acc.$$</p>
</blockquote>
<hr>
<p>Next chapter: <a href="../agv7-2/">From LTL to Alternating Büchi Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-28T23:36:06.000Z" title="29/11/2024, 00:36:06">2024-11-29</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.418Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1063 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-7/">AGV 6.7 -- S1S$_0$ and Büchi-recognizable Language</a></p><div class="content"><p>Previous chapter: <a href="../agv6-6/">Express QPTL using S1S</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>To prepare for the proof that every S1S-definable language is Büchi-recognizable, we show in the following lemma that we can focus on a restricted sublogic, called S1S$_0$, which is defined by the following grammar:</p>
<p>$$\varphi::&#x3D;0\in X\mid x\in Y\mid x&#x3D;0\mid x&#x3D;y\mid x&#x3D;S(y)\mid \neg\varphi\mid\varphi\wedge\varphi\mid\exists x.\varphi\mid\exists X.\varphi$$</p>
<ul>
<li><strong>Membership tests</strong> $(\in)$: variables $(x,y,\dots)$ and $0$ only</li>
<li><strong>Equalities</strong> $(&#x3D;)$: variables $(x,y,\dots)$, $0$ and a <strong>single</strong> successor operation $(S(t))$ only<ul>
<li>i.e. $S(S(t))$ is not allowed.</li>
</ul>
</li>
</ul>
<p>Complex formula in S1S can then be simplified by introducing additional variables.</p>
<h2 id="From-S1S-to-S1S-0"><a href="#From-S1S-to-S1S-0" class="headerlink" title="From S1S to S1S$_0$"></a>From S1S to S1S$_0$</h2><blockquote>
<p>$\textbf{Lemma 6.1. } \textit{For every S1S formula }\varphi\textit{ there is an S1S}_0\text{ formula }\varphi’\textit{ such that }\mathcal{L}(\varphi)&#x3D;\mathcal{L}(\varphi’).$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We rewrite a given S1S formula $\varphi$ into the S1S$_0$ formula $\varphi$’ using the following rewrite rules:</p>
<table>
<thead>
<tr>
<th align="left">S1S</th>
<th align="left">S1S_0</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$S(t)\in X$</td>
<td align="left">$\exists y. y&#x3D;S(t)\wedge y\in X$</td>
<td align="left">only $0$ and <code>First-order variable</code> $(x,y,\dots)$ is allowed on the L.H.S of $\in$</td>
</tr>
<tr>
<td align="left">$0&#x3D;x$</td>
<td align="left">$x&#x3D;0$</td>
<td align="left"><code>First-order variable</code> has higher priority than $0$</td>
</tr>
<tr>
<td align="left">$S(t)&#x3D;0$</td>
<td align="left">$0&#x3D;S(t)$</td>
<td align="left">successor operation not allowed on L.H.S</td>
</tr>
<tr>
<td align="left">$S(t)&#x3D;x$</td>
<td align="left">$x&#x3D;S(t)$</td>
<td align="left">successor operation not allowed on L.H.S</td>
</tr>
<tr>
<td align="left">$S(t)&#x3D;S(t’)$</td>
<td align="left">$t&#x3D;t’$</td>
<td align="left">successor operation not allowed on L.H.S</td>
</tr>
<tr>
<td align="left">$0&#x3D;0$</td>
<td align="left">$\exists Y.0\in Y\vee0\notin Y$</td>
<td align="left">only accept the form $x&#x3D;0$</td>
</tr>
<tr>
<td align="left">$0&#x3D;S(t)$</td>
<td align="left">$\exists y.y&#x3D;S(t)\wedge y&#x3D;0$</td>
<td align="left">only accept the form $x&#x3D;0$ or $x&#x3D;S(y)$</td>
</tr>
<tr>
<td align="left">$t&#x3D;S(0)$</td>
<td align="left">$\exists x.x&#x3D;0\wedge t&#x3D;S(x)$</td>
<td align="left">only accept the form $x&#x3D;S(y)$</td>
</tr>
<tr>
<td align="left">$t&#x3D;S(S(t’)$</td>
<td align="left">$\exists y.y&#x3D;S(t’)\wedge t&#x3D;S(y)$</td>
<td align="left">only allow one successor operation</td>
</tr>
</tbody></table>
<h2 id="From-S1S-definable-to-Buchi-recognizable"><a href="#From-S1S-definable-to-Buchi-recognizable" class="headerlink" title="From S1S-definable to Büchi-recognizable"></a>From S1S-definable to Büchi-recognizable</h2><blockquote>
<p>$\textbf{Theorem 6.4. } \textit{Every S1S-definable language is Büchi-recognizable.}$</p>
</blockquote>
<h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><p>Let $\varphi$ be an S1S-formula. We construct a Büchi automaton $\mathcal{A}$ with $\mathcal{L}(\varphi)&#x3D;\mathcal{L}(\mathcal{A})$.</p>
<ul>
<li>Step 1: We begin by translating $\varphi$ into an equivalent S1S$_0$ according to the above Lemma 6.1.</li>
<li>Step 2: Express every basic S1S$_0$ formula from the grammar above using Büchi automaton.</li>
</ul>
<p>Remember in <a href="../agv6-6/">last section</a>, when we translate QPTL to S1S, we defined <code>Second-order variable</code> $X$ as atomic proposition of QPTL. Here same definitions continue:</p>
<p>First of all, <strong>$A$ is the set of atomic propositions $(A\subseteq AP)$ which is avaliable in the current state</strong>. For example, in state $q_2$, $A &#x3D; \lbrace X,Y\rbrace$, where $AP &#x3D; \lbrace X,Y,Z\rbrace$. Which means in $q_2$ there exists transitions only when proposition $X$ or $Y$ is $\textit{true}$.</p>
<p>Then, words are defined as a sequence containing atomic propositions. For example, a possible structure for word $\alpha$ may look like this: $$\alpha&#x3D;\lbrace XYYXXYY\dots\rbrace$$</p>
<p>Finally, our <a href="../agv6-5/">definition</a> of <code>Second-order variable</code> is <strong>set of positions</strong>, and <code>First-order variable</code> are the <strong>positions</strong>. The relationship between proposition and variables in S1S is essentially $\alpha[x] &#x3D; X$, where $x$ is some <code>First-order variable</code> and $X$ is some <code>Second-order variable</code>.</p>
<p>We can also use the S1S way to interpret, that proposition $X$ holds $\textit{true}$ in position x and y, i.e. $X&#x3D;\lbrace x,y\rbrace$.</p>
<p>Therefore, when we see transitions like $\lbrace A\mid X\in A\rbrace$, it means if $X$ is part of the avaliable propositions for the current state and holds in certain letter(position), then the automata can take this transition as a path. (Here the position is not specified, will see more examples below)</p>
<ol>
<li><p>$0\in X$: This statement holds $\textit{true}$ iff. theres a word that contains $X$ in zero position.<br><img src="/images/notes/uds/agv/6_7_0inX.png"></p>
</li>
<li><p>$x\in Y$: This statement holds $\textit{true}$ iff. theres a word that contains $Y$ in $x$ position.<br><img src="/images/notes/uds/agv/6_7_xinY.png"></p>
</li>
<li><p>$x&#x3D;0$: This statement holds $\textit{true}$ iff. the word exist some propositions that only holds $\textit{true}$ in $x$-th position, assign $x$ as $0$.<br><img src="/images/notes/uds/agv/6_7_x=0.png"></p>
</li>
<li><p>$x&#x3D;y$: This statement holds $\textit{true}$ iff. the word exist some propositions that only holds $\textit{true}$ in $x$-th and $y$-th position, which are indeed the same.<br><img src="/images/notes/uds/agv/6_7_x=y.png"></p>
</li>
<li><p>$x&#x3D;S(y)$: This statement holds $\textit{true}$ iff. the word exist some propositions that only holds $\textit{true}$ in $x$-th and $y$-th position, where $x$ and $y$ are different and $x$ is the next position after $y$.<br><img src="/images/notes/uds/agv/6_7_x=S(y).png"></p>
</li>
<li><p>$\varphi\wedge\psi$: Let $\mathcal{A_\varphi}$ and $\mathcal{A_\psi}$ be the automata constructed for $\varphi$ and $\psi$, respectively. We obtain the automaton $\mathcal{A}_{\varphi\wedge\psi}$ by constructing the automaton that recognizes the intersection of $\mathcal{L(A_\varphi)}$ and $\mathcal{L(A_\psi)}$.<br>Below is the example of $0\in X \wedge x \in Y$:<br><img src="/images/notes/uds/agv/6_7_and.png"></p>
</li>
<li><p>$\neg\varphi$: let $\mathcal{A_{\varphi}}$ be the automaton constructed for $\varphi$. We obtain the automaton $\mathcal{A_{\neg\varphi}}$ by first constructing the automaton that recognizes the complement of $\mathcal{L(A_{\varphi})}$ and then intersecting it with $A_x$ for each <strong>free</strong> <code>first-order variable</code> $x$, which ensures that $x$ appears exactly once. Below we use $\neg(x\in Y)$ as an example:<br><img src="/images/notes/uds/agv/6_7_neg.png"><br>Notice that $(\lbrace x,Y\rbrace\subseteq A)\wedge(x\in A)&#x3D;\lbrace x,Y\rbrace\subseteq A$:<br><img src="/images/notes/uds/agv/6_7_notphi.png"></p>
</li>
<li><p>$\exists X.\varphi$: Let $\mathcal{A_{\varphi}}$ be the automaton constructed for $\varphi$. We obtain the automaton $\mathcal{A}_{\exists X. \varphi}$ for by eliminating $X$ from the input alphabet, i.e., we replace each transition $(q,A,q’)$ by $(q,A\setminus\lbrace X\rbrace,q’)$.<br>(Because the Büchi-recognizable Language only contains the set of <strong>free</strong> atomic propositions)</p>
</li>
<li><p>$\exists x. \varphi$: Similarly, we replace each transition $(q,A,q’)$ by $(q,A\setminus\lbrace x\rbrace,q’)$.</p>
</li>
</ol>
<hr>
<p>Next chapter: <a href="../agv7-1/">Alternating Büchi Automata</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-28T22:45:21.000Z" title="28/11/2024, 23:45:21">2024-11-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.423Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 461 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-6/">AGV 6.6 -- Express QPTL using S1S</a></p><div class="content"><p>Previous chapter: <a href="../agv6-5/">Monadic Second-Order Logic of One Successor (S1S)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We already showed, in <a href="../agv6-4/">Theorem 6.2</a>, that every Büchi-recognizable language is QPTL-definable. We now complete a full circle by showing that every QPTL-definable language is S1S-definable, and that every S1S-definable language is Büchi-recognizable. <strong>Hence, QPTL, S1S, and Büchi automata are equally expressive.</strong></p>
<blockquote>
<p>$\textbf{Theorem 6.3. } \textit{Every QPTL-definable language is S1S-definable.}$</p>
</blockquote>
<h2 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h2><p>In <a href="../agv6-4/">section 6.4</a>, we defined the language of QPTL as: $\mathcal{L}(\varphi)&#x3D;\lbrace\alpha\in{(2^{AP’})}^{\omega}\mid\alpha\models\varphi\rbrace$, and</p>
<p>In <a href="../agv6-5/">section 6.5</a>, we defined the language of S1S as: $\mathcal{L}(\varphi)&#x3D;\lbrace \alpha_{\sigma_1,\sigma_2}\in(2^{V’_1\cup V’_2})^\omega\mid\sigma_1,\sigma_2\models\varphi\rbrace$</p>
<p>Notice main difference comes from $\alpha\models\varphi$ and $\sigma_1,\sigma_2\models\varphi$. Also, QPTL uses <em>propositions</em> but S1S uses <em>term</em>. We thus define S1S formula as $T(\varphi,t)$, where $\varphi$ is a QPTL-formula over $AP$ and $t$ is a S1S-term. Lastly, with $V_2&#x3D;AP$, we can now define a S1S formula for all $\alpha\in(2^{AP})^\omega$,</p>
<blockquote>
<p>$$\alpha\lbrack\lbrack t\rbrack_{\sigma_1},\infty\rbrack\models_{QPTL}\varphi\hspace{0.5cm}\text{iff}\hspace{0.5cm}\sigma_1,\sigma_2\models_{S1S}T(\varphi,t)\varphi,\hspace{1cm}\text{where }\ \sigma_2:P\mapsto\lbrace i\in\mathbb{N}\mid P\in\alpha(i)\rbrace$$</p>
</blockquote>
<p>$\begin{array}{llll}<br>\hspace{1cm}\cdot&amp;T(P,t)&amp;&#x3D;&amp;t\in P\text{, for }P\in AP\newline<br>\hspace{1cm}\cdot&amp;T(\neg\varphi,t)&amp;&#x3D;&amp;\neg T(\varphi,t)\newline<br>\hspace{1cm}\cdot&amp;T(\varphi\wedge\psi,t)&amp;&#x3D;&amp;T(\varphi,t)\wedge T(\psi,t)\newline<br>\hspace{1cm}\cdot&amp;T(\bigcirc\varphi,t)&amp;&#x3D;&amp;T(\varphi,S(t))\newline<br>\hspace{1cm}\cdot&amp;T(\Diamond\varphi,t)&amp;&#x3D;&amp;\exists x.(x\geq t\wedge T(\varphi, x))\newline<br>\hspace{1cm}\cdot&amp;T(\exists P.\varphi,t)&amp;&#x3D;&amp;\exists P. T(\varphi,t)\newline<br>\end{array}$</p>
<p>Therefore, the language of $\varphi$ is then defined by the S1S formula $T(\varphi, 0)$.</p>
<h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>We apply every basic QPTL operators into $\varphi$, and transform them using S1S operators.</p>
<p>For proposition $P$, we can assign its value based on the temporal state when it holds. For example, for $\alpha&#x3D;{PPQPQQQ\dots}$, $P$ is in position $\alpha[0], \alpha[1], \alpha[3]$. So $\sigma_2:P\mapsto\lbrace0,1,3\rbrace$<br>And $T(P,t)$ is true when $t$ have value equals to {1,2,3}.</p>
<p>For the Finally operator $\Diamond$, it is expressed as true when the value is greater than or equals to t.</p>
<hr>
<p>Next chapter: <a href="../agv6-7/">S1S$_0$ and Büchi-recognizable Language</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-27T02:21:19.000Z" title="27/11/2024, 03:21:19">2024-11-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.416Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1048 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-5/">AGV 6.5 -- Monadic Second-Order Logic of One Successor (S1S)</a></p><div class="content"><p>Previous chapter: <a href="../agv6-4/">Quantified Propositional Temporal Logic (QPTL)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Temporal logics like LTL and QPTL refer to the positions of the input word <em>implicitly</em> through the <code>temporal operators</code>. With S1S, we now introduce a logic that allows us to manipulate positions <em>explicitly</em>.</p>
<p>For example, the mutual exclusion property in LTL is $\square\neg(\ell_1\wedge m_1)$, where the Always operator $\square$ <strong>implicitly quantifies over all positions</strong>. In S1S, we use <strong>explicit universal quantifiers</strong> instead: $\forall x.\neg(x\in P_{\ell_1}\wedge x\in P_{m_1})$.</p>
<h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul>
<li><em><strong>Monadic</strong></em>: the second-order quantification is restricted to <strong>unary relations</strong>, i.e., sets,</li>
<li><em><strong>One successor</strong></em>: only have a single successor operation.</li>
</ul>
<p>Later in the course, we will study monadic second-order logics of two or more successors (S2S, WS1S, etc.), which allow us to describe <em>trees</em> rather than <em>words</em>.</p>
<h2 id="S1S-syntax"><a href="#S1S-syntax" class="headerlink" title="S1S syntax"></a>S1S syntax</h2><p>In automaton, we use <em>states</em>; in LTL and QPTL, we use <em>propositions</em>, in S1S, we use <strong>positions</strong>.<br>Propositions in QPTL can be interpreted as <strong>set of positions</strong> that holds $\textit{true}$.</p>
<table>
<thead>
<tr>
<th align="left">basic variables</th>
<th align="left">Defintiion</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>first-order variables</code></td>
<td align="left">store <strong>positions</strong></td>
<td align="left">$0,1,x,y,\dots$</td>
</tr>
<tr>
<td align="left"><code>second-order variables</code></td>
<td align="left">store <strong>sets of positions</strong> (refer to $p$ as $\exists p.\varphi$ in QPTL)</td>
<td align="left">$X,Y,\dots$</td>
</tr>
<tr>
<td align="left"><code>successor operation</code></td>
<td align="left">$S$, allows us to navigate to the next position (same as $\bigcirc$ in LTL)</td>
<td align="left">$S(t), S(2),\dots$</td>
</tr>
</tbody></table>
<h3 id="Terms-and-Formulas"><a href="#Terms-and-Formulas" class="headerlink" title="Terms and Formulas"></a>Terms and Formulas</h3><p>Let $V_1&#x3D;\lbrace x, y,\dots\rbrace$ be a set of <code>first-order variables</code> and $V_2&#x3D;\lbrace X, Y,\dots\rbrace$ a set of <code>second-order variables</code>. Then the <strong>terms</strong> of S1S are defined by the following grammar:</p>
<p>$$t::&#x3D;0\mid x\mid S(t)$$</p>
<p>The <strong>formulas</strong>&#96;of S1S are defined by the following grammar:</p>
<p>$$\varphi::&#x3D;t\in X\mid t&#x3D;t\mid\neg\varphi\mid\varphi\wedge\varphi\mid\exists x.\varphi\mid\exists X.\varphi$$</p>
<p>The precedence order of the operators goes from left (highest precedence) to right (lowest precedence), as denoted by the grammar above. We still allow usual boolean connectives with the following abbreviations:</p>
<p>$<br>\begin{array}{ll}<br>\hspace{1cm}\cdot\hspace{0.5cm} \forall X.\varphi :&#x3D; \neg\exists X. \neg\varphi&amp; \hspace{3cm}\cdot\hspace{0.5cm} \forall x.\varphi :&#x3D; \neg\exists x. \neg\varphi\newline<br>\hspace{1cm}\cdot\hspace{0.5cm} x\notin Y :&#x3D; \neg(x\in Y)&amp; \hspace{3cm}\cdot\hspace{0.5cm} x\neq y:&#x3D; \neg(x&#x3D;y)<br>\end{array}<br>$</p>
<h3 id="Variable-Valuations"><a href="#Variable-Valuations" class="headerlink" title="Variable Valuations"></a>Variable Valuations</h3><p>The semantics of an S1S formula is given relative to a valuation of the variables.</p>
<ul>
<li><code>First-order Valuation</code>: $\sigma_1:V_1\rightarrow\mathbb{N}$ assigns to each <code>first-order variable</code> a <strong>natural number</strong>.</li>
<li><code>Second-order Valuation</code>: $\sigma_2:V_2\rightarrow 2^\mathbb{N}$ assigns to each <code>second-order variable</code> a <strong>set of natural numbers</strong>.</li>
</ul>
<p>The value of a term is then defined as follows:</p>
<p>$\begin{array}{lll}<br>\hspace{1cm}\cdot\hspace{0.5cm} \lbrack 0\rbrack_{\sigma_1} &#x3D; 0 &amp;<br>\hspace{4cm}\cdot\hspace{0.5cm} \lbrack x\rbrack_{\sigma_1} &#x3D; \sigma_1(x) &amp;<br>\hspace{3cm}\cdot\hspace{0.5cm} \lbrack S(t)\rbrack_{\sigma_1} &#x3D;[t]_{\sigma_1}+1\newline<br>\end{array}$</p>
<h2 id="Free-Bound-and-the-Language-of-S1S"><a href="#Free-Bound-and-the-Language-of-S1S" class="headerlink" title="Free, Bound and the Language of S1S"></a>Free, Bound and the Language of S1S</h2><p>Again, we define the subsets of <strong>free</strong> first-order and <strong>free</strong> second-order variables as $V’_1\subseteq V_1$ and $V’_2\subseteq V_2$ respectively. An S1S formula $\varphi$ then defines the following language over the alphabet $2^{V’_1\cup V’_2}$:</p>
<p>$$\mathcal{L}(\varphi)&#x3D;\lbrace \alpha_{\sigma_1,\sigma_2}\in(2^{V’_1\cup V’_2})^\omega\mid\sigma_1,\sigma_2\models\varphi\rbrace$$</p>
<p>where $x\in\alpha_{\sigma_1,\sigma_2}(j)\text{ iff }&#x3D;\sigma_1(x)$, and $X\in\alpha_{\sigma_1,\sigma_2}(j)\text{ iff }j&#x3D;\sigma_2(X)$, and $\models$ is the smallest relation that satisfies the following:</p>
<p>$<br>\begin{array}{llllll}<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; t\in X &amp; \text{iff} &amp; \lbrack t\rbrack_{\sigma_1}\in\sigma_2(X)\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; t_1&#x3D;t_2 &amp; \text{iff} &amp;\lbrack t_1\rbrack_{\sigma_1}&#x3D;\lbrack t_2\rbrack_{\sigma_1}\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; \neg\psi &amp; \text{iff} &amp;\sigma_1,\sigma_2\not\models\psi\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; \varphi_0\wedge \varphi_1 &amp; \text{iff} &amp;\sigma_1,\sigma_2\models\varphi_0\text{ and }\sigma_1,\sigma_2\models\varphi_1\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; \exists x.\varphi &amp; \text{iff} &amp;\text{there is an }\alpha\in\mathbb{N}\text{ s.t. }\sigma’_1,\sigma_2\models\varphi\text{ and }\sigma’_1(y)&#x3D;\left\lbrace\begin{array}{ll}\sigma_1(y)&amp;\text{if }y\neq x \newline a&amp;\text{if }y&#x3D;x\end{array}\right.\newline<br>\hspace{1cm}\cdot &amp; \sigma_1,\sigma_2 &amp; \models &amp; \exists X.\varphi &amp; \text{iff} &amp;\text{there is an }A\in\mathbb{N}\text{ s.t. }\sigma_1,\sigma’_2\models\varphi\text{ and }\sigma’_2(Y)&#x3D;\left\lbrace\begin{array}{ll}\sigma_2(Y)&amp;\text{if }Y\neq X\newline A&amp;\text{if }Y&#x3D;X\end{array}\right.<br>\end{array}<br>$</p>
<p>For Existence Operator $(\exists)$, the definition is similar to QPTL: We have $\sigma’_1$ that behave exactly the same for every <code>first-order variable</code> $y$. Except for some $x$, there is a value $a$ that $\sigma’_1$ can assign to $x$ so that $\varphi$ holds. Same definition apply on <code>second-order variable</code> $X$ resepctively.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><table>
<thead>
<tr>
<th align="left">Statement</th>
<th align="left">Formula</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$X$ is a subset of $Y$</td>
<td align="left">$X\subseteq Y\equiv\forall z.\ (z\in X\rightarrow z\in Y)$</td>
</tr>
<tr>
<td align="left">$X$ and $Y$ are equal</td>
<td align="left">$X &#x3D; Y\equiv X\subseteq Y \wedge Y\subseteq X$</td>
</tr>
<tr>
<td align="left">$X$ is upward closed</td>
<td align="left">$\textit{Upwardclosed}(X)\equiv\forall y.\ (y\in X\rightarrow S(y)\in X)$</td>
</tr>
<tr>
<td align="left">$x$ is less than or equals to $y$</td>
<td align="left">$x\leq y\equiv\forall Z.\ (x\in Z\wedge\textit{Upwardclosed}(Z))\rightarrow y\in Z$</td>
</tr>
<tr>
<td align="left">$X$ is a finite set</td>
<td align="left">$\textit{Fin}(X)\equiv\exists Y.\ (X\subseteq Y\wedge(\exists z.\ z\notin Y)\wedge(\forall z.\ (z\notin Y\rightarrow S(z)\notin Y)))$</td>
</tr>
<tr>
<td align="left">$X$ is the set of even numbers</td>
<td align="left">$\textit{Even}(X)\equiv0\in X\wedge\neg S(0)\in X \wedge \forall y.\ (y\in X\leftrightarrow S(S(y))\in X)$</td>
</tr>
<tr>
<td align="left">Every even number in $X$ is in $Y$</td>
<td align="left">$\textit{EvenCount}(X,Y)\equiv\forall w.\ (\exists Z.\ \textit{Even}(Z)\wedge w\in Z)\rightarrow(w\in X\rightarrow w\in Y)$</td>
</tr>
</tbody></table>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In the next section, we will try to compare S1S with QPTL and see their expressiveness.</p>
<hr>
<p>Next chapter: <a href="../agv6-6/">Express QPTL using S1S</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-26T01:33:51.000Z" title="26/11/2024, 02:33:51">2024-11-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.415Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 1101 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-4/">AGV 6.4 -- Quantified Propositional Temporal Logic (QPTL)</a></p><div class="content"><p>Previous chapter: <a href="../agv6-3/">LTL and Counting Languages</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the last section, we knew that LTL cannot express <code>counting-languages</code>. QPTL, which extends<br>LTL with <strong>quantification over propositions</strong>, repairs this deficiency.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>We knew $L&#x3D;(\varnothing\varnothing)^\ast\lbrace p\rbrace^\omega$ is not LTL-definable. However, similar language $L’&#x3D;(\varnothing\lbrace q\rbrace)^\ast\lbrace p\rbrace^\omega$ is LTL-definable:</p>
<p>$$\varphi&#x3D;\neg q\wedge(\neg p\wedge(\neg q\leftrightarrow\bigcirc q))\ \mathcal{U}\ (\square(p\wedge\neg q))$$</p>
<p>Intuitively, $L’$ is the same language as $L$, except that there is an additional proposition $q$ that keeps track of odd and even positions. LTL has no means of introducing such “helpful” propositions that are not already present in the language we wish to define. In QPTL, we can introduce the proposition $q$ using a quantifier. The existential quantification $\exists q$. $\varphi$ expresses that there is a way to evaluate the new proposition $q$ such that, in the such extended word, $\varphi$ is true. In the example, the language of $\exists q.\ \varphi$ is thus precisely $L$.</p>
<h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><p>QPTL formulas over a set $AP$ of atomic propositions are generated by the following grammar, where $p\in AP$:</p>
<p>$$\psi ::&#x3D; p\ \mid\ \neg\psi\ \mid\ \psi\wedge\varphi\ \mid\ \bigcirc\psi\ \mid\ \Diamond\psi\ \mid\ \exists p.\ \psi$$</p>
<p>The QPTL connectives have the same semantics and precedence as in LTL, except for propositional quantification, which has lowest precedence and the following semantics:</p>
<p>$$\begin{array}{lcr}\alpha\models\exists p.\ \varphi&amp;\text{ iff }&amp;\text{ there exists }\alpha’\in(2^{AP})^\omega\text{ such that }\alpha&#x3D;_{AP\setminus\lbrace p\rbrace}\alpha’\text{ and }\alpha’\models\varphi\end{array}$$</p>
<p>where $\alpha&#x3D;_P\alpha’$ for some $P\subseteq AP$ iff, for all $i\in\mathbb{N},\alpha(i)\cap P&#x3D;\alpha’(i)\cap P$.</p>
<blockquote>
<p>Every $AP$ in $\alpha$ is same as $\alpha’$, except $\alpha’$ can modify $p$ so that $\varphi$ holds for $\alpha’$</p>
</blockquote>
<h3 id="Until-operator-mathcal-U-in-QPTL"><a href="#Until-operator-mathcal-U-in-QPTL" class="headerlink" title="Until operator $\mathcal{U}$ in QPTL"></a>Until operator $\mathcal{U}$ in QPTL</h3><p>We can express the Until operator $\mathcal{U}$ in the syntax of QPTL with quantifier and the meaning is equivalent:</p>
<blockquote>
<p>$\varphi\ \mathcal{U}\ \psi:$ $\varphi$ must hold $\textit{true}$ until $\psi$ becomes $\textit{true}$.</p>
</blockquote>
<p>$$\exists t.\ t\wedge\square(t\rightarrow(\psi\vee(\varphi\wedge\bigcirc t)))\wedge\Diamond\neg t:$$</p>
<blockquote>
<ul>
<li><p>$\exists t.\ t$: For some proposition $t$, $t$ holds at the beginning;</p>
</li>
<li><p>$\square(t\rightarrow(\psi\vee(\varphi\wedge\bigcirc t)))$: if $t$ holds, we repeatly check the following</p>
<ul>
<li>either $\psi$ becomes $\textit{true}$, or</li>
<li>$\varphi$ must remain $\textit{true}$ and so as $t$ in the next step<br>(so that this if-clause check again in the next step);\</li>
</ul>
</li>
<li><p>$\Diamond\neg t$ : Eventually, $t$ will no longer hold.</p>
<ul>
<li>It enforces $\psi$ must become $\textit{true}$ at some point and then $t$ doesn’t need to hold anymore</li>
<li>If it is weak until $\mathcal{W}$ then this part is not necessarily because we don’t enforce $\psi$ to be $\textit{true}$</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="Free-and-Bound-Atomic-Propositions"><a href="#Free-and-Bound-Atomic-Propositions" class="headerlink" title="Free and Bound Atomic Propositions"></a><code>Free</code> and <code>Bound</code> Atomic Propositions</h3><table>
<thead>
<tr>
<th align="left">Atomic Propositions</th>
<th align="left">Defintiion</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Free</code></td>
<td align="left"><strong>NOT in</strong> the <em>scope of a quantifier</em> over the proposition</td>
</tr>
<tr>
<td align="left"><code>Bound</code></td>
<td align="left"><strong>In</strong> the <em>scope of a quantifier</em> over the proposition</td>
</tr>
</tbody></table>
<p>Here, <code>Bounded</code> propositions are internal helpers to help us construct some logical conditions of the formula that do not directly appear in the language. (e.g. we need a counter for <code>counting</code>-language, but it doesn’t belongs to any proposition that refers to the alphabet or language.)</p>
<h2 id="From-QPTL-formula-to-omega-regular-language"><a href="#From-QPTL-formula-to-omega-regular-language" class="headerlink" title="From QPTL formula to $\omega$-regular language"></a>From QPTL formula to $\omega$-regular language</h2><p>Let’s defined the set of <strong>free</strong> atomic propositions as $AP’\subseteq AP$. For every letter in the alphabet, we can describe them in $AP’$.</p>
<p>For exmaple, if $\lbrace a,b,c\rbrace&#x3D;\Sigma$, the word $\lbrace ab\rbrace\in\Sigma$ will be $\lbrace a,b,\neg c\rbrace\in AP’$</p>
<p>Now, the language of QPTL is essentially the language over alphabet $2^{AP’}:\mathcal{L}(\varphi)&#x3D;\lbrace\alpha\in{(2^{AP’})}^{\omega}\mid\alpha\models\varphi\rbrace$</p>
<p>In fact, it is exactly the $\omega$-regular languages that can be expressed in QPTL. And therefore, we can translate a given Büchi automaton with alphabet $2^{AP}$ into a QPTL formula:</p>
<blockquote>
<p>$\textbf{Theorem 6.2. } \textit{For every Büchi automaton }\mathcal{A}\textit{ over }\Sigma&#x3D;2^{AP}\textit{ there exists a QPTL formula }\varphi_{\mathcal{A}}\newline\textit{such that }\mathcal{L}(\varphi)&#x3D;\mathcal{L}(\mathcal{A}).$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Reminder: here the automaton using atomic propositions $2^{AP}$, not the alphabet $\Sigma$. To translate states in automata into atomic proposition in QPTL formula, we introduce <em>auxiliary proposition</em> $at_q$ for each <em>state</em> $q\in Q$, where $Q&#x3D;\lbrace q_1, q_2,\dots,q_n\rbrace$</p>
<p>Then QPTL formula $\varphi_\mathcal{A}$ for the Büchi automaton $\mathcal{A}$ so that $\mathcal{L}(\varphi)&#x3D;\mathcal{L}(\mathcal{A})$ is defined as follows:</p>
<p>$$<br>\begin{array}{rll}<br>\varphi_\mathcal{A}:&#x3D;\exists at_q,\dots,at_{q_n}.&amp;&amp;\underset{q\in I}{\bigvee}at_q\newline<br>&amp;\wedge&amp;\square\left(\underset{(q,A,q’)\in T}{\bigvee}at_q\wedge\bigcirc at_{q’}\wedge\left(\underset{p\in A}{\bigwedge}p\right)\wedge\left(\underset{p\in AP\setminus A}{\bigwedge}\neg p\right)\right)\newline<br>&amp;\wedge&amp;\square\left(\overset{n}{\underset{i&#x3D;1}{\bigwedge}}\underset{j\neq i}{\bigwedge}\neg(at_{q_i}\wedge at_{q_j})\right)\newline<br>&amp;\wedge&amp;\square\Diamond\underset{q\in F}{\bigvee}at_q<br>\end{array}<br>$$</p>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>To express a Büchi automaton in QPTL, we first need to know what features&#x2F;characteristics we need express.</p>
<ul>
<li>Begins with Initial states and reaches the Accepting states infinitely often:</li>
</ul>
<p>$$\textsf{Initial states: }\underset{q\in I}{\bigvee}at_q \hspace{3cm} \textsf{Accepting states: }\square\Diamond\underset{q\in F}{\bigvee}at_q$$</p>
<ul>
<li>There’s always transitions for any states, only using the letters available in the current state defined by set $A$:</li>
</ul>
<p>$$\square\left(\underset{(q,A,q’)\in T}{\bigvee}at_q\wedge\bigcirc at_{q’}\wedge\left(\underset{p\in A}{\bigwedge}p\right)\wedge\left(\underset{p\in AP\setminus A}{\bigwedge}\neg p\right)\right)$$</p>
<ul>
<li>Additionally, we also need to ensure that there’s exactly one current state $q_i$, which is $at_{q_i}$ in propositions:</li>
</ul>
<p>$$\square\left(\overset{n}{\underset{i&#x3D;1}{\bigwedge}}\underset{j\neq i}{\bigwedge}\neg(at_{q_i}\wedge at_{q_j})\right)$$</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>As above, we can see that every feature of a Büchi automaton can be expressed in QPTL. What’s next? Can we use simpler syntax to express same formula?</p>
<hr>
<p>Next chapter: <a href="../agv6-5/">Monadic Second-Order Logic of One Successor (S1S)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-24T23:44:03.000Z" title="25/11/2024, 00:44:03">2024-11-25</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.415Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1241 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-3/">AGV 6.3 -- LTL and Counting Languages</a></p><div class="content"><p>Previous chapter: <a href="../agv6-2/">Expressing Program Properties using LTL</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h2><p>An LTL formula $\varphi$ over $AP$ defines the following language over the alphabet $2^{AP}$:</p>
<p>$\hspace{1cm} \mathcal{L}(\varphi)&#x3D;\lbrace\alpha\in(2^{AP})^\omega\mid\alpha\models\varphi\rbrace$</p>
<p>where $\models$ is the smallest relation satisfying:</p>
<p>$\begin{array}{lllll}<br>\hspace{1cm} \alpha &amp; \models &amp; p &amp; \text{iff} &amp; p\in\alpha(0) \ \ \ \ (\text{i.e., }\alpha(0)\models p)\newline<br>\hspace{1cm} \alpha &amp; \models &amp; \varphi_1\wedge\varphi_2 &amp; \text{iff} &amp; \alpha\models\varphi_1\ \text{ and }\ \alpha\models\varphi_1\newline<br>\hspace{1cm} \alpha &amp; \models &amp; \neg\varphi &amp; \text{iff} &amp; \alpha\not\models\varphi\newline<br>\hspace{1cm} \alpha &amp; \models &amp; \bigcirc\varphi &amp; \text{iff} &amp; \alpha[1,\infty]&#x3D;\alpha(1)\alpha(2)\alpha(3)\dots\models\varphi\newline<br>\hspace{1cm} \alpha &amp; \models &amp; \varphi_1\ \mathcal{U}\ \varphi_2 &amp; \text{iff} &amp; \exists j\geq0.\ \alpha[j,\infty]\models\varphi_2\ \text{ and }\ \alpha[i,\infty]\models\varphi_1\text{ for all }0\leq i\leq j\newline<br>\end{array}$</p>
<p>For the temporal operators, the semantics can be visualized as below:</p>
<p><img src="/../images/notes/uds/agv/6_3_ltl.png"></p>
<h2 id="From-LTL-to-omega-regular-languages"><a href="#From-LTL-to-omega-regular-languages" class="headerlink" title="From LTL to $\omega$-regular languages"></a>From LTL to $\omega$-regular languages</h2><blockquote>
<p>All LTL-definable properties are $\omega$-regular, but <strong>NOT ALL</strong> $\omega$-regular languages can be defined in LTL.</p>
</blockquote>
<p>Why can’t we? What is the limitation of LTL formula?</p>
<h3 id="Counting-and-Non-counting-Languages"><a href="#Counting-and-Non-counting-Languages" class="headerlink" title="Counting and Non-counting Languages"></a>Counting and Non-counting Languages</h3><p>Let say we want to express:</p>
<blockquote>
<p>An arbitrary <strong>even</strong> sequence of $\varnothing$ symbols, followed by an infinite sequence of $p$ symbols</p>
</blockquote>
<p>In $\omega$-language it is $(\varnothing\varnothing)^\ast\lbrace p\rbrace^\omega$. However, this cannot be defined in LTL, because it is a <code>counting language</code>.</p>
<blockquote>
<p>$\textbf{Definition 6.1. }\text{A Language }L\subseteq\Sigma^\omega\text{ is }\textit{non-counting}\text{ iff}$<br>$$\exists n_0\in\mathbb{N}.\ \forall n\geq n_0.\ \forall v,w\in\Sigma^\ast, \alpha\in\Sigma^\omega.\ vw^n\alpha\in L\Leftrightarrow vw^{n+1}\alpha\in L$$</p>
</blockquote>
<p>For some threshold $n_0$, and a word with prefix $w$ which repeated $n$ times and $n\geq n_0$. For every $n$ we picked, if we can always find a pair of words $vw^{n}\alpha,vw^{n+1}$ that are both accepted by language $L$, then $L$ is <code>non-counting</code>.</p>
<p>For example, in $L_1&#x3D;(\varnothing\varnothing)^\ast\lbrace p\rbrace^\omega$, if $(\varnothing)^n\lbrace p\rbrace^\omega\in L_1$, then $(\varnothing)^{n+1}\lbrace p\rbrace^\omega\not\in L_1$, so $L_1$ is <code>counting</code> with $n_0&#x3D;1$.</p>
<blockquote>
<p>$\textbf{Theorem 6.1. }\textit{ For every LTL-formula }\varphi,\mathcal{L}(\varphi)\textit{ is non-counting.}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We prove the theorem by structural induction on $\varphi$, going through its sematics:</p>
<p>$\textbf{Case }\varphi&#x3D;p:$<br>$\hspace{1cm}$  Simply choose the length $n_0&#x3D;1$, (because $\alpha\models p\text{ iff }p\in\alpha(0)$)</p>
<p>$\textbf{Case }\varphi&#x3D;\varphi_1\wedge\varphi_2:$<br>$\hspace{1cm}$ By induction hypothesis, If $\varphi_1$ and $\varphi_2$ are <code>non-counting</code>, then $\mathcal{L}(\varphi_1)$ and $\mathcal{L}(\varphi_2)$ have threshold $n_0’$ and<br>$\hspace{1cm}$ $n’’_0\in\mathbb{N}$ respectively. We can choose $n_0&#x3D;\text{max}\lbrace n’_0,n’’_0\rbrace$ to ensure $\varphi$ is also <code>non-counting</code>. (max. because<br>$\hspace{1cm}$ the larger the $n_0$, less $n$ is required to be <code>non-counting</code>)</p>
<p>$\textbf{Case }\varphi&#x3D;\neg\varphi_1:$<br>$\hspace{1cm}$ If $\varphi_1$ is <code>non-counting</code>, then $\mathcal{L}(\varphi_1)$ has threshold $n_0’\in\mathbb{N}$. We choose $n_0&#x3D;n’_0$</p>
<p>$\textbf{Case }\varphi&#x3D;\bigcirc\varphi_1:$<br>$\hspace{1cm}$ If $\varphi_1$ is <code>non-counting</code>, then $\mathcal{L}(\varphi_1)$ has threshold $n_0’\in\mathbb{N}$. We choose $n_0&#x3D;n’_0+1$ and try to show<br>$$\text{“For }n\geq n_0,\ vw^n\alpha\models\bigcirc\varphi\ \text{ if and only if }\ n\geq n_0,\ vw^{n+1}\alpha\models\bigcirc\varphi”$$</p>
<p>$\hspace{1cm}$ We try to perform operations on the fix length prefix $v$ as it doesn’t affect the finite loop prefix $w$. So we<br>$\hspace{1cm}$ need to consider whether the fix length prefix $v$ is an <em>empty string</em> $(\varepsilon)$, if not, we try to “peel” one cycle of<br>$\hspace{1cm}$ $w$ and make it so-called “fix-length” prefix.</p>
<p>$\hspace{1cm}$ A simple example for the operation: if there’s logic requires $b$ to be reached in the next step, then the same<br>$\hspace{1cm}$ logic without <strong>neXt</strong> operator $\bigcirc$ can be satisfied by removing the first letter. (if $ab\models\bigcirc\varphi$, then $b\models\varphi$)</p>
<p>$\hspace{1cm}\textbf{Case }\ v\neq\varepsilon:$ Thus $v&#x3D;av’$ for some $a\in\Sigma,v’\in\Sigma^\ast$. We have that</p>
<p>$\begin{array}{lrl}<br>\hspace{2cm}&amp;av’w^n\alpha&amp;\models\bigcirc\varphi\newline<br>\hspace{2cm}\text{iff}&amp;v’w^n\alpha&amp;\models\varphi\newline<br>\hspace{2cm}\text{iff}&amp;v’w^{n+1}\alpha&amp;\models\varphi&amp;\text{(induction hypothesis)}\newline<br>\hspace{2cm}\text{iff}&amp;av’w^{n+1}\alpha&amp;\models\bigcirc\varphi\newline<br>\end{array}$</p>
<p>$\hspace{1cm}\textbf{Case }\ v&#x3D;\varepsilon:$ Thus either $w&#x3D;\varepsilon$ (proved trivially), or $w&#x3D;aw’$ for some $a\in\Sigma,w’\in\Sigma^\ast$. It follows that</p>
<p>$\begin{array}{lrl}<br>\hspace{2cm}&amp;(aw’)^n\alpha&amp;\models\bigcirc\varphi\newline<br>\hspace{2cm}\text{iff}&amp;(aw’)(aw’)^{n-1}\alpha&amp;\models\bigcirc\varphi\newline<br>\hspace{2cm}\text{iff}&amp;w’(aw’)^{n-1}\alpha&amp;\models\varphi\newline<br>\hspace{2cm}\text{iff}&amp;w’(aw’)^{n}\alpha&amp;\models\varphi&amp;\text{(induction hypothesis)}\newline<br>\hspace{2cm}\text{iff}&amp;(aw’)^{n+1}\alpha&amp;\models\bigcirc\varphi\newline<br>\end{array}$</p>
<p>$\textbf{Case }\varphi&#x3D;\varphi_1\ \mathcal{U}\ \varphi_2:$<br>$\hspace{1cm}$ If $\varphi_1$ and $\varphi_2$ are <code>non-counting</code>, then $\mathcal{L}(\varphi_1)$ and $\mathcal{L}(\varphi_2)$ have threshold $n_0’$ and $n’’_0\in\mathbb{N}$ respectively. We<br>$\hspace{1cm}$ choose $n_0&#x3D;\text{max}\lbrace n’_0,n’’_0\rbrace+1$ and try to show<br>$$”\text{For }n\geq n_0,\ vw^n\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2\ \text{ if and only if }\ vw^{n+1}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2”$$</p>
<p>$\hspace{1cm}$ By the semantics of $\mathcal{U}$, $\varphi_1$ keeps holding until $\varphi_2$ is satisfied. Let $j$ be the least index when $\varphi_2$ is satisfied,<br>$\hspace{1cm}$ then we have $vw^n\alpha[j,\infty]\models\varphi_2$ and for all $i&lt;j,\ vw^n\alpha[i,\infty]\models\varphi_1$, respectively applies on $vw^{n+1}\alpha$.</p>
<p>$\hspace{1cm}$ $\textbf{1. }\textit{If }\ vw^n\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2\textit{, then }\ vw^{n+1}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2:$<br>$\hspace{2cm}$ Similar to $\bigcirc\varphi$, we try to do the operation with respect to $j$’s position. So we need to consider whether<br>$\hspace{2cm}$ index $j$ lies within the first cycle of the prefix $|v|+|w|$, or lies in the finite loop of the prefix $|w|$.</p>
<p>$\hspace{2cm}\textbf{Case }j\leq|v|+|w|:$<br>$\hspace{3cm}$ By induction hypothesis, we assumed $\varphi_1$ and $\varphi_2$ are <code>non-counting</code>. So<br>$\hspace{3cm}$ if $vww^{n−1}\alpha[j,\infty]\models\varphi_2$, then $vww^{n}\alpha[j,\infty]\models\varphi_2$ and analogously,<br>$\hspace{3cm}$ if $vww^{n−1}\alpha[i,\infty]\models\varphi_1$, then $vww^{n}\alpha[i,\infty]\models\varphi_1$ for $i &lt; j$.<br>$\hspace{3cm}$ Hence, $vw^{n+1}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2$.</p>
<p>$\hspace{2cm}\textbf{Case }j&gt;|v|+|w|:$<br>$\hspace{3cm}$ By adding one more cycle, we can essentially get the same suffix if $j$ is somewhere in the cycle:<br>$\hspace{3cm}$ if $vw^{n}\alpha[j,\infty]\models\varphi_2$, then $vw^{n+1}\alpha[j+|w|,\infty]\models\varphi_2$, and<br>$\hspace{3cm}$ if $vw^{n}\alpha[i,\infty]\models\varphi_1$, then $vw^{n+1}\alpha[i,\infty]\models\varphi_1$, for each position $|v|+|w|\leq i&lt;j+|w|$.<br>$\hspace{3cm}$ Additionally, by induction hypothesis from the above case, we have that</p>
<p>$\begin{array}{lrcccll}<br>\hspace{4cm}&amp;|v|+|w|&amp;\leq&amp;i&amp;&lt;&amp;j+|w|\newline<br>\hspace{4cm}\text{iff}&amp;|v|&amp;\leq&amp;i&amp;&lt;&amp;j\newline<br>\hspace{4cm}\text{iff}&amp;&amp;&amp;i&amp;&lt;&amp;j&amp;&amp;(\text{induction hypothesis: }i&lt;|v|+|w|)\newline<br>\end{array}$</p>
<p>$\hspace{3cm}$ Hence, $vw^{n}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2$.</p>
<p>$\hspace{1cm}$ $\textbf{2. }\textit{If }\ vw^{n+1}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2\textit{, then }\ vw^{n}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2:$<br>$\hspace{2cm}$ Again, we need consider both cases seperately:</p>
<p>$\hspace{2cm}\textbf{Case }j\leq|v|+|w|:$<br>$\hspace{3cm}$ By induction hypothesis, we assumed $\varphi_1$ and $\varphi_2$ are <code>non-counting</code>. So<br>$\hspace{3cm}$ if $vww^{n}\alpha[j,\infty]\models\varphi_2$, then $vww^{n-1}\alpha[j,\infty]\models\varphi_2$ and analogously,<br>$\hspace{3cm}$ if $vww^{n}\alpha[i,\infty]\models\varphi_1$, then $vww^{n-1}\alpha[i,\infty]\models\varphi_1$ for $i &lt; j$.<br>$\hspace{3cm}$ Hence, $vw^{n}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2$.</p>
<p>$\hspace{2cm}\textbf{Case }j&gt;|v|+|w|:$<br>$\hspace{3cm}$ Simliar to above, by subtracting one more cycle, we can essentially get the same suffix:<br>$\hspace{3cm}$ if $vw^{n+1}\alpha[j,\infty]\models\varphi_2$, then $vw^{n}\alpha[j-|w|,\infty]\models\varphi_2$, and<br>$\hspace{3cm}$ if $vw^{n+1}\alpha[i,\infty]\models\varphi_1$, then $vw^{n}\alpha[i,\infty]\models\varphi_1$, for each position $|v|+|w|\leq i&lt;j-|w|$.<br>$\hspace{3cm}$ Again, by induction hypothesis from the above case, we have that</p>
<p>$\begin{array}{lrcccll}<br>\hspace{4cm}&amp;|v|+|w|&amp;\leq&amp;i&amp;&lt;&amp;j-|w|\newline<br>\hspace{4cm}\text{iff}&amp;|v|+2|w|&amp;\leq&amp;i&amp;&lt;&amp;j\newline<br>\hspace{4cm}\text{iff}&amp;&amp;&amp;i&amp;&lt;&amp;j&amp;&amp;(\text{induction hypothesis: }i&lt;|v|+|w|)\newline<br>\end{array}$</p>
<p>$\hspace{3cm}$ Hence, $vw^{n}\alpha\models\varphi_1\ \mathcal{U}\ \varphi_2$.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Unfortunately, LTL is not expressive enough to include all $\omega$-regular languages. However, by extending the syntax of LTL, we can also extend the languages it covers.<br>In the next section, we will Quantified Propositional Temporal Logic (QPTL), and see whether it suffices to solve our problem.</p>
<hr>
<p>Next chapter: <a href="../agv6-4/">Quantified Propositional Temporal Logic (QPTL)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-24T04:56:28.000Z" title="24/11/2024, 05:56:28">2024-11-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.424Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">4 minutes read (About 668 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-2/">AGV 6.2 -- Expressing Program Properties using LTL</a></p><div class="content"><p>Previous chapter: <a href="../agv6-1/">Linear-Time Temporal Logic (LTL)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this section, we consider again our concurrent program $\small{\text{TURN}}$ introduced in <a href="../agv1-1/">section 1.1</a>. As discussed before, a major property of interest is <code>mutual exclusion</code>,i.e., at any given point of time, at most one process is in the $\text{critical}$ region. We can express <code>mutual exclusion</code>, as well as other properties of turn, in <code>LTL</code>.</p>
<blockquote>
<p>$\textbf{Example 1.1. }\small{\text{TURN}}:$<br>$$\text{local $t$: boolean where initially $t$ &#x3D; $false$}\newline<br>P_0::\left[ \begin{array}{l}\text{loop forever do}\newline<br>\hspace{1cm}\left[ \begin{array}{l}<br>\ell_0: \text{await }\neg t; \newline<br>\ell_1: \text{critical;} \newline<br>\ell_2: t :&#x3D; true; \newline<br>\end{array} \right]\end{array} \right]<br>\mid\mid P_1::\left[ \begin{array}{l}<br>\text{loop forever do}\newline<br>\hspace{1cm}\left[ \begin{array}{l}<br>m_0: \text{await } t; \newline<br>m_1: \text{critical;} \newline<br>m_2: t :&#x3D; false; \newline<br>\end{array} \right]\end{array} \right]$$</p>
</blockquote>
<h2 id="Properties-of-the-Concurrent-Program-small-text-TURN"><a href="#Properties-of-the-Concurrent-Program-small-text-TURN" class="headerlink" title="Properties of the Concurrent Program $\small{\text{TURN}}$"></a>Properties of the Concurrent Program $\small{\text{TURN}}$</h2><h3 id="Mutual-exclusion-square-neg-ell-1-wedge-m-1"><a href="#Mutual-exclusion-square-neg-ell-1-wedge-m-1" class="headerlink" title="Mutual exclusion : $\square\neg(\ell_1\wedge m_1)$"></a><em>Mutual exclusion</em> : $\square\neg(\ell_1\wedge m_1)$</h3><blockquote>
<p>$\ell_{1}$ and $m_1$ cannot ($\neg$) be true at the same time ($\wedge$) at every point in time ($\square$)</p>
</blockquote>
<p>The property can equivalently be formulated as $\neg(\textit{true}\ \mathcal{U}\ (\ell_1\wedge m_1))$, which means that the system remains true, until the a violation of mutual exclusion, i.e., $\ell_1\wedge m_1$, occurs</p>
<h3 id="Finite-waiting-square-ell-0-rightarrow-Diamond-ell-1-wedge-m-0-rightarrow-Diamond-m-1"><a href="#Finite-waiting-square-ell-0-rightarrow-Diamond-ell-1-wedge-m-0-rightarrow-Diamond-m-1" class="headerlink" title="Finite waiting : $\square((\ell_0\rightarrow\Diamond\ell_1)\wedge(m_0\rightarrow\Diamond m_1))$"></a><em>Finite waiting</em> : $\square((\ell_0\rightarrow\Diamond\ell_1)\wedge(m_0\rightarrow\Diamond m_1))$</h3><blockquote>
<p>If ($\rightarrow$) $\ell_0$ is reached, eventually ($\Diamond$) it moves to $\ell_1$ and so as $m_0$ and $m_1$, this happens forever ($\square$)</p>
</blockquote>
<p>In other words, each process only waits a finite amount of time (in locations $\ell_0$ and $m_0$, respectively) until it enters the $\text{critical}$ region (in locations $\ell_1$ and $m_1$, respectively):</p>
<p>This property is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Safety_and_liveness_properties#Liveness">Liveness</a> conditions, usually involve infinite number of steps. Usually it is only meaningful when it is held under additional assumptions on the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linear_time_property#Fairness_properties">fairness</a> of the <strong>scheduler</strong>.</p>
<h3 id="Finite-waiting-under-Fairness-square-Diamond-P-0-wedge-square-Diamond-P-1-rightarrow-square-ell-0-rightarrow-Diamond-ell-1-wedge-m-0-rightarrow-Diamond-m-1"><a href="#Finite-waiting-under-Fairness-square-Diamond-P-0-wedge-square-Diamond-P-1-rightarrow-square-ell-0-rightarrow-Diamond-ell-1-wedge-m-0-rightarrow-Diamond-m-1" class="headerlink" title="Finite waiting under Fairness : $(\square\Diamond P_0\wedge\square\Diamond P_1)\rightarrow\square((\ell_0\rightarrow\Diamond\ell_1)\wedge(m_0\rightarrow\Diamond m_1))$"></a><em>Finite waiting under Fairness</em> : $(\square\Diamond P_0\wedge\square\Diamond P_1)\rightarrow\square((\ell_0\rightarrow\Diamond\ell_1)\wedge(m_0\rightarrow\Diamond m_1))$</h3><blockquote>
<p><code>Finite waiting</code> is required if both $P_0$ and $P_1$ will always happens (taking turns)</p>
</blockquote>
<p>Let the atomic propositions $P_0$ and $P_1$ denote that the <strong>scheduler</strong> allows the respective process to advance in the current step. The subformula $\square\Diamond P_0$ states that process $P_0$ is scheduled infinitely often (always eventually). The <em>finite waiting property</em> is thus only required to hold if both processes are scheduled infinitely often.</p>
<h3 id="Bounded-overtaking-square-ell-0-rightarrow-neg-m-1-mathcal-U-m-1-mathcal-U-neg-m-1-mathcal-U-ell-1"><a href="#Bounded-overtaking-square-ell-0-rightarrow-neg-m-1-mathcal-U-m-1-mathcal-U-neg-m-1-mathcal-U-ell-1" class="headerlink" title="Bounded overtaking : $\square(\ell_0\rightarrow(\neg m_1\ \mathcal{U}\ (m_1\ \mathcal{U}\ (\neg m_1\ \mathcal{U}\ \ell_1))))$"></a><em>Bounded overtaking</em> : $\square(\ell_0\rightarrow(\neg m_1\ \mathcal{U}\ (m_1\ \mathcal{U}\ (\neg m_1\ \mathcal{U}\ \ell_1))))$</h3><blockquote>
<p>If $\ell_0$ is reached, it must leave the location $m_1$, and wait until $\ell_1$ is reached; when it leaves $\ell_1$, then it is allowed to move back to location $m_1$ again. This repeats infinitely.</p>
</blockquote>
<p>In program $\small{\text{TURN}}$, the shared variable $t$ ensures that the processes <em>take turns</em> in entering their respective $\text{critical}$ regions. <em>Bounded Overtaking</em> refers to once process $P_0$ reaches location $\ell_0$, process $P_1$ can enter location $m_1$ at most once before Process $P_0$ enters location $\ell_1$.</p>
<p>This formulization of <em>bounded overtaking</em> requires that Process $P_1$ will eventually reach $\ell_1$. Sometimes we may also prefer a weaker requirement, where <strong>waiting forever</strong> is fine, as long as Process $P_1$ does not get to enter $m_1$ more than once in the meantime. We can simply change the operator into <code>weak until</code>$(\mathcal{W})$ to allow the processes to wait forever: $\square(\ell_0\rightarrow(\neg m_1\ \mathcal{W}\ (m_1\ \mathcal{W}\ (\neg m_1\ \mathcal{W}\ \ell_1))))$</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In the next section, we will define the semantics of the logic for our automaton.</p>
<hr>
<p>Next chapter: <a href="../agv6-3/">LTL and Counting Languages</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Safety_and_liveness_properties">Safety and liveness properties</a>. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Linear_time_property">Linear time property</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-23T12:40:02.000Z" title="23/11/2024, 13:40:02">2024-11-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.414Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1185 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv6-1/">AGV 6.1 -- Linear-Time Temporal Logic (LTL)</a></p><div class="content"><p>Previous chapter: <a href="../agv5-3/">Complement Büchi Automaton with Odd Ranking</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the following sections, we introduce several logics for the specification of sets of infinite sequences: <strong>LTL</strong>, <strong>QPTL</strong>, and <strong>S1S</strong>, which can be used to describe $\omega$-regular languages: we can translate a given formula into an automaton that recongnizes the models of the formula.</p>
<p>As a result, we can use the automata-theoretic machinery to answer logical questions like <code>satisfiability</code> or <code>validity</code>. We can also use the logics as a much more convenient starting point, compared to a direct specification using automata, for <code>verification</code> and <code>synthesis</code>.</p>
<h2 id="Linear-Time-Temporal-Logic-LTL"><a href="#Linear-Time-Temporal-Logic-LTL" class="headerlink" title="Linear-Time Temporal Logic (LTL)"></a>Linear-Time Temporal Logic (LTL)</h2><p>Linear-time temporal logic (LTL) is a popular logic for the specification of reactive systems. For a given set of <code>atomic propositions</code>$(AP)$, the formulas of <code>LTL</code> define sets of infinite words over the alphabet $2^{AP}$.</p>
<ul>
<li><strong>Atomic Propositions:</strong><br>the interface of a system or a component, such as (a boolean representation of) input and output variables</li>
<li><strong>Words defined by the Formula:</strong><br>the executions of the system that are considered correct (see example in <a href="../agv1-1/">section 1.1</a>).</li>
</ul>
<h3 id="Syntax-of-LTL"><a href="#Syntax-of-LTL" class="headerlink" title="Syntax of LTL"></a>Syntax of LTL</h3><p>φ has to be true until and including the point where ψ first becomes true; if ψ never becomes true, φ must remain true forever.</p>
<p>LTL formulars are constructed from <code>proposition logic</code> with extra <code>temporal operators</code>.</p>
<blockquote>
<p>$\begin{array}{lrl} \ \textit{Propositional logic}\newline\hspace{1cm} \cdot \ p,\varphi,\dots\in AP&amp;&amp; \ \text{(Atomic Propositions)}\newline\hspace{1cm} \cdot \ \neg\varphi,\varphi\wedge\psi,\dots&amp;&amp; \ \text{(Logical Operators)}\newline \ \textit{Temporal Operator}\newline\hspace{1cm} \cdot \bigcirc\varphi \ &#x2F;\  \mathcal{X}\ \varphi&amp; \ \text{Ne}\textbf{X}\text{t: }&amp;\varphi\text{ has to be }\textit{true}\text{ in next state}\newline\hspace{1cm} \cdot \ \Diamond \ \varphi \ &#x2F;\  \mathcal{F}\ \varphi&amp; \ \textbf{F}\text{inally: }&amp;\varphi\text{ has to be }\textit{true}\text{ eventually}\newline\hspace{1cm} \cdot \ \square \ \varphi \ &#x2F;\  \mathcal{G}\ \varphi&amp; \ \textbf{G}\text{lobally: }&amp;\varphi\text{ has to be }\textit{true}\text{ for now and so on}\newline\hspace{1cm} \cdot \ \varphi \ \mathcal{U} \ \psi&amp; \ \textbf{U}\text{ntil: }&amp;\varphi\text{ has to be }\textit{true}\textit{ at least }\text{until }\psi\text{ becomes }\textit{true}\newline\hspace{1cm} \cdot \ \varphi \ \mathcal{R} \ \psi&amp; \ \textbf{R}\text{elease: }&amp;\psi\text{ has to be }\textit{true}\text{ until }\varphi\text{ becomes true (inclusive)}\newline&amp;&amp;\psi\text{ remains }\textit{true}\textit{ forever}\text{ if } \varphi\text{ never becomes }\textit{true}\newline\hspace{1cm} \cdot \ \varphi \ \mathcal{W} \ \psi&amp; \ \textbf{W}\text{eak until: }&amp;\varphi\text{ has to be }\textit{true}\textit{ at least }\text{until }\psi\text{ becomes }\textit{true}\text{, or}\newline&amp;&amp;\varphi\text{ remains }\textit{true}\textit{ forever}\text{ if }\psi\text{ never becomes }\textit{true}\newline\hspace{1cm} \cdot \ \varphi \ \mathcal{M} \ \psi&amp; \ \textbf{M}\text{ighty Release: }&amp;\psi\text{ has to be }\textit{true}\text{ until }\varphi\text{ becomes true (inclusive)}\end{array}$</p>
</blockquote>
<h3 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h3><p>When we determine whether a LTL formula is $\textit{true}$ or $\textit{false}$, it only depends on <strong>current and future</strong> states.</p>
<p>For example, the formula $\varphi\ \mathcal{U}\ \psi$ states that $\varphi$ must remain $\textit{true}$ <strong>UNTIL</strong> $\psi$ become $\textit{true}$. If the current state we have only $\psi&#x3D;\textit{true}$, this formula is still evaluated as $\textit{true}$, even if $\varphi$ never become $\textit{true}$.</p>
<p>We can conclude that, $\varphi\ \mathcal{U}\ \psi &#x3D; \textit{true}$ if:</p>
<ol>
<li>In current state $\psi$ becomes $\textit{true}$ (regardless of $\varphi$’s condition)</li>
<li>Eventually $\psi$ becomes $\textit{true}$ in certain state (not now), and from now <strong>Until</strong> that state, $\varphi$ must remain $\textit{true}$</li>
</ol>
<h2 id="Sematics-of-LTL"><a href="#Sematics-of-LTL" class="headerlink" title="Sematics of LTL"></a>Sematics of LTL</h2><h3 id="Additional-operators"><a href="#Additional-operators" class="headerlink" title="Additional operators"></a>Additional operators</h3><p>$\mathcal{R}$, $\Diamond\ (\mathcal{F})$, $\square\ (\mathcal{G})$ are considered as <em>additional operators</em>, which can be defined by other LTL operators:</p>
<ul>
<li>$\varphi\ \mathcal{R}\ \psi\equiv\neg(\neg\varphi\ \mathcal{U}\ \neg\psi)$</li>
<li>$\square\ \varphi \equiv\neg\ \Diamond\ \neg\ \varphi\equiv\ \textit{false}\ \mathcal{R}\ \varphi$</li>
<li>$\Diamond\ \varphi\equiv\textit{true} \ \mathcal{U}\ \varphi$</li>
</ul>
<h3 id="Weak-until-mathcal-W-and-Mighty-release-mathcal-M"><a href="#Weak-until-mathcal-W-and-Mighty-release-mathcal-M" class="headerlink" title="Weak until $\mathcal{W}$ and Mighty release $\mathcal{M}$"></a>Weak until $\mathcal{W}$ and Mighty release $\mathcal{M}$</h3><p><strong>W</strong>eak Until is <strong>U</strong>ntil that accepts no stop conditions <strong>F</strong>orever, or <strong>R</strong>elease that include itself as the stop conditions:</p>
<ul>
<li>$\varphi\ \mathcal{W}\ \psi\equiv(\varphi\ \mathcal{U}\ \psi) \vee \square\ \psi\equiv\psi\ \mathcal{R}\ (\psi\vee\varphi)$</li>
</ul>
<p><strong>M</strong>ighty release is forced to <strong>R</strong>elease <strong>F</strong>inally, or simply <strong>U</strong>ntil both propositions becomes $\textit{true}$:</p>
<ul>
<li>$\varphi\ \mathcal{W}\ \psi\equiv(\varphi\ \mathcal{R}\ \psi) \wedge \Diamond\ \varphi\equiv\psi\ \mathcal{U}\ (\psi\wedge\varphi)$</li>
</ul>
<h3 id="Distributivity"><a href="#Distributivity" class="headerlink" title="Distributivity"></a>Distributivity</h3><p>$\bigcirc\ (\mathcal{X})$, $\Diamond\ (\mathcal{F})$, $\square\ (\mathcal{G})$, $\mathcal{U}$ satisfied distributivity:</p>
<ul>
<li>$\bigcirc(\varphi\vee\psi)\equiv(\bigcirc\varphi)\vee(\bigcirc\psi)$</li>
<li>$\bigcirc(\varphi\wedge\psi)\equiv(\bigcirc\varphi)\wedge(\bigcirc\psi)$</li>
<li>$\Diamond(\varphi\vee\psi)\equiv(\Diamond\varphi)\vee(\Diamond\psi)$</li>
<li>$\square(\varphi\wedge\psi)\equiv(\square\varphi)\wedge(\square\psi)$</li>
<li>$\rho\ \mathcal{U}\ (\varphi\vee\psi)\equiv(\rho\ \mathcal{U}\ \varphi)\vee(\rho\ \mathcal{U}\ \psi)$</li>
<li>$(\varphi\wedge\psi)\ \mathcal{U}\ \rho\equiv(\varphi\ \mathcal{U}\ \rho)\wedge(\psi\ \mathcal{U}\ \rho)$</li>
<li>$\bigcirc(\varphi\ \mathcal{U}\ \psi)\equiv(\bigcirc\varphi)\ \mathcal{U}\ (\bigcirc\psi)$</li>
</ul>
<h3 id="Negation-Dual"><a href="#Negation-Dual" class="headerlink" title="Negation Dual"></a>Negation Dual</h3><ul>
<li>First of all, Ne<strong>X</strong>t is a self dual:<br>$\neg\bigcirc\varphi\equiv\bigcirc\neg\varphi$ (Not in next step &#x3D; Next step won’t happened)</li>
<li><strong>F</strong>inally and <strong>G</strong>lobally are dual:<br>$\neg\Diamond\varphi\equiv\square\neg\varphi$ (Never happened eventually &#x3D; Forever never happened)<br>$\neg\square\varphi\equiv\Diamond\neg\varphi$ (Won’t happen forever &#x3D; eventually won’t happen anymore)</li>
<li><strong>U</strong>ntil and <strong>R</strong>elease are dual:<br>$\neg(\varphi\ \mathcal{U}\ \psi)\equiv\neg\varphi\ \mathcal{R}\ \neg\psi$ ($\psi$ won’t happen until $\varphi$ stops &#x3D; $\psi$ can’t happen unless $\varphi$ stops)<br>$\neg(\varphi\ \mathcal{R}\ \psi)\equiv\neg\varphi\ \mathcal{U}\ \neg\psi$ (Never stop $\psi$ with $\varphi$ &#x3D; $\varphi$ never happens, if it does, that means $\psi$ has been stopped)</li>
<li>Similarly, <strong>W</strong>eak Until and <strong>M</strong>ighty Release are also dual:<br>$\neg(\varphi\ \mathcal{W}\ \psi)\equiv\neg\varphi\ \mathcal{M}\ \neg\psi$<br>$\neg(\varphi\ \mathcal{M}\ \psi)\equiv\neg\varphi\ \mathcal{W}\ \neg\psi$</li>
</ul>
<h3 id="Special-temporal-properties"><a href="#Special-temporal-properties" class="headerlink" title="Special temporal properties"></a>Special temporal properties</h3><ul>
<li>$\Diamond\varphi\equiv\Diamond\Diamond\varphi$<br>(<strong>F</strong>inally <strong>F</strong>inally $\varphi$ is $\textit{true}$)</li>
<li>$\square\varphi\equiv\square\square\varphi$<br>($\varphi$ is always always $\textit{true}$)</li>
<li>$\varphi\ \mathcal{U}\ \psi\equiv\varphi\ \mathcal{U}\ (\varphi\ \mathcal{U}\ \psi)$<br>($\varphi$ is $\textit{true}$ <strong>U</strong>ntil $\psi$ become $\textit{true}$ &#x3D; $\varphi$ is $\textit{true}$ <strong>U</strong>ntil, if “$\varphi$ is $\textit{true}$ <strong>U</strong>ntil $\psi$ become $\textit{true}$” is $\textit{true}$)</li>
<li>$\Diamond\varphi\equiv\varphi\vee \bigcirc(\Diamond\varphi)$<br>( $\varphi$ <strong>F</strong>inally becomes $\textit{true}$ &#x3D; either now $\varphi$ is $\textit{true}$ or in ne<strong>X</strong>t step $\varphi$ <strong>F</strong>inally becomes $\textit{true}$)</li>
<li>$\square\varphi\equiv\varphi\wedge \bigcirc(\square\varphi)$<br>( $\varphi$ is always $\textit{true}$ &#x3D; now $\varphi$ is $\textit{true}$ and in ne<strong>X</strong>t step $\varphi$ is also always $\textit{true}$)</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this section, we have go through basic sytanx and properties of LTL. In next section we will try to apply the formula to some systems and $\omega$-languages.</p>
<hr>
<p>Next chapter: <a href="../agv6-2/">Expressing Program Properties using LTL</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-22T15:36:01.000Z" title="22/11/2024, 16:36:01">2024-11-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.414Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">9 minutes read (About 1354 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv5-3/">AGV 5.3 -- Complement Büchi Automaton with Odd Ranking</a></p><div class="content"><p>Previous chapter: <a href="../agv5-2/">Ranking of DAG</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In <a href="../agv4-2/">section 4.2</a>, we have shown the complementation construction for <strong>deterministic Büchi Automata</strong>.</p>
<p>Now, by using DAG we can construct complement automaton of any Büchi Automata, with the help of the definition of <code>odd ranking</code> and the new function <strong>Level Ranking</strong>.</p>
<h2 id="Level-Ranking"><a href="#Level-Ranking" class="headerlink" title="Level Ranking"></a>Level Ranking</h2><blockquote>
<p>$\textbf{Definition 5.3. }\text{(Level Ranking). Consider a Büchi Automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize(F)).\newline\text{A level ranking }\ell\text{ is a pair }(S,g)\text{ such that:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ S\subseteq Q,\newline<br>\hspace{1cm} \cdot \ g:S\rightarrow\lbrace 0,\dots,2|Q|\rbrace\text{ with }g(q)\text{ necessarily even if }q\in F.\end{array}\newline \ \newline\text{We also denote: }$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ \textsf{Lvlrks}&amp;&#x3D;&amp;\text{the (finite) set of level ranks, and }\newline<br>\hspace{1cm} \cdot \ \textsf{Initrks}&amp;&#x3D;&amp;\text{the set of level ranks s.t. }S&#x3D;I\end{array}\newline \ \newline<br>\hspace{1cm}\text{We say that a level ranking }\ell’\text{, given by }(S’,g’)\text{ cover }\ell\text{, given by }(S,g)\text{ for }\sigma\in\Sigma,\newline\text{if }S’&#x3D;\lbrace q’\mid(q,\sigma,q’)\in T\rbrace\text{ and for all }q\in S,q’\in S’\text{ with }(q,\sigma,q’)\in T\text{, it holds that } g’(q’)\leq g(q).$</p>
</blockquote>
<p>Here, the <code>level ranking</code> refers to a pair that contains set of states that share the same ranking.</p>
<h3 id="ell’-covers-ell"><a href="#ell’-covers-ell" class="headerlink" title="$\ell’$ covers $\ell$ ?"></a>$\ell’$ covers $\ell$ ?</h3><p>The last part of the definition states that one level ranking is <strong>covering</strong> the other if the following satisfied:</p>
<ul>
<li>Let $\ell’&#x3D;(S’,g’)$ and $\ell&#x3D;(S,g)$ for $\sigma\in\Sigma$</li>
<li>$q$ are the states that in the set $S$, so as $q’$ are in $S’$</li>
<li><strong>All states $q’$ are some successors of some states</strong> $q, \ (S’&#x3D;\lbrace q’\mid(q,\sigma,q’)\in T\rbrace)$</li>
<li>for all $q\in S,q’\in S’, (q,\sigma,q’)\in T$, <strong>the rank of $q’$ is lower than $q, \ (g’(q’)\leq g(q))$</strong></li>
</ul>
<p>That means the whole level’s successors will never have higher rank than itself.</p>
<h2 id="Complement-Automaton-Construction"><a href="#Complement-Automaton-Construction" class="headerlink" title="Complement Automaton Construction"></a>Complement Automaton Construction</h2><p>By <a href="../agv5-2/">lemma 5.1</a>, we know that a word $\alpha$ that is rejected by $\mathcal{A}$ has an <code>odd ranking</code> on the run DAG of $\mathcal{A}$ on $\alpha$.<br>Now our complement will do the opposite: it only accepts the word that has <code>odd ranking</code>.</p>
<p>To achieve this, we construct the <code>odd ranking</code>, level by level, by assigning ranks to vertices.<br>The definition of <code>level ranks</code> and <code>covering</code> for a letter ensure that the requirements of a ranking are satisfied.</p>
<p>Through the acceptance condition, we ensure that the ranking is <code>odd</code>, i.e., there is no infinite path that consists only of even-ranked vertices.</p>
<blockquote>
<p>$\textbf{Construction 5.1. }\text{Given a Büchi Automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ that recognizes}\newline\text{the language }L\text{, we construct a Büchi Automaton}$ $$\newline \mathcal{A’}&#x3D;(\Sigma,\textsf{Lvlrks}\times\textsf{OnEvenPath},I’,T’,\small\text{BÜCHI}\normalsize(F))$$ $\text{that recognizes the language }\Sigma^\omega\setminus L\text{ as follows.}$<br>$\begin{array}{lrl}<br>\hspace{0.5cm} \cdot &amp;\textsf{OnEvenPath} &#x3D; &amp; 2^Q, \text{tracking states in the current level,} \newline<br>\hspace{0.5cm} \cdot &amp;I’&#x3D; &amp; \lbrace (\ell,R) \mid \ell \in \textsf{InitRks, } \ell \text{ is given by } (S,g) \text{, and } R &#x3D; \lbrace q \mid g(q) \text{ is even} \rbrace \rbrace \newline<br>\hspace{0.5cm} \cdot &amp;T’&#x3D; &amp; \textsf{NewEvenPaths} \cup \textsf{ContinueEvenPaths}, \text{ where} \newline<br>\hspace{0.5cm} &amp;&amp; \hspace{0.9cm}\textsf{NewEvenPaths}&#x3D;\lbrace ((\ell,\varnothing),\sigma,(\ell’,R’)) \mid \ell’ \text{ covers } \ell \text{ for } \sigma, \newline<br>\hspace{0.5cm} &amp;&amp; \hspace{4.8cm} \ell’ \text{ is given by } (S’,g’), \newline<br>\hspace{0.5cm} &amp;&amp; \hspace{4.8cm} \text{and } R’ &#x3D; \lbrace q’ \mid g’(q’) \text{ is even} \rbrace \rbrace \newline<br>\hspace{0.5cm} &amp;&amp; \textsf{ContinueEvenPaths} &#x3D; \lbrace ((\ell,R),\sigma,(\ell’,R’)) \mid R \neq \varnothing, \ell’ \text{ covers } \ell \text{ for } \sigma,\newline<br>\hspace{0.5cm} &amp;&amp; \hspace{4.8cm} \ell’ \text{ is given by } (S’,g’)\text{, and}\newline<br>\hspace{0.5cm} &amp;&amp; \hspace{4.8cm} R’ &#x3D; \lbrace q’ \mid (q,\sigma,q’) \in T, q \in R, \text{ and } g’(q’) \text{ is even} \rbrace \rbrace \newline<br>\hspace{0.5cm} \cdot &amp;F’ &#x3D; &amp; \textsf{Lvlrks} \times \lbrace \varnothing \rbrace.<br>\end{array}$</p>
</blockquote>
<h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>$Q’ &#x3D; \textsf{Lvlrks}\times\textsf{OnEvenPath}:$ all states contain their <code>level ranking</code> and set of all states that is tracked currently (states would be dropped if it leads to odd-ranked vertex).</p>
<p>$I’:$ The initial state contains the initial <code>level ranking</code> ($\textsf{Lvlrks}$), and the set of all <code>even ranking</code> states ($R$).</p>
<p>$T’:$ We have transitions $\textsf{NewEvenPaths}$ and $\textsf{ContinueEvenPaths}$. Both share some properties in common.</p>
<ul>
<li>all the states are <code>covered</code> by their successors,</li>
<li>their successors only keep track on <strong>even ranking</strong> states,</li>
<li>$\textsf{ContinueEvenPaths}$ requires that the current states must keep track on <strong>even ranking</strong> states already</li>
</ul>
<p>$F’:$ Accepting states are those has no infinite path that consists only of <code>even-ranked</code> vertices.(<code>odd ranking</code>).</p>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Now we can try to verify the Lemma with our construction:</p>
<blockquote>
<p>$\textbf{Lemma 5.2. }\textit{The automaton of Construction 5.1 has an accepting run on input }\alpha\newline\textit{if and only if the run DAG of }\mathcal{A}\textit{ on }\alpha\textit{ has an odd ranking.}$</p>
</blockquote>
<p>The run of the automaton on the input word builds a potential ranking, level by level. Note that the level-by-level guessing of the ranking is the only source of non-determinism. But if the guess is indeed an <code>odd ranking</code>, then the automaton has a unique run.</p>
<p>In the construction, we used <code>level rankings</code> to ensure the definition of <code>ranking</code> is satisified, so instead of verify whether it is <code>odd ranking</code>, we only need to verify that in the guessed ranking, there is no infinite path of even-ranked vertices.</p>
<p>At any given point, the second component ($\textsf{OnEvenPath}&#x2F;R$) in the state of the constructed automaton tracks a “batch” of paths that traverse <strong>solely through even-ranked vertices</strong>. Paths that hit an <strong>odd-ranked vertex</strong> are dropped from the batch. The <strong>acceptance condition</strong> enforces that every batch that is followed must be eventually be <strong>emptied</strong>.</p>
<blockquote>
<p><em><strong>Odd ranking &#x3D; no infinite path of even-ranked vertices &#x3D; eventually every batch are emptied</strong></em></p>
</blockquote>
<p>So we can rephrase the lemma as “The run is accepting if and only if <strong>eventually every batch are emptied</strong>“.</p>
<h3 id="If-the-run-is-accepting-then-eventually-every-batch-are-emptied"><a href="#If-the-run-is-accepting-then-eventually-every-batch-are-emptied" class="headerlink" title="If the run is accepting, then eventually every batch are emptied"></a>If the run is accepting, then eventually every batch are emptied</h3><p>This condition is clearly necessary for the guessed ranking to be odd: if there is eventually a batch that is never emptied, this corresponds to an infinite path of <code>even-ranked</code> vertices in the run DAG, violating <strong>requirement 3 (The rank cannot increase upon traversing an edge)</strong>.</p>
<p>Why? Because as long as we have one empty batch, the ranking of that batch will definitely be hihger than the those which are not empty (consider the definition of <code>rank</code> function and pruning), and any states will never have high rank than their successors.</p>
<h3 id="If-eventually-every-batch-are-emptied-then-the-run-is-accepting"><a href="#If-eventually-every-batch-are-emptied-then-the-run-is-accepting" class="headerlink" title="If eventually every batch are emptied, then the run is accepting"></a>If eventually every batch are emptied, then the run is accepting</h3><p>Assume we have non accepting run that have emptied batch, which means there is an infinite path of <code>even-ranked</code> vertices in the run DAG.</p>
<p>Now suppose this run has the batch-tracking set $\textsf{OnEvenPath}$ is emptied infinitely often. That means in the infinite path of <code>even-ranked</code> vertices there is an level $n$ so that $\textsf{OnEvenPath}$ is emptied at step $n$.</p>
<p>Because this is an infinite path of even-ranked vertices, once $\textsf{OnEvenPath}$ is emptied at step $n$, the next transition will be $\textsf{NewEvenPath}$. Which means there is a successor in level $n+1$ that has an <code>even rank</code>.</p>
<p>Since the path is infinite, subsequent transitions will be $\textsf{ContinueEvenPaths}$, and the even-rank vertices will be remained in the set of $\textsf{OnEvenPath}$. Which contradicts that the run have emptied batch. Therefore this non accepting run that have emptied batch do not exist.</p>
<hr>
<p>Next chapter: <a href="../agv6-1/">Linear-Time Temporal Logic (LTL)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/3/">Previous</a></div><div class="pagination-next"><a href="/page/5/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link is-current" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>