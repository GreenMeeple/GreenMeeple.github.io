<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>GreenMeeple</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="GreenMeeple"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="GreenMeeple"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="72x72" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="96x96" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="128x128" href="/img/avatar.png"><link rel="apple-touch-icon" sizes="256x256" href="/img/avatar.png"><meta property="og:type" content="blog"><meta property="og:title" content="GreenMeeple"><meta property="og:url" content="https://greenmeeple.github.io/"><meta property="og:site_name" content="GreenMeeple"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://greenmeeple.github.io/img/og_image.png"><meta property="article:author" content="Alex Li"><meta property="article:tag" content="Coding, Boardgames, Language learning."><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://greenmeeple.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://greenmeeple.github.io"},"headline":"GreenMeeple","image":["https://greenmeeple.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Alex Li"},"publisher":{"@type":"Organization","name":"GreenMeeple","logo":{"@type":"ImageObject","url":"https://greenmeeple.github.io/img/logo.png"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="GreenMeeple" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script data-ad-client="ca-pub-5112876356744847" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-21T00:19:18.000Z" title="21/11/2024, 01:19:18">2024-11-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.413Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">8 minutes read (About 1245 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv5-2/">AGV 5.2 -- Ranking of DAG</a></p><div class="content"><p>Previous chapter: <a href="../agv5-1/">Infinite Directed Acyclic Graph (DAG)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Ranking"><a href="#Ranking" class="headerlink" title="Ranking"></a>Ranking</h2><p>last section, we have introduced the <strong>DAG</strong> and the <strong>pruning method</strong> to reason about the run of the word on a non-deterministic Büchi automaton. We know that pruning can be use to prove the <strong>non-acceptance</strong> of the word by automaton is we obtains an empty graph eventually.</p>
<p><img src="/../images/notes/uds/agv/5_1_g1.png"></p>
<p>In this section, we will introduce <strong>ranking</strong>, which can formalize our pruning construction.</p>
<blockquote>
<p>$\textbf{Definition 5.2. }\text{(Ranking). A }\textit{ranking}\text{ on a run DAG } G&#x3D;(V,E)\text{ is a function }f:V\rightarrow\newline\lbrace 0,\dots,2|Q|\rbrace\text{ such that:}$<br>$\begin{array}{l}\hspace{1cm} 1. \ \text{ If }q\in F\text{, then }f((q,i))\text{ is even for all }i.\newline\hspace{1cm} 2. \ \text{ If }(v,v’)\in E\text{, we have that }f(v’)\leq f(v).\end{array}\newline$<br>$\text{A ranking } f\text{ is }\textit{odd}\text{ if, for each even }j\text{, there is no infinite path in }G\text{ that consists only }\newline\text{of verticies }v\text{ such that }f(v)&#x3D;j.$</p>
</blockquote>
<p>By the above definition, we can see:</p>
<ol>
<li>All verticies that contains state q (the accepting state) are marked as even rank.</li>
<li>Verticies will never have lower rank than their successors.</li>
</ol>
<p>Most importantly, it introduced a new concept: <strong>Odd Ranking</strong>. Meaning that the run of the DAG is rejected.</p>
<h2 id="From-Ranking-to-Rank"><a href="#From-Ranking-to-Rank" class="headerlink" title="From Ranking to Rank"></a>From Ranking to Rank</h2><p>Now, let’s consider the function $rank:V\rightarrow\lbrace 0,\dots,2|Q|\rbrace$, where</p>
<ul>
<li>$rank(q,i)&#x3D;2j$ iff $(q,i)$ is <strong>endangered</strong> in $G_{2j}$, and</li>
<li>$rank(q,i)&#x3D;2j+1$ iff $(q,i)$ is <strong>safe</strong> in $G_{2j+1}$.</li>
</ul>
<p><img src="/../images/notes/uds/agv/5_2_dag.png"></p>
<p>By tracking our pruning procedure, we can easily identify their rank now.<br>Blue verticies that remove in $G_1$ are <strong>safe</strong>, thus their rank are 1, and so as orange (2), green (3) and red (4).</p>
<h2 id="From-Rank-to-Odd-Ranking"><a href="#From-Rank-to-Odd-Ranking" class="headerlink" title="From Rank to Odd Ranking"></a>From Rank to Odd Ranking</h2><p>Now back to odd ranking, by our new function $rank$, we can prove the following lemma.</p>
<blockquote>
<p>$\textbf{Lemma 5.1. }\newline\textit{A Büchi automaton }\mathcal{A}\textit{ reject the word }\alpha\textit{ iff the run DAG of }\mathcal{A}\textit{ on }\alpha\textit{ has an odd ranking}$</p>
</blockquote>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><blockquote>
<p><strong>If the run DAG of $\mathcal{A}$ on $\alpha$ has an odd ranking, then $\alpha$ is rejected</strong></p>
</blockquote>
<p>By the definition above, we know that graph with odd ranking has <strong>no infinite path that settles on only even rank $f(v)&#x3D;j$</strong>. Which means:</p>
<ul>
<li>every run of $\mathcal{A}$ on $\alpha$ <strong>gets stuck</strong>, or,</li>
<li>eventually <strong>settles on vertices with a constant odd rank</strong>, since ranks are not increasing.</li>
</ul>
<p>In which case the run eventually only visits states that are not accepting.</p>
<blockquote>
<p><strong>If $\alpha$ is rejected, then the run DAG of $\mathcal{A}$ on $\alpha$ has an odd ranking</strong></p>
</blockquote>
<p>Since we know pruning leads to rejecting with function $rank$. Therefore, instead of using odd ranking directly, we try to show the function $rank$ is the odd ranking. To prove this, we need to show that:</p>
<ol>
<li>All vertices are indeed pruned away, latest by step $2|Q|$.</li>
<li>Accepting vertices must have an even rank</li>
<li>The rank cannot increase upon traversing an edge.</li>
<li>There is no infinite path that consists only of vertices of even rank.</li>
</ol>
<h3 id="Requirement-1-All-vertices-are-indeed-pruned-away-latest-by-step-2-Q"><a href="#Requirement-1-All-vertices-are-indeed-pruned-away-latest-by-step-2-Q" class="headerlink" title="Requirement 1: All vertices are indeed pruned away, latest by step $2|Q|$"></a>Requirement 1: All vertices are indeed pruned away, latest by step $2|Q|$</h3><p>Here, we define the <strong>width</strong> of a level $j$ in a graph $G_i$ as the number of vertices of the form $(q,j)$ in $G_i$.<br><img src="/../images/notes/uds/agv/5_2_width.png"></p>
<p>Assume we are in step $2j$, it removes all <code>endangered</code> vertices from $G_{2j}$. Then how would $G_{2j+1}$ become?</p>
<ol>
<li>become empty (all vertices in $G_{2j}$ are <code>endangered</code>)</li>
<li>still has infinitely many vertices<br>(by definition, vertices that not <code>endangered</code> always have some infinite path, also because $\infty-n&#x3D;\infty$)</li>
</ol>
<p>In scenario <strong>2</strong>, since our <code>premise</code> is that the word is <strong>rejected</strong>, there must exist a <code>safe</code> vertex in $G_{2j+1}$. If there’s no <code>safe</code> vertex, then those vertices are either accepting, or has a path to accepting vertex, which contradicts to our premise.</p>
<blockquote>
<p><em><strong>a) Each iteration there must be at least one <code>safe</code> vertex being removed</strong></em></p>
</blockquote>
<p>Among all the <code>safe</code> vertices in $G_{2j+1}$, consider the vertex $(q,m)$ which has the smallest $m$ (closest to the beginning). All descendants of this vertex in $G_{2j+1}$ are also <code>safe</code> (because <code>safe</code> refers to the whole path).</p>
<p>Therefore, these <code>safe</code> vertices will be pruned away in step $2j+1$. Observe the affect towards the width after these deletions:</p>
<ul>
<li>At the beginning of iteration $0$, each level has width at most $|Q|$ (max. no. of states).</li>
<li>In every iteration $j$, the widths of all levels $i\geq m$ decrease by at least 1.<br>(because vertex $(q,m)$ and all its descendants in $i\geq m$ are removed)</li>
</ul>
<blockquote>
<p><em><strong>b) If one <code>safe</code> vertex is removed, all its descendants will also be removed</strong></em></p>
</blockquote>
<p>By <em><strong>a)</strong></em> and <em><strong>b)</strong></em>, we can ensure that after $|Q|$ iterations of <code>safe</code> vertices removal there must be some level $m$ contains no more vertices, which means now the graph terminate in $m$ and it is a <strong>finite graph</strong>.</p>
<p>By including the iteration of <code>endangered</code> vertices, we can conclude that in step $2|Q|$, $G_{2|Q|}$ must be a finite graph, all vertices are <code>endangered</code>, thus it will prune all vertices away.</p>
<h3 id="Requirement-2-Accepting-vertices-must-have-an-even-rank"><a href="#Requirement-2-Accepting-vertices-must-have-an-even-rank" class="headerlink" title="Requirement 2: Accepting vertices must have an even rank"></a>Requirement 2: Accepting vertices must have an even rank</h3><p>Since accepting vertices are not <code>safe</code>, and our premise it that the word is rejected. That means the path contains accepting verticeis can only be <strong>finite</strong>, which means they are always <code>endangered</code>.</p>
<p>In our rank function, <code>endangered</code> vertices have even rank and thus accepting vertices always have even rank.</p>
<h3 id="Requirement-3-The-rank-cannot-increase-upon-traversing-an-edge"><a href="#Requirement-3-The-rank-cannot-increase-upon-traversing-an-edge" class="headerlink" title="Requirement 3: The rank cannot increase upon traversing an edge"></a>Requirement 3: The rank cannot increase upon traversing an edge</h3><p>Suppose there is a $(q’,i+1)$ that is pruned later than $(q,i)$. Consider the step $j$ at which $(q,i)$ is pruned. The graph $G_j$ would have contained both vertices, along with their edge.</p>
<p>If $j$ is even, it means that $(q,i)$ has even rank, and <code>endangered</code> in $G_j$ , and hence so must be its successor $(q’,i+1)$, meaning that it is pruned at step $j$.</p>
<p>If $j$ is odd, then $(q,i)$ was established to be <code>safe</code> in Gj , implying the safety of its successor too. In both cases, the pruning of $(q’,i+1)$ in the same step is inevitable.</p>
<h3 id="Requirement-4-There-is-no-infinite-path-of-only-even-ranked-vertices"><a href="#Requirement-4-There-is-no-infinite-path-of-only-even-ranked-vertices" class="headerlink" title="Requirement 4: There is no infinite path of only even-ranked vertices"></a>Requirement 4: There is no infinite path of only even-ranked vertices</h3><p>If such a path exists, since ranks do not increase along a path, and there are only finitely many ranks, this path will eventually consist only of vertices of rank $2j$.</p>
<p>However, only <code>endangered</code> verticies will have even rank in $G_{2j}$, and endangered vertices only have finite paths.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>With the above properties and proofs, we know that:</p>
<ul>
<li>the run DAG of $\mathcal{A}$ on $\alpha$ has an odd ranking &#x3D; $\alpha$ is rejected</li>
<li>Pruning method with $rank$ function &#x3D; odd ranking</li>
</ul>
<blockquote>
<p>So if a word is rejected, its run DAG always becomes an empty graph after pruning, and if a run DAG eventually becomes an empty graph after pruning, it must be rejected by $\mathcal{A}$.</p>
</blockquote>
<p>With these definition, we can now construct complementation of Büchi automaton $\mathcal{A}$ using the run DAG of $\mathcal{A}$ and the odd ranking. Let see how is it done in the next section.</p>
<hr>
<p>Next chapter: <a href="../agv5-3/">Complement Büchi Automaton with Odd Ranking</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-20T15:44:16.000Z" title="20/11/2024, 16:44:16">2024-11-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.424Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 893 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv5-1/">AGV 5.1 -- Infinite Directed Acyclic Graph (DAG)</a></p><div class="content"><p>Previous chapter: <a href="../agv4-2/">Complementation of deterministic Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Reasoning-about-all-runs-of-an-automaton"><a href="#Reasoning-about-all-runs-of-an-automaton" class="headerlink" title="Reasoning about all runs of an automaton"></a>Reasoning about all runs of an automaton</h2><p>Since complementation inevitably introduce <strong>nondeterminism</strong>, we need to check whether <strong>all</strong> runs of the automaton on the word are <strong>rejecting</strong> to determine whether a word is in the complement of the language recognized by this Büchi automaton.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Consider the following nondeterministic Büchi automaton $\mathcal{A}$. Its language consists of all infinite words over $\lbrace a,b\rbrace$ with infinitely many <em>b</em>s, i.e., $(a^*b)^\omega$:</p>
<p><img src="/../images/notes/uds/agv/5_1_eg.png"></p>
<blockquote>
<p>$\textbf{Definition 5.1. }\text{Let }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ be a Büchi automaton. The run DAG of }\mathcal{A}\newline\text{on a word }\alpha\in\Sigma^\omega\text{ is the directed acylic graph }G&#x3D;(V,E)\text{, where}$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ V&amp;&#x3D;&amp;\cup_{i\geq0}(Q_i\times\lbrace i\rbrace)\text{ with }Q_0&#x3D;I\text{ and}\newline<br>\hspace{1.1cm} \ Q_{i+1}&amp;&#x3D;&amp;\lbrace q’\mid(q,\alpha(i),q’)\in T\text{ for some }q\in Q\rbrace\newline<br>\hspace{1cm} \cdot \ E&amp;&#x3D;&amp;\lbrace((q,i),(q’,i+1))\mid i\geq 0,(q,\alpha(i),q’)\in T\rbrace.\end{array}$<br>$\text{For a natural number }i\text{, we refer to the set }Q_i\text{ as the }\textit{level }i\text{ of the DAG.}$</p>
</blockquote>
<p>Using <strong>infinite directed acyclic graph (DAG)</strong> to represent the set of all runs on a particular word, e.g., $ababa^\omega$.</p>
<p><img src="/../images/notes/uds/agv/5_1_g1.png"></p>
<p>In the above example: the word $\alpha&#x3D;ababa^\omega$ has only two <em>b</em>‘s and hence must be rejected by $\mathcal{A}$.</p>
<p>Since the automaton is nondeterministic, a single word of $\mathcal{A}$ will have multiple runs on $\alpha$, represented by each <em>path in DAG</em>. The path is called accepting <strong>if and only if</strong> its corresponding run is accepting, i.e., the path visits $F\times\mathcal{A}$ infinitely often.</p>
<h2 id="Graph-Pruning"><a href="#Graph-Pruning" class="headerlink" title="Graph Pruning"></a>Graph Pruning</h2><p>To show the <strong>non-acceptance</strong> of $\alpha$ by $\mathcal{A}$, we can systematically identifying and pruning away vertices of the run DAG that only lead to rejecting paths until the graph is empty using the following definitions:</p>
<table>
<thead>
<tr>
<th align="left">Vertices in DAG</th>
<th align="left">Defintiion</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Endangered</code></td>
<td align="left">when they only have <strong>finitely many descendants</strong></td>
</tr>
<tr>
<td align="left"><code>Safe</code></td>
<td align="left">when they are <strong>not in</strong> $F\times\mathcal{A}$, and <strong>none of its descendants</strong> are in $F\times\mathcal{A}$ either</td>
</tr>
</tbody></table>
<p>We start with a graph $G_0&#x3D;G$. Each iteration $j\geq 0$ of our pruning will consist of two steps:</p>
<ol>
<li>in step $2j$, the graph &#x3D; $G_{2j}$, remove all <code>endangered</code> vertices, graph after removal &#x3D; $G_{2j+1}$</li>
<li>in step $2j+1$, the graph &#x3D; $G_{2j+1}$, remove all <code>safe</code> vertices, graph after removal &#x3D; $G_{2j+2}$</li>
</ol>
<h3 id="Step-0-Remove-endangered-vertices"><a href="#Step-0-Remove-endangered-vertices" class="headerlink" title="Step 0: Remove endangered vertices"></a>Step 0: Remove <code>endangered</code> vertices</h3><ul>
<li>Input: $G_0$ ↑ (using example above), Output: $G_1$ ↓</li>
</ul>
<p>Since there’s no <code>endangered</code> verticies, $G_0$ &#x3D; $G_1$</p>
<p><img src="/../images/notes/uds/agv/5_1_g1.png"></p>
<h3 id="Step-1-Remove-safe-vertices-marked-as-blue"><a href="#Step-1-Remove-safe-vertices-marked-as-blue" class="headerlink" title="Step 1: Remove safe vertices (marked as blue)"></a>Step 1: Remove <code>safe</code> vertices (marked as blue)</h3><ul>
<li>Input: $G_1$ ↑, Output: $G_2$ ↓</li>
</ul>
<p>As we can see all vertices that in state r stay in r forever (accepting state is q). Therefore those path can never be accepted and they are safe.</p>
<p><img src="/../images/notes/uds/agv/5_1_g2.png"></p>
<h3 id="Step-2-Remove-endangered-vertices-marked-as-red"><a href="#Step-2-Remove-endangered-vertices-marked-as-red" class="headerlink" title="Step 2: Remove endangered vertices (marked as red)"></a>Step 2: Remove <code>endangered</code> vertices (marked as red)</h3><ul>
<li>Input: $G_2$ ↑, Output: $G_3$ ↓</li>
</ul>
<p>After <code>safe</code> verticies in r are removed, paths towards r from q become dead end. Therefore they are now <code>endangered</code>.</p>
<p><img src="/../images/notes/uds/agv/5_1_g3.png"></p>
<h3 id="Step-3-Remove-safe-vertices-marked-as-blue"><a href="#Step-3-Remove-safe-vertices-marked-as-blue" class="headerlink" title="Step 3: Remove safe vertices (marked as blue)"></a>Step 3: Remove <code>safe</code> vertices (marked as blue)</h3><ul>
<li>Input: $G_3$ ↑, Output: $G_4$ ↓</li>
</ul>
<p>Now all the vertices starting from (p,3) stay in p forever. Therefore they are <code>safe</code> as well.</p>
<p><img src="/../images/notes/uds/agv/5_1_g4.png"></p>
<h3 id="Step-4-Remove-endangered-vertices-marked-as-red"><a href="#Step-4-Remove-endangered-vertices-marked-as-red" class="headerlink" title="Step 4: Remove endangered vertices (marked as red)"></a>Step 4: Remove <code>endangered</code> vertices (marked as red)</h3><ul>
<li>Input: $G_4$ ↑, Output: $G_5$ ↓</li>
</ul>
<p>Now the graph is finite, meaning all the vertices in the graph are <code>endangered</code>.</p>
<p><img src="/../images/notes/uds/agv/5_1_g5.png"></p>
<p>Therefore, graph $G_5$ will be an empty graph, which means there’s no accepting path and thus the word $ababa^\omega$ is rejected.</p>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>We start from removing <code>endangered</code> verticies in <strong>step 0</strong> because they can never infinitely reach the accepting states. Then we can remove all <code>Safe</code> verticies in <strong>step 1</strong> because they never visit accepting states anymore.</p>
<p>For the subsequent pruning, if a vertex v of the original run DAG is pruned away in step $2j$ because it is <code>endangered</code> in $G_{2j}$, it means that all paths from v in the original run DAG can reach were pruned away in the earlier steps.</p>
<p>Similarly, if a vertex v of the original run DAG is pruned away in step $2j+1$ because it is <code>safe</code> in $G_{2j+1}$, it means that v corresponds to a <strong>non-accepting state</strong>. And furthermore, all paths from v in the original run DAG either avoid accepting vertices, or eventually reach a vertex that was pruned away in the earlier steps.</p>
<p>So we can see that if a vertex is pruned away, all paths from that vertex are rejecting. Hence, if our scheme eventually obtains the empty graph, the pruning is a proof of the non-acceptance of the word by the automaton.</p>
<p>We formalize this type of reasoning as a <code>ranking</code>, which labels the vertices with numbers. We will define <code>ranking</code> in the next chapter. </p>
<hr>
<p>Next chapter: <a href="../agv5-2/">Ranking of DAG</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-19T22:12:02.000Z" title="19/11/2024, 23:12:02">2024-11-19</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.413Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">7 minutes read (About 984 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv4-2/">AGV 4.2 -- Complementation of deterministic Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv4-1/">Deterministic vs. Nondeterministic Büchi Automata</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>For regular languages, Complementation is very simple: one translates a given complete deterministic automaton $\mathcal{A}$ that recognizes some language $L\subseteq\Sigma^*$ into an automaton $\mathcal{A’}$ that recognizes the complement $\Sigma^*\setminus L$ by complementing the set of final states, i.e., $F’&#x3D;Q\setminus F$.</p>
<p>For deterministic Büchi automata, the construction is tricky, because it introduces <strong>nondeterminism</strong></p>
<blockquote>
<p>$\textbf{Construction 4.1. }\text{Let }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))\text{ be a complete deterministic Büchi}\newline\text{automaton, where we assume w.l.o.g. that } Q\neq\varnothing. \text{ We construct a Büchi automaton}\newline\mathcal{A’}&#x3D;(\Sigma,Q’,I’,T’,\small\text{BÜCHI} \normalsize (F’))\text{ with }\mathcal{L}(\mathcal{A’})&#x3D;\Sigma^\omega\setminus\mathcal{L}(\mathcal{A})\text{ as follows:}$<br>$\begin{array}{lrll}<br>\hspace{1cm} \cdot &amp;Q’&amp;&#x3D;&amp;(Q\times\lbrace 0\rbrace)\cup((Q\setminus F)\times\lbrace 1\rbrace)\newline<br>\hspace{1cm} \cdot &amp;I’&amp;&#x3D;&amp;I\times\lbrace 0\rbrace\newline<br>\hspace{1cm} \cdot &amp;T’&amp;&#x3D;&amp;\lbrace ((q,0),\sigma,(q’,i))\mid(q,\sigma,q’)\in T,i\in\lbrace 0,1\rbrace,(q’,i)\in Q’\rbrace \cup \newline<br>\hspace{1cm} \ &amp;&amp;&amp;\lbrace ((q,1),\sigma,(q’,1))\mid(q,\sigma,q’)\in T,q’,q’\in Q\setminus F\rbrace\newline<br>\hspace{1cm} \cdot &amp;F’&amp;&#x3D;&amp;(Q\setminus F)\times\lbrace 1\rbrace<br>\end{array}$</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$Q’$</td>
<td align="left">Uses two copies of the given automaton $\mathcal{A}$, mark them seperately using $\lbrace 0\rbrace$ and $\lbrace 1\rbrace$, notice that all <strong>accpeting states</strong> from $\lbrace 1\rbrace$ are eliminated</td>
</tr>
<tr>
<td align="left">$I’$</td>
<td align="left">The complemented automaton starts from initial states from $\lbrace 0\rbrace$.</td>
</tr>
<tr>
<td align="left">$T’$</td>
<td align="left">The switch from $\lbrace 0\rbrace$ and $\lbrace 1\rbrace$ happens nondeterministically. And once you enter the second copy $\lbrace 1\rbrace$, it stays forever.</td>
</tr>
<tr>
<td align="left">$F’$</td>
<td align="left">The automaton $\mathcal{A’}$ accepts if the run ends up in the second copy, which means that, on the unique run of $\mathcal{A}$ on the input word, the accepting states of $\mathcal{A}$ are only visited <strong>finitely often</strong>.</td>
</tr>
</tbody></table>
<p>Note that the resulting automaton is <strong>nondeterministic</strong>. This is, in general, <strong>unavoidable</strong>.</p>
<p>This is because there are languages, such as $L&#x3D;(b^*a)^\omega$ where the language itself is recognizable by a deterministic Buchi automaton, while its complement $\Sigma^\omega\setminus L$ can only be recognized by a nondeterministic Büchi automaton.</p>
<blockquote>
<p>$\textbf{Theorem 4.3. }\textit{For every deterministic Büchi automaton }\mathcal{A}\textit{, there exists a Büchi automaton }\mathcal{A’}\newline\textit{ such that }\mathcal{L}(\mathcal{A’})&#x3D;\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}).$</p>
</blockquote>
<h3 id="Explained-in-Human-Language"><a href="#Explained-in-Human-Language" class="headerlink" title="Explained in Human Language"></a>Explained in Human Language</h3><p>$\mathcal{L}(\mathcal{A’})\subseteq\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}):$</p>
<p>To prove that “If $\alpha$ is accepted by $\mathcal{L}(\mathcal{A’})$, then it is also accepted by the complement of $\mathcal{L}(\mathcal{A})$”, we can show that every state in $\mathcal{A’}$ is same as $\mathcal{A}$, but as long as it switched to $\lbrace 1\rbrace$, it stays forever and there is no accepting states of $\mathcal{A}$.</p>
<p>Therefore, every accepted word in $\mathcal{L}(\mathcal{A’})$ is also accepted in $\Sigma^\omega \setminus\mathcal{L}(\mathcal{A})$.</p>
<p>$\mathcal{L}(\mathcal{A’})\supseteq\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}):$</p>
<p>To prove that “If $\alpha$ is accepted by the complement of $\mathcal{L}(\mathcal{A})$, then it is also accepted by $\mathcal{L}(\mathcal{A’})$”, we assume there’s a word $\alpha$ that is not accepted by $\mathcal{L}(\mathcal{A})$.</p>
<p>Since $\mathcal{A}$ is <strong>complete</strong> and <strong>deterministic</strong>, so the run on $\alpha$ is still infinite, yet <strong>never</strong> visit the accepted states <strong>infinitely often</strong>. i.e. starting from certain position, it will never visit the accepting states anymore.</p>
<p>We can treat that position as the switch from $\lbrace 0\rbrace$ and $\lbrace 1\rbrace$ in $\mathcal{A’}$ occurs. And therefore $\alpha$ is an accepted word in $\mathcal{L}(\mathcal{A’})$.</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>Let $\mathcal{A’}$ be constructed from the given deterministic Büchi automaton $\mathcal{A}$ (which we<br>assume, w.l.o.g., to be complete) by <em>Construction 4.1.</em> We prove that $\mathcal{L}(\mathcal{A’})&#x3D;\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}).$</p>
<p>$\mathcal{L}(\mathcal{A’})\subseteq\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}):$</p>
<p>For every word $\alpha\in\mathcal{L}(\mathcal{A’})$ we have an accepting run: $r’:(q_0,0)(q_1,0)\dots(q_j,0)(q’_0,1)(q_1,1)\dots$ on $\mathcal{A}$. Hence, $r:q_0q_1\dots q_jq_0’q_1’\dots$ is the unique run of $\mathcal{A}$ on $\alpha$. Since $q_0’,q_1’,\dots\in Q\setminus F$, we have that $\text{Inf}(r)\subseteq Q\setminus F$. Hence, $r$ is not accepting and $\alpha\in\Sigma^\omega\setminus\mathcal{L}(\mathcal{A})$.</p>
<p>$\mathcal{L}(\mathcal{A’})\supseteq\Sigma^\omega \setminus\mathcal{L}(\mathcal{A}):$</p>
<p>Let $\alpha\notin\mathcal{L}(\mathcal{A’})$ be some word that is not in the language of $\mathcal{A}$. Since $\mathcal{A}$ is complete and deterministic, there exists a unique run $r:q_0q_1q_2\dots$ of $\mathcal{A}$ on $\alpha$ and  $\text{Inf}(r)\cap F&#x3D;\varnothing$. Thus, there exists a $k\in\mathbb{N}$ such that $q_j\notin F$ for all $j &gt; k$.</p>
<p>This gives us the run: $r’:(q_0,0)(q_1,0)\dots(q_j,0)(q’_0,1)(q_1,1)\dots$ of $\mathcal{A’}$ on $\alpha$ with $\text{Inf}(r)\subseteq ((Q\setminus F)\times\lbrace 1\rbrace)&#x3D;F’$. Hence, $r’$ is accepting and therefore $\alpha\in\mathcal{L}(\mathcal{A’})$.</p>
<h3 id="Example-mathcal-L-mathcal-A-b-ast-a-omega-and-mathcal-L-mathcal-A’-a-b-ast-b-omega"><a href="#Example-mathcal-L-mathcal-A-b-ast-a-omega-and-mathcal-L-mathcal-A’-a-b-ast-b-omega" class="headerlink" title="Example: $\mathcal{L}(\mathcal{A})&#x3D;(b^\ast a)^\omega$ and $\mathcal{L}(\mathcal{A’})&#x3D;(a+b)^\ast b^\omega$"></a>Example: $\mathcal{L}(\mathcal{A})&#x3D;(b^\ast a)^\omega$ and $\mathcal{L}(\mathcal{A’})&#x3D;(a+b)^\ast b^\omega$</h3><p><img src="/../images/notes/uds/agv/4_2_eg.png"></p>
<p>Note that, since not all $\omega$-regular languages can be recognized by deterministic Büchi automata, Construction 4.1 does not provide us with a complementation construction for all $\omega$-regular languages. Such a general construction is the subject of the following section.</p>
<hr>
<p>Next chapter: <a href="../agv5-1/">Infinite Directed Acyclic Graph (DAG)</a></p>
<p>Further Reading: <a href=""></a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-17T23:11:57.000Z" title="18/11/2024, 00:11:57">2024-11-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.413Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 809 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv4-1/">AGV 4.1 -- Deterministic vs. Nondeterministic Büchi Automata</a></p><div class="content"><p>Previous chapter: <a href="../agv3-5/">Büchi’s Characterization Theorem</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the theory of automata over finite words, we have <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Powerset_construction">Rabin-Scott powerset construction</a>, which converts a <em>nondeterministic automaton</em> over finite words into a <em>deterministic automaton</em> that <strong>recognizes the same language</strong>. This shows that nondeterminism does not make automata over finite words more expressive (but makes it more concise as the construction produces an exponential number of states).</p>
<p>The situation is different for Büchi automata: even though the language $L &#x3D; (a+b)^*b^\omega$ is clearly <em>Büchi-recognizable</em>, there is, as the following theorem shows, <strong>no deterministic Büchi automaton that recognizes L</strong>.</p>
<h2 id="Deterministic-vs-nondeterministic-Buchi-automata"><a href="#Deterministic-vs-nondeterministic-Buchi-automata" class="headerlink" title="Deterministic vs. nondeterministic Büchi automata"></a>Deterministic vs. nondeterministic Büchi automata</h2><blockquote>
<p>$\textbf{Theorem 4.1. }\textit{Language $L&#x3D;(a+b)^*b^\omega$ is not recognizable by deterministic Büchi Automata}$</p>
</blockquote>
<p>Starting a base case $b^\omega$, we add $(a+b)$ as the prefix one by one. Can we express the  <strong>kleene star</strong>?<br>That is, is the automaton only accept <strong>finitely many</strong> $(a+b)$?</p>
<h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Assume, by way of contradiction, that $L$ is recognizable by the deterministic Büchi automaton $\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize(F))$. Since $\alpha_0&#x3D;b^\omega$ is in $L$, there is an unique run</p>
<p>$$r_0&#x3D;r_0(0)r_0(1)r_0(2)\dots$$</p>
<p>of $\mathcal{A}$ on $\alpha_0$ with $r_0(n_0)\in F$ for some $n_0\in\mathbb{N}$. Similarly, $\alpha_1&#x3D;b^{n_0}ab^\omega$ in $L$ and there is a unique run</p>
<p>$$r_1&#x3D;r_0(0)r_0(1)r_0(2)\dots r_0(n_0)r_1(n_0+1)r_1(n_0+2)\dots$$</p>
<p>of $\mathcal{A}$ on $\alpha_1$ with $r_1(n_1)\in F$ for some $n_1&gt;n_0$. Since $\mathcal{A}$ is deterministic, $r_0$ &amp; $r_1$ are identical up to position $n_0$.</p>
<p>By repeating this argument infinitely often, we obtain a word $\alpha&#x3D;b^{n_0}ab^{n_1}ab^{n_2}a\dots$ and a run $r$ with infinitely many visits to $F$. Hence, $\alpha$ is accepted by $\mathcal{A}$. However, $\alpha$ is not an element of $L$. This contradicts $L &#x3D; \mathcal{L}(\mathcal{A})$.</p>
<h2 id="Limit-Operator"><a href="#Limit-Operator" class="headerlink" title="Limit Operator"></a>Limit Operator</h2><p>We start by defining a <em>Limit Operator</em> to generate $\omega$-language using regular language. For the regular language $W$, $\overrightarrow{W}$ contains all the words that they all contain words in $W$ as substrings.</p>
<blockquote>
<p>$\textbf{Definition 4.1. }\text{(Limit). The}\textit{ limit }\overrightarrow{W}\text{ of a language }W\subseteq\Sigma^* \text{ over finite words}\newline\text{is the following language over infinite words:}$ $$\overrightarrow{W}&#x3D;\lbrace\alpha\in\Sigma^\omega\mid\text{there exist infinitely many }n\in\mathbb{N}\text{ s.t. }\alpha[0,n]\in W\rbrace.$$</p>
</blockquote>
<p>And From regular language, now we can define an $\omega$-regular language that is recognizable by deterministic Büchi Automata:</p>
<blockquote>
<p>$\textbf{Theorem 4.2. }\textit{An }\omega\textit{-language }L\subseteq\Sigma^\omega\textit{ is recognizable by a deterministic Büchi Automata}\newline\textit{iff there is a regular langauge }W\subseteq\Sigma^*\textit{ s.t. }L&#x3D;\overrightarrow{W}.$</p>
</blockquote>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>Basically, we are trying to prove $\mathcal{L}(\mathcal{A_B})&#x3D;\overrightarrow{\mathcal{L}(\mathcal{A_F})}$, where $\mathcal{L}(\mathcal{A_B})$ is a deterministic Büchi Automata and $\mathcal{L}(\mathcal{A_F})$ is a a deterministic automaton over finite words.</p>
<p>As we can see, an accepted word $\alpha\in\mathcal{L}(\mathcal{A_B})$ with have substring $\alpha[0,n]$ that is accepted by $\mathcal{L}(\mathcal{A_F})$ with infinitely many $n\in\mathbb{N}$, by the definition of the <em>limit operator</em>.</p>
<p>We can prove regular language $W$ exists if $\alpha$ exists using $\overrightarrow{W}$. Automata that accepts $W$ and $\overrightarrow{W}$ should exist, namely $\mathcal{L}(\mathcal{A_F})$ and $\overrightarrow{\mathcal{L}(\mathcal{A_F})}$ respectively.</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>We claim that the languages of a deterministic Büchi automaton $\mathcal{A}_B$ and of a deterministic<br>automaton over finite words $\mathcal{A}_F$, where the automata $\mathcal{A}_B&#x3D;(\Sigma,Q,I,T,\small\text{BÜCHI}\normalsize(F))$ and $\mathcal{A}_F&#x3D;(\Sigma,Q,I,T,F)$, constructed from the same components, are related as follows:</p>
<p>$$\mathcal{L}(\mathcal{A_B})&#x3D;\overrightarrow{\mathcal{L}(\mathcal{A_F})}.$$</p>
<p>Since every regular language is recognized by a deterministic automaton over finite words,<br>the theorem follows. To prove the claim, we consider an infinite word $\alpha\in\Sigma^\omega$.</p>
<p>$\hspace{1cm}\alpha\in\mathcal{L}(\mathcal{A_B})\newline<br>\text{iff} \hspace{0.5cm}\text{for the unique run $r$ of $\mathcal{A_B}$ on $\alpha$, Inf($r$) $\cap$ $F\neq\varnothing$}\newline \text{iff} \hspace{0.5cm} \alpha[0,n]\in\mathcal{L}(\mathcal{A_F})\text{ for infinitely many }n\in\mathbb{N}\newline<br>\text{iff} \hspace{0.5cm} \alpha\in\mathcal{L}(\mathcal{A_F})$</p>
<hr>
<p>Next chapter: <a href="../agv4-2/">Complementation of deterministic Büchi Automata</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Powerset_construction">powerset construction</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-17T16:33:21.000Z" title="17/11/2024, 17:33:21">2024-11-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.425Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 849 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-5/">AGV 3.5 -- Büchi&#039;s Characterization Theorem</a></p><div class="content"><p>Previous chapter: <a href="../agv3-4/">Closure Properties of the Büchi-recognizable languages (Concatenations)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>We are now ready to prove Büchi’s Characterization Theorem, a result from 1962.</p>
<blockquote>
<p>$\textbf{Theorem 3.6. }\text{(Büchi’s Characterization Theorem) }\newline\textit{An $\omega$-language is Büchi-recognizable iff it is $\omega$-regular.}$</p>
</blockquote>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><blockquote>
<p>p.s. Büchi-recognizable means the language can be described by a Büchi automata.</p>
</blockquote>
<p>$”\Leftarrow”$<br>We have to prove if the language is <strong>$\omega$-regular</strong>, then it is <strong>Büchi-recognizable</strong>.<br>In <a href="../agv3-2/">section 3.2</a>, we learn that an $\omega$-regular language contains 3 operators:</p>
<ul>
<li><strong>union</strong> of $\omega$-regular languages, $W_1+W_2$ (proved by Theorem <a href="../agv3-3/">3.2</a>),</li>
<li><strong>infinite concatenation</strong> of a <strong>non-empty</strong> regular language $E^\omega$ (proved by Theorem <a href="../agv3-4/">3.4</a>), and</li>
<li><strong>concatenation</strong> of regular languages and $\omega$-regular language $E\cdot W$ (proved by Theorem <a href="../agv3-4/">3.5</a>)</li>
</ul>
<p>$”\Rightarrow”$<br>We have to prove if the language is <strong>Büchi-recognizable</strong>, then it is <strong>$\omega$-regular</strong>.<br>Here, we try to construct a Büchi-recognizable using all <strong>$\omega$-regular</strong> operators.</p>
<p>We begin by constructing a <strong>regular language</strong> $W_{q,q’}$. <strong>Words</strong> of the language $w$ is accepted by some finite-word automata, with a pair of state $q,q’\in Q$ being the <strong>initial and accepting states</strong> respectively.</p>
<p>Then we try to prove that a <strong>Büchi-recognizable language</strong> $\mathcal{L}(\mathcal{A})$ equals to the regular language <strong>concatenates</strong> (<a href="../agv3-4/">3.5</a>) with the <strong>infinite concatenated</strong>, <strong>non-empty</strong> (<a href="../agv3-4/">3.4</a>) starting from the previous accepting state. That is $W_{q,q’}\cdot(W_{q’,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$.</p>
<p>On top of that, we do a set union (<a href="../agv3-3/">3.2</a>) for each pair of <strong>initial and accepting states</strong> $q,q’\in Q$, that is $\bigcup_{q\in I,q’\in F}$</p>
<blockquote>
<p>Therefore, now we only need to prove that $\mathcal{L}(\mathcal{A})&#x3D;\bigcup_{q\in I,q’\in F}W_{q,q’}\cdot(W_{q,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$.</p>
</blockquote>
<p>For the word $\alpha$ from L.H.S, it reaches $q’\in F$ infinitely often. We can thus seperate into $r:q\xrightarrow{w_0}q’\xrightarrow{w_1}q’\xrightarrow{w_2}\dots$<br>The $w$ here refers the word to reach $q’$. We know that Büchi automata is non-empty so $|w_i|&gt;0$ when $i&gt;0$.<br>Therefore, $w_0$ will be a word from $W_{q,q’}$ and the rest will be words for $(W_{q’,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$ because they reach the accepting state $q’\in F$.</p>
<p>For the word $w_0w_1w_2\dots$ from R.H.S, where $w_0$ refers to $W_{q,q’}$ and the rest refers to $(W_{q’,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$.<br>This is accepted by $\mathcal{L}(\mathcal{A})$ because it reaches the accepting state $q’\in F$ infinitely often.</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>$”\Leftarrow”$<br>Follows from the closure properties of the Büchi-recognizable languages established by Theorems <a href="../agv3-3/">3.2</a>, <a href="../agv3-4/">3.4</a>, <a href="../agv3-4/">3.5</a>.</p>
<p>$”\Rightarrow”$<br>Given a Büchi automaton $\mathcal{A}$, we consider for each pair $q,q’\in Q$ the regular language<br>$$<br>W_{q,q’} &#x3D; \lbrace w\in\Sigma^*\mid \text{finite-word automaton } (\Sigma,Q,\lbrace q\rbrace,T,{q’}) \text{ accepts }w\rbrace.<br>$$<br>We claim that $\mathcal{L}(\mathcal{A})&#x3D;\bigcup_{q\in I,q’\in F}W_{q,q’}\cdot(W_{q,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$. The claim is proven as follows.</p>
<p>$\mathcal{L}(\mathcal{A})\subseteq\bigcup_{q\in I,q’\in F}W_{q,q’}\cdot(W_{q,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$: Let $\alpha\in\mathcal{L}(\mathcal{A})$. Then there is an accpeting run $r$ of $\mathcal{A}$ on $\alpha$, which begins at some $q&#x3D;r(0)\in I$ and visits some $q’\in F$ infinitely often:</p>
<p>$$<br>r:q\xrightarrow{w_0}q’\xrightarrow{w_1}q’\xrightarrow{w_2}\dots<br>$$</p>
<p>where $w_i\in\Sigma^*$ for all $i\ge 0$, $|w_i|&gt;0$ for all $i&gt;0$ and $\alpha&#x3D;w_0w_1w_2\dots$ The notation $q_0\xrightarrow{w}q_{k+1}$ for some finite word $w&#x3D;w(0)w(1)\dots w(k)$ means that there exist states $q_1,\dots,q_k\in Q$ s.t. $(q_i,w(i),q_{i+1})\in T$ for all $0\leq i \leq k$. Since $w_0\in W_{q,q’}$ and $w_k\in W_{q’,q’}$ for $k&gt;0$, we have that $\alpha \in W_{q,q’}\cdot W_{q’,q’}^\omega$ for some $q\in I,q’\in F$.</p>
<p>$\mathcal{L}(\mathcal{A})\supseteq\bigcup_{q\in I,q’\in F}W_{q,q’}\cdot(W_{q,q’}\setminus\lbrace\varepsilon\rbrace)^\omega$: Let $\alpha&#x3D;w_0w_1w_2\dots$ with $w_0\in W_{q,q’}$ and $w_k\in W_{q’,q’}$ for some $q\in I,q’\in F$ and for all $k&gt;0$. Then the run:</p>
<p>$$<br>r:q\xrightarrow{w_0}q’\xrightarrow{w_1}q’\xrightarrow{w_2}\dots<br>$$</p>
<p>exists and is aceepting because $q’\in F$. It follows that $\alpha\in\mathcal{L}(\mathcal{A})$.</p>
<hr>
<p>Next chapter: <a href="../agv4-1/">Deterministic vs. Nondeterministic Büchi Automata</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-16T19:36:21.000Z" title="16/11/2024, 20:36:21">2024-11-16</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.413Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">10 minutes read (About 1558 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-4/">AGV 3.4 -- Closure Properties of the Büchi-recognizable languages (Concatenations)</a></p><div class="content"><p>Previous chapter: <a href="../agv3-3/">Closure Properties of the Büchi-recognizable languages (Intersection and Union)</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>In this section, we continue the proof of the <strong>closure properties</strong> of the Büchi-recognizable languages.</p>
<h2 id="Concatenation-of-regular-Langauge-and-Buchi-recognizable-Language"><a href="#Concatenation-of-regular-Langauge-and-Buchi-recognizable-Language" class="headerlink" title="Concatenation of regular Langauge and Büchi-recognizable Language"></a>Concatenation of regular Langauge and Büchi-recognizable Language</h2><blockquote>
<p>$\textbf{Construction 3.3. } \text{Let }\mathcal{A}_1&#x3D;(\Sigma,Q_1,I_1,T_1,F_1)\text{ be an automaton over finite words that}\newline\text{recognizes the languge }L_1\text{, and let }\mathcal{A}_2 &#x3D; (\Sigma,Q_2,I_2,T_2,\small\text{BÜCHI}\normalsize (F_2))\text{ be a Büchi automaton}\newline\text{over the same alphabet that recognizes }L_2.\text{ We construct a Büchi autotmaton }\newline\mathcal{A’}&#x3D;(\Sigma,Q’,I’,T’,\small\text{BÜCHI}\normalsize (F_2))\text{ with }\mathcal{L}(\mathcal{A’})&#x3D;L_1\cdot L_2\text{ as follows:}$<br>$\begin{array}{lrll}<br>\hspace{1cm} \cdot &amp;Q’&amp;&#x3D;&amp;Q_1\cup Q_2 \hspace{0.7cm}(\text{w.l.o.g we assume }Q_1\cap Q_2&#x3D;\varnothing)\newline<br>\hspace{1cm} \cdot &amp;I’&amp;&#x3D;&amp;\biggl\lbrace \begin{array}{ll}I_1 &amp; \ \text{if }I_1\cap F_1&#x3D;\varnothing\newline<br>I_1\cup I_2 &amp; \ \text{otherwise}\end{array} \newline<br>\hspace{1cm} \cdot &amp;T’&amp;&#x3D;&amp;T_1\cup T_2\cup\lbrace (q,\sigma,q’)\mid(q,\sigma,f)\in T_1,f\in F_1,q’\in I_2\rbrace \newline<br>\end{array}$</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Notation</th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$Q’$</td>
<td align="left">Same as Union, we include both automata for concatenation</td>
</tr>
<tr>
<td align="left">$I’$</td>
<td align="left">We normaly start the the automaton from $I_1$ If $I_1$ is non-empty, otherwise we start at $I_2$</td>
</tr>
<tr>
<td align="left">$T’$</td>
<td align="left">For any states that can reach the accepting states of $T_1$ with one transition, we create a new transitions that reach the initial states of $T_2$ $(I_2)$</td>
</tr>
</tbody></table>
<p>The correctness of this construction is proven by the following theorem.</p>
<blockquote>
<p>$\textbf{Theorem 3.4. }\newline\textit{If $L_1$ is a regular language and $L_2$ is Büchi-recognizable, then $L_1\cdot L_2$ is Büchi-recognizable.}$</p>
</blockquote>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>If $I_1$ is non-empty, then we can have a run that starts from $I_1$ to $r(n)$, that is one transition before $\mathcal{A_1}$’s accepting states of $f$. Then for next transition we either move to $f$, or we move on to $\mathcal{A_2}$ starting from $r(n+1)$.</p>
<p>If $I_1$ is empty, then any word accepted by $\mathcal{A‘}$ is accepted by $\mathcal{A_2}$</p>
<p>On the other way, we can always construct a word $w\alpha$. If $w$ is accepted by $\mathcal{A_1}$ and $\alpha$ is accepted by $\mathcal{A_2}$, then $w\alpha$ is always accepted by $\mathcal{A’}$</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>We prove that the Büchi automaton $\mathcal{A’}$ built from the automaton on finite words $\mathcal{A}_1$ and the Büchi automaton $\mathcal{A}_2$ indeed recognizes the concatenation of the languages of the two automata.</p>
<p>$\mathcal{L}(\mathcal{A’})\subseteq\mathcal{L}(\mathcal{A}_1)\cdot\mathcal{L}(\mathcal{A}_2):$</p>
<p>For $\alpha\in\mathcal{L}(\mathcal{A’})$, we have an accepting run $r&#x3D;r(0)r(1)r(2)\dots$ of $\mathcal{A’}$ on $\alpha$.<br>If $r(0)\in I_1$, then there is an $n\in\mathbb{N}$ such that $(r(n),\alpha(n),r(n+1))\in Q_1\times\Sigma\times I_2$ and therefore, there is a final state $f\in F_1$ such that $r(0)r(1)r(2)\dots r(n)f$ is an accepting run of $\mathcal{A_1}$ on $\alpha(0)\alpha(1)\alpha(2)\dots \alpha(n)$ and $r(n+1)r(n+2)\dots$ is an accepting run of $\mathcal{A_2}$ on $\alpha(n+1)\alpha(n+2)\dots$<br>If $r(0)\in I_2$ then $I_1\cup F_1 \neq\varnothing$ and therefore, $\varepsilon\in\mathcal{L}(\mathcal{A_1}),\alpha\in\mathcal{L}(\mathcal{A_2})$</p>
<p>$\mathcal{L}(\mathcal{A’})\supseteq\mathcal{L}(\mathcal{A}_1)\cdot\mathcal{L}(\mathcal{A}_2):$</p>
<p>For $w\in\mathcal{A_1}$, let $r&#x3D;r(0)r(1)\dots r(n)$ be an accepting run $\mathcal{A_1}$ on $w$.<br>For $\alpha\in\mathcal{A_2}$, let $s&#x3D;s(0)s(1)\dots$ be an accepting run of $\mathcal{A_2}$ on $\alpha$.<br>Then, $r(n)\in F_1$ and, by construction, $r(0)r(1)\dots r(n-1)s(0)s(1)\dots$ is an accepting run of $\mathcal{A’}$ on $w\alpha$.</p>
<h2 id="Infinite-concatenation-of-Regular-language"><a href="#Infinite-concatenation-of-Regular-language" class="headerlink" title="Infinite concatenation of Regular language"></a>Infinite concatenation of Regular language</h2><p>Finally, we show that the infinite concatenation of words of a regular language forms a Büchi-recognizable language. We construct a Büchi automaton for this language from an automaton over finite words in two steps.</p>
<h3 id="From-automaton-over-finite-words-to-a-single-initial-state"><a href="#From-automaton-over-finite-words-to-a-single-initial-state" class="headerlink" title="From automaton over finite words to a single initial state"></a>From automaton over finite words to a single initial state</h3><p>Firstly, we modify a given automaton over finite words into an equivalent automaton with one <strong>single initial state</strong> that has <strong>no incoming transitions</strong>.</p>
<p>We do this by create a new fresh state as the new initial state, with all transitions identical as the original. And the original initial state now has no incoming transitions.</p>
<blockquote>
<p>$\textbf{Construction 3.4. } \text{Let }\mathcal{A}_1&#x3D;(\Sigma,Q_1,I_1,T_1,F_1)\text{ be an automaton over finite words. We assume}\newline\text{that }\varepsilon\notin\mathcal{L}(\mathcal{A})\text{. We construct an automaton }\mathcal{A’} &#x3D; (\Sigma,Q’,I’,T’,F)\text{ over finite words such that }\newline\mathcal{L}(\mathcal{A})&#x3D;\mathcal{L}(\mathcal{A’})\text{ and }\mathcal{A’}\text{ has a single initial state that has no incoming transitions.}$<br>$\begin{array}{lrll}<br>\hspace{1cm} \cdot &amp;Q’&amp;&#x3D;&amp;Q_1\cup\lbrace q_f\rbrace \text{where }q_f\text{ is a fresh state}\newline<br>\hspace{1cm} \cdot &amp;I’&amp;&#x3D;&amp;\lbrace q_f\rbrace\newline<br>\hspace{1cm} \cdot &amp;T’&amp;&#x3D;&amp;T\cup\lbrace (q_f,\sigma,q’)\mid(q,\sigma,q’)\in T \text{ for some }q\in I\rbrace\newline<br>\end{array}$</p>
</blockquote>
<p>The second construction builds the Büchi automaton that recognizes the infinite concatenations of words from the regular language by <strong>adding a loop</strong> to the modified automaton.</p>
<blockquote>
<p>$\textbf{Construction 3.5. } \text{Let }\mathcal{A}\text{ be an automaton over finite words. We assume that }\varepsilon\notin\mathcal{L}(\mathcal{A}).\newline\text{We construct a Büchi automaton }\mathcal{A’’}&#x3D;(\Sigma,Q’’,I’’,T’’,\small\text{BÜCHI}\normalsize (F’’))\text{ such that }\mathcal{L}(\mathcal{A’’})&#x3D;\mathcal{L}(\mathcal{A})^\omega.\newline\text{Let }\mathcal{A’}&#x3D;(\Sigma,Q’,I’,T’,F’)\text{ be the automaton of Construction 3.4. Then }A’’\text{ is defined as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ Q’’&#x3D;Q’ \hspace{1cm} \cdot \ I’’&#x3D;I’ \hspace{1cm} \cdot \ F’’&#x3D;I’\newline<br>\hspace{1cm} \cdot \ T’’&#x3D;T’\cup\lbrace (q,\sigma,q_f)\mid(q,\sigma,q’)\in T’ \text{ and }q’\in F’\rbrace\newline<br>\end{array}$</p>
</blockquote>
<p>This construction change the final state into the initial state, with adding new transition from final state to initial state. Therefore the automaton becomes a loop.</p>
<p>The correctness of this construction is proven by the following theorem.</p>
<blockquote>
<p>$\textbf{Theorem 3.5. }\textit{If $L$ is a regular language such that $\varepsilon\notin L$, then $L^\omega$ is Büchi-recognizable}$</p>
</blockquote>
<h3 id="Explained-in-Human-language-1"><a href="#Explained-in-Human-language-1" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>If there is accepting run for $\mathcal{L}(\mathcal{A’’})$, it reaches the accepting state infinitely often.<br>We can split the word in every accepting states and it will be an accepting run for $\mathcal{L}(\mathcal{A’})$, since the transition to accepting state $F’’$ and $F’$ are identical.</p>
<p>If there is accepting run(s) for $\mathcal{L}(\mathcal{A’})$, we can infinitely repeat them so that is also accepted for $\mathcal{L}(\mathcal{A’’})$.</p>
<h3 id="Formal-Proof-1"><a href="#Formal-Proof-1" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>Construction 3.4 does not affect the language of $\mathcal{A}$. We show that the Büchi automaton $\mathcal{A’’}$ built in Construction 3.5 from the resulting automaton $\mathcal{A’}$ on finite words indeed recognizes $\mathcal{L}(\mathcal{A’})^\omega$.</p>
<p>$\mathcal{L}(\mathcal{A’’})\subseteq\mathcal{L}(\mathcal{A’})^\omega:$</p>
<p>Assume that $\alpha\in\mathcal{L}(\mathcal{A’’})$ and that $r(0)r(1)r(2)\dots$ is an accpeting run of $\mathcal{A’’}$ on $\alpha$. Hence, we have that $r(i)&#x3D;q_f\in F’’&#x3D;I’$ for inifinitely many indices $i:i_0,i_1,i_2,\dots$. This provides a sequence of runs of $\mathcal{A’}$:</p>
<ul>
<li>run $r(0)r(1)\dots r(i_0-1)q$ on $w_0&#x3D; \alpha(0)\alpha(1)\dots\alpha(i_0-1)$ for some $q\in F’$</li>
<li>run $r(i_0)r(i_0+1)\dots r(i_i-1)q$ on $w_1&#x3D; \alpha(i_0)\alpha(i_1)\dots\alpha(i_1-1)$ for some $q\in F’$</li>
<li>and so forth.</li>
</ul>
<p>We thus have that $w_k\in\mathcal{L}(\mathcal{A’})$ for every $k\geq 0$. Hence, $\alpha\in\mathcal{L}(\mathcal{A’})^\omega$.</p>
<p>$\mathcal{L}(\mathcal{A’’})\supseteq\mathcal{L}(\mathcal{A’})^\omega:$</p>
<p>Assume that $\alpha &#x3D;w_0w_1w_2\dots\in\Sigma^\omega$ such that $w_k\in\mathcal{L}(\mathcal{A’})$ for all $k\geq 0$. For each $k$, we choose an accepting run $r_k(0)r_k(1)r_k(2)\dots r_k(n_k)$ of $\mathcal{A’}$ on $w_k$. Hence, $r_k(0)\in I’$ and $r_k(n_k)\in F’$ for all $k&gt;1$. Thus,</p>
<p>$$r_0(0)\dots r_0(n_0-1)r_1(0)\dots r_1(n_1-1)r_2(0)\dots r_2(n_2-1)\dots$$</p>
<p>is an accepting run of $\mathcal{A’’}$ on $\alpha$. Hence, $\alpha\in\mathcal{L}(\mathcal{A’’})$.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Now we proved the closure property holds for <strong>Union</strong> $(W_1\cup W_2)$, <strong>Intersection</strong> $(W_1\cap W_2)$, <strong>Concatenation of regular Langauge and Büchi-recognizable Language</strong> $(E+W)$, and <strong>Infinite concatenation of Regular language</strong> $(E^\omega)$.</p>
<p>In the next section we can start to prove <strong>Büchi’s Characterization Theorem</strong>.</p>
<hr>
<p>Next chapter: <a href="../agv3-5/">Büchi’s Characterization Theorem</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Closure_(mathematics)">Closure (mathematics)</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concatenation">Concatenation</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Absolute_infinite">Absolute infinite</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-15T00:31:57.000Z" title="15/11/2024, 01:31:57">2024-11-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.425Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">6 minutes read (About 963 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-3/">AGV 3.3 -- Closure Properties of the Büchi-recognizable languages (Intersection and Union)</a></p><div class="content"><p>Previous chapter: <a href="../agv3-2/">$\omega$-regular language</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<p>In the following we refer the languages recognized by Büchi automata simply as <strong>Büchi-recognizable languages</strong>. <strong>Büchi’s characterization theorem</strong> states that the $\omega$-regular languages are exactly <strong>Büchi-recognizable languages</strong>. To prepare for the proof of Büchi’s theorem, we establish several <strong>closure properties</strong> of the Büchi-recognizable languages.</p>
<h2 id="Closure-Properties-of-Language-Union"><a href="#Closure-Properties-of-Language-Union" class="headerlink" title="Closure Properties of Language Union"></a>Closure Properties of Language Union</h2><blockquote>
<p>$\textbf{Construction 3.1. } \text{Let }L_1\text{ and }L_2\text{ be }\omega\text{-languages recognized by the Büchi automata}\newline\mathcal{A}_1&#x3D;(\Sigma,Q_1,I_1,T_1,\small\text{BÜCHI}\normalsize (F_1))\text{ and }\mathcal{A}_2 &#x3D; (\Sigma,Q_2,I_2,T_2,\small\text{BÜCHI}\normalsize (F_2))\text{, respectively.}\newline\text{We construct}\mathcal{A}_\cup&#x3D;(\Sigma,Q_\cup,I_\cup,T_\cup,\small\text{BÜCHI}\normalsize (F_\cup))\text{ with }\mathcal{L}(\mathcal{A}_\cup)&#x3D;L_1\cup L_2\text{ as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ Q_\cup&#x3D;Q_1\cup Q_2 \hspace{1cm}(\text{w.l.o.g we assume }Q_1\cap Q_2&#x3D;\varnothing)\newline<br>\hspace{1cm} \cdot \ I_\cup&#x3D;I_1\cup I_2 \ \hspace{1cm} \cdot \ T_\cup&#x3D;T_1\cup T_2 \ \hspace{1cm} \cdot \ F_\cup&#x3D;F_1\cup F_2 \newline<br>\end{array}$</p>
</blockquote>
<p>The correctness of this construction is proven by the following theorem.</p>
<blockquote>
<p>$\textbf{Theorem 3.2. } \textit{If $L_1$ and $L_2$ are Büchi-recognizable, then so is $L_1\cup L_2$.}$</p>
</blockquote>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>We prove that the Büchi automaton $\mathcal{A}_\cup$ built by $\mathcal{A}_1$ and $\mathcal{A}_2$ indeed recognizes the union of the languages of the two automata.</p>
<p>$\mathcal{L}(\mathcal{A}_\cup)\subseteq\mathcal{L}(\mathcal{A}_1)\cup\mathcal{L}(\mathcal{A}_2):$</p>
<p>For $\alpha\in\mathcal{L}(\mathcal{A}_\cup)$, we have an accepting run $r&#x3D;r(0)r(1)r(2)\dots$ of $\mathcal{A}_\cup$ on $\alpha$.<br>If $r(0)\in I_1$, then $r$ is an accepting run of $\mathcal{A}_1$, otherwise $r(0)\in I_2$ and $r$ is an accepting run of $\mathcal{A}_2$.</p>
<p>$\mathcal{L}(\mathcal{A}_\cup)\supseteq\mathcal{L}(\mathcal{A}_1)\cup\mathcal{L}(\mathcal{A}_2):$</p>
<p>For $i\in\lbrace 1,2\rbrace$ and $\alpha\in\mathcal{L}(\mathcal{A}_i)$, there is an accepting run $r$ of $\mathcal{A}_i$. The run $r$ is also an accepting run of $\mathcal{A}_\cup$.</p>
<h2 id="Closure-Properties-of-Language-Intersection"><a href="#Closure-Properties-of-Language-Intersection" class="headerlink" title="Closure Properties of Language Intersection"></a>Closure Properties of Language Intersection</h2><p>As we will see later, the Büchi-recognizable languages are closed under <code>complement</code>.<br>The closure under <code>complement</code> and <code>union</code> implies the closure under <code>intersection</code> $(\mathcal{A}_\cap &#x3D; (\mathcal{A’_1}\cup \mathcal{A’_2})’)$</p>
<p>Below, the automaton for the intersection is essentially the product of the two automata.</p>
<blockquote>
<p>$\textbf{Construction 3.2. } \text{Let }L_1\text{ and }L_2\text{ be }\omega\text{-languages recognized by the Büchi automata}\newline\mathcal{A}_1&#x3D;(\Sigma,Q_1,I_1,T_1,\small\text{BÜCHI}\normalsize(F_1))\text{ and }\mathcal{A}_2 &#x3D; (\Sigma,Q_2,I_2,T_2,\small\text{BÜCHI}\normalsize (F_2))\text{, respectively.}\newline\text{We construct}\mathcal{A}_\cap&#x3D;(\Sigma,Q_\cap,I_\cap,T_\cap,\small\text{BÜCHI}\normalsize (F_\cap))\text{ with }\mathcal{L}(\mathcal{A}_\cap)&#x3D;L_1\cap L_2\text{ as follows:}$<br>$\begin{array}{rll}<br>\hspace{1cm} \cdot \ Q_\cap&amp;&#x3D;&amp;Q_1\times Q_2\times\lbrace 1,2\rbrace\newline<br>\hspace{1cm} \cdot \ I_\cap&amp;&#x3D;&amp;I_1\times I_2\times\lbrace 1\rbrace\newline<br>\hspace{1cm} \cdot \ T_\cap&amp;&#x3D;&amp;\lbrace (q_1,q_2,i),\sigma ,(q’_1,q’_2,j)\mid (q_1,\sigma,q’_1)\in T_1,(q_2,\sigma,q’_2)\in T_2,i,j\in\lbrace 1,2\rbrace,\newline<br>\hspace{1cm} \ &amp;&amp;\hspace{5.3cm}q_i \notin F_i\rightarrow i&#x3D;j \wedge q_i\in F_i\wedge i\neq j\rbrace\newline<br>\hspace{1cm} \cdot \ F_\cap&amp;&#x3D;&amp;\lbrace (q_1,q_2,2)\mid q_1\in F_1, q_2\in F_2\rbrace\newline<br>\end{array}$</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$Q_\cap$</td>
<td align="left">States in the new automaton is <strong>tuples</strong> that contain the states of two automata plus the third component that used to <strong>combine acceptance conditions</strong>, e.g. $(q_1,q_2,1)$ is a state.</td>
</tr>
<tr>
<td align="left">$I_\cap$</td>
<td align="left">New automaton is constructed with only <strong>one initial state</strong>, so we assign the value to the acceptance condition <code>&#123;1&#125;</code> for simplicity</td>
</tr>
<tr>
<td align="left">$T_\cap$</td>
<td align="left">The switch from $\lbrace 0\rbrace$ and $\lbrace 1\rbrace$ happens nondeterministically. And once you enter the second copy $\lbrace 1\rbrace$, it stays forever.</td>
</tr>
<tr>
<td align="left">$F_\cap$</td>
<td align="left">For each transition, it has to be possible by both automata and if such transition reach the one of the automata’s accepting state, the acceptance condition changed. This creates an alternation between the accepting state of the 1st and 2nd automaton.</td>
</tr>
</tbody></table>
<p>Since we start our acceptance condition as <code>&#123;1&#125;</code>, our accepting states of the new automaton will be the <strong>accepting states of the 2nd automaton when acceptance condition becomes <code>&#123;2&#125;</code></strong>. i.e. Whenever the run reach to the accepting states of the 2nd automaton, it always has to first reach the accepting states of the 1st automaton.</p>
<blockquote>
<p>$\textbf{Theorem 3.3. } \textit{If $L_1$ and $L_2$ are Büchi-recognizable, then so is $L_1\cap L_2$.}$</p>
</blockquote>
<h3 id="Formal-Proof-1"><a href="#Formal-Proof-1" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><p>The run $r’$ is accepting iff $r_1$ is accepting and $r_2$ is accepting.</p>
<p>i.e. $r’&#x3D;(q_1^0,q_2^0,t^0)(q_1^1,q_2^1,t^1)\dots$ is a run of $\mathcal{A}_\cap$ on an input word $\alpha$,<br>iff $r_1 &#x3D; q^0_1 q^1_1\dots$ is a run of $\mathcal{A}_1$ on $\alpha$ and $r_1 &#x3D; q^0_2 q^1_2\dots$ is a run of $\mathcal{A}_2$ on $\alpha$</p>
<p>Therefore, an accepting run will be: <strong>(1)</strong> go to states with <code>&#123;1&#125;</code> → <strong>(2)</strong> reach accepting state of 1st automaton → <strong>(3)</strong> go to states with <code>&#123;2&#125;</code> → <strong>(4)</strong> reach accepting state of 2nd automaton → goes back to <strong>(1)</strong>…</p>
<hr>
<p>Next chapter: <a href="../agv3-4/">Closure Properties of the Büchi-recognizable languages (Concatenations)</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Closure_(mathematics)">Closure (mathematics)</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Intersection_(set_theory)">Intersection (set theory)</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Union_(set_theory)">Union (set theory)</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-14T11:40:04.000Z" title="14/11/2024, 12:40:04">2024-11-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.411Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">3 minutes read (About 381 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-2/">AGV 3.2 -- $\omega$-regular language</a></p><div class="content"><p>Previous chapter: <a href="../agv/">Kleene’s Theorem</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><em>$\omega$-regular expression</em> denotes languages over <strong>infinite</strong> words.<br>In addition to language union on languages over infinite words, we have 2 operations that convert languages over finite words into languages over infinite words.</p>
<h2 id="omega-regular-expression"><a href="#omega-regular-expression" class="headerlink" title="$\omega$-regular expression"></a>$\omega$-regular expression</h2><p>The collection of $\omega$-regular languages over an alphabet $\Sigma^\omega$ is $\mathcal{L}(W)$, where $W$ is a $\omega$-regular expression.<br>$\omega$-regular expression can be defined as $W :&#x3D; E^\omega \mid E\cdot W\mid W_1+W_2 $, where:</p>
<ul>
<li><strong>infinite concatenation</strong> of a <strong>non-empty</strong> regular language $E^\omega$,</li>
<li><strong>union</strong> of $\omega$-regular languages, $W_1+W_2$, and</li>
<li><strong>concatenation</strong> of regular languages and $\omega$-regular language $E\cdot W$</li>
</ul>
<blockquote>
<p>$\textbf{Definition 3.3. } \textit{$\omega$-Regular expressions } \text{are defined as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ \text{If $E$ is a regular expression where $\varepsilon\notin\mathcal{L}(E)$, then $E^\omega$ is an $\omega$-regular expression.}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E^\omega) &#x3D; \mathcal{L}(E)^\omega\newline<br>\hspace{1cm} \ \ \text{where } L^\omega &#x3D;\lbrace \omega_0\omega_1\dots\mid\omega_i\in L,|\omega_i|&gt;0\rbrace \text{ for } L\subseteq\Sigma^* \newline<br>\hspace{1cm} \cdot \ \text{If $E$ is a regular expression and $W$ is an $\omega$-regular expression,}\newline<br>\hspace{1cm} \ \ \text{then $E\cdot W$ is an $\omega$-regular expression:}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E\cdot W) &#x3D; \mathcal{L}(E)\cdot\mathcal{L}(W)\newline<br>\hspace{1cm} \ \ \text{where } L_1 \cdot L_2&#x3D;\lbrace \omega\alpha\mid\omega\in L_1,\alpha\in L_2\rbrace \text{ for } L_1 \subseteq\Sigma^*, L_2 \subseteq\Sigma^\omega\newline<br>\hspace{1cm} \cdot \ \text{If $W_1$ and $W_2$ are $\omega$-regular expressions, then $W_1+W_2$ is an $\omega$-regular expression:}\newline<br>\hspace{1cm} \ \ \mathcal{L}(W_1+W_2) &#x3D; \mathcal{L}(W_1)\cup\mathcal{L}(W_2) .\newline<br>\end{array}$</p>
</blockquote>
<p>A language over infinite words is $\omega$-regular if it is definable by a $\omega$-regular expression.</p>
<hr>
<p>Next chapter: <a href="../agv3-3/">Closure Properties of the Büchi-recognizable languages (Intersection and Union)</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Omega_language">Omega language</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Omega-regular_language">Omega Regular language</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-13T12:36:30.000Z" title="13/11/2024, 13:36:30">2024-11-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.411Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 750 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv3-1/">AGV 3.1 -- Kleene&#039;s Theorem</a></p><div class="content"><p>Previous chapter: <a href="../agv2-3/">The Büchi Acceptance Condition</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><em>Kleene’s theorem</em> states that the <em>set of languages over finite words</em> that can be defined by <strong>regular expressions</strong> is exactly the set of languages that can be recognized by <strong>automata over finite words</strong>.</p>
<p>Based on this, we define $\omega$-regular expressions, and finally prove the corresponding theorem for $\omega$-regular languages: <strong>Büchi’s characterization theorem</strong>.</p>
<h2 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h2><p>Regular expression consist of <strong>constants</strong> that denote languages of <em>finite words</em>, and<br>consist of <strong>operator symbols</strong> that denote <em>operations over these languages</em>.</p>
<p>The collection of regular languages over an alphabet $\Sigma$ is $\mathcal{L}(E)$, where $E$ is a regular expression.<br>Regular expression can be defined as $E :&#x3D; \varepsilon\mid\varnothing\mid a\in\Sigma\mid E+F\mid E\cdot F\mid E^* $, where:</p>
<ul>
<li><strong>empty language</strong>: $\varepsilon$,</li>
<li><strong>empty string language</strong>: $\varnothing$,</li>
<li><strong>singleton language</strong>: (single letter from alphabet) $a\in\Sigma$,</li>
<li><strong>union</strong> of regular languages: $E+F$,</li>
<li><strong>concatenation</strong> of regular languages: $E\cdot F$, and</li>
<li>language with <strong>kleene star</strong>: $E^*$.</li>
</ul>
<blockquote>
<p>$\textbf{Definition 3.1. } \textit{Regular expressions } \text{are defined as follows:}$<br>$\begin{array}{l}\hspace{1cm} \cdot \ \text{The constants }\varepsilon\text{ and }\varnothing\text{ are regular expressions.}\newline<br>\hspace{1cm} \ \ \mathcal{L}(\varepsilon) &#x3D; \lbrace\varepsilon\rbrace ,\mathcal{L}(\varnothing)&#x3D;\varnothing.\newline<br>\hspace{1cm} \cdot \ \text{If }a\in\Sigma\text{ is a symbol, then }a\text{ is a regular expressions.}\newline<br>\hspace{1cm} \ \ \mathcal{L}(a) &#x3D; \lbrace a\rbrace .\newline<br>\hspace{1cm} \cdot \ \text{If }E\text{ and }F\text{ are regular expressions, then }E+F\text{ is a regular expression:}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E+F) &#x3D; \mathcal{L}(E)\cup\mathcal{L}(F) .\newline<br>\hspace{1cm} \cdot \ \text{If }E\text{ and }F\text{ are regular expressions, then }E\cdot F\text{ is a regular expression:}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E\cdot F) &#x3D; \lbrace uv\mid u\in\mathcal{L}(E),v\in\mathcal{L}(F)\rbrace.\newline<br>\hspace{1cm} \cdot \ \text{If }E\text{ is a regular expression, then }E^*\text{ is a regular expression.}\newline<br>\hspace{1cm} \ \ \mathcal{L}(E^{\ast}) &#x3D; \lbrace u_1u_2\dots u_n\mid n\in\mathbb{N},u_i\in\mathcal{L}(E)\text{ for all }0\leq i\leq n\rbrace.\end{array}$</p>
</blockquote>
<h2 id="Kleene’s-Theorem"><a href="#Kleene’s-Theorem" class="headerlink" title="Kleene’s Theorem"></a>Kleene’s Theorem</h2><p><em>A language over finite words</em> is <strong>regular</strong> if it is definable by a <em>regular expression</em>, or<br>if it is recognized by <em>automata over finite words</em>.</p>
<blockquote>
<p>$\textbf{Definition 3.2. } \text{An }\textit{automaton on finite words } \mathcal{A}\text{ is a tuple } (\Sigma,Q,I,T,F), \text{ where }\Sigma\text{ is an input} \newline \text{alphabet, }Q\text{ is a nonempty finite set of states, }I\in Q\text{ is a set of initial states, }\Delta\subseteq Q\times\Sigma\times Q\text{ is}\newline\text{a set of transitions, and }F\subseteq Q\text{ are a set of finite states.}$</p>
</blockquote>
<h3 id="Mathematical-Definition"><a href="#Mathematical-Definition" class="headerlink" title="Mathematical Definition"></a>Mathematical Definition</h3><p>An automaton $\mathcal{A}$ accepts a finite word $w \in\Sigma^*$ if there is a finite sequence of states $q(0)q(1) . . . q(|w|)$ such that $q(0)\in I$ and $(q(i),w(i), q(i + 1))\in\Delta$ for all $i &lt; |w|$ and with $q(|w|)\in F$</p>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>In a nutshell, a finite word $w$ is <strong>accepted</strong> by an automaton $\mathcal{A} &#x3D; (\Sigma,Q,I,T,F)$ if:</p>
<table>
<thead>
<tr>
<th align="left">Notation</th>
<th align="left">Explaination</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$\Sigma$</td>
<td align="left">$w$ is a finite word in $\Sigma$</td>
</tr>
<tr>
<td align="left">$Q$</td>
<td align="left">There exists a finite sequence of states $q(0)q(1) . . . q(|w|)$</td>
</tr>
<tr>
<td align="left">$I$</td>
<td align="left">In such sequence, $q(0)$ is one of the initial state $I$</td>
</tr>
<tr>
<td align="left">$T$</td>
<td align="left">In such sequence, there is transition from $q(i)$ to $q(i+1)$ for each letter $w(i)$, where $i&lt;|w|$</td>
</tr>
<tr>
<td align="left">$F$</td>
<td align="left">In such sequence, $q(|w|)$ is one of the final state $F$, and it will be the last state of the run since there is no more letters</td>
</tr>
</tbody></table>
<h3 id="From-accepted-word-to-accepted-language"><a href="#From-accepted-word-to-accepted-language" class="headerlink" title="From accepted word to accepted language"></a>From accepted word to accepted language</h3><p>The set of all words accepted by $\mathcal{A}$ is called the <strong>language</strong> of $\mathcal{A}$, denoted by $\mathcal{L}(\mathcal{A})$.</p>
<blockquote>
<p>$\textbf{Theorem 3.1. } \text{(Kleene’s Theorem)}\newline\textit{A language is regular iff it is recognized by some finite word automaton.}$</p>
</blockquote>
<hr>
<p>Next post: <a href="../agv3-2/">$\omega$-regular language</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Regular_expression">Regular expression</a>,<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Regular_language">Regular language</a> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kleene_star#:~:text=The%20Kleene%20star%20is%20defined,x%E2%8B%85y%20%E2%88%88%20S*.">Kleene star</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-11-12T04:56:26.000Z" title="12/11/2024, 05:56:26">2024-11-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2025-04-03T07:41:15.426Z" title="03/04/2025, 09:41:15">2025-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Notes/">Notes</a><span> / </span><a class="link-muted" href="/categories/Notes/UdS/">UdS</a></span><span class="level-item">5 minutes read (About 723 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/AGV/agv2-3/">AGV 2.3 -- The Büchi Acceptance Condition</a></p><div class="content"><p>Previous chapter: <a href="../agv2-2/">Automata over Infinite Words</a></p>
<blockquote>
<p>This is a learning note of a course in <a target="_blank" rel="noopener" href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p>
</blockquote>
<h2 id="2-3-The-Buchi-Acceptance-Condition"><a href="#2-3-The-Buchi-Acceptance-Condition" class="headerlink" title="2.3 The Büchi Acceptance Condition"></a>2.3 The Büchi Acceptance Condition</h2><p>The Büchi Acceptance Condition is given as a set of <strong>accepting states</strong> $F$.<br>A run of a Büchi automaton is accepting if <strong>some state from this set occurs infinitely often</strong>.</p>
<p><a name="inf"></a></p>
<h3 id="Infinite-word"><a href="#Infinite-word" class="headerlink" title="Infinite word"></a>Infinite word</h3><p>For an infinite word $\alpha$ over $\Sigma$, an <strong>Infinity Set</strong> of $\alpha$ is denoted as:<br>$$\text{Inf}(\alpha) &#x3D; \lbrace\sigma\in\Sigma\mid\forall m\in\mathbb{N}.\exists n\in\mathbb{N}.n\geq m \text{ and } \alpha(n)&#x3D;\sigma\rbrace$$</p>
<p>Meaning that $\text{Inf}(\alpha)$ is a set of all letters $\sigma$ from the alphabet $\Sigma$, so that<br>for all $m$, you can always find $\sigma$ as the n-th letter of $\alpha$ when there exists an $n$ where $n\geq m$.</p>
<p>This denotes the set of all letters of $\Sigma$ that occur <strong>infinitely often</strong> in $\alpha$.</p>
<h3 id="Buchi-Condition"><a href="#Buchi-Condition" class="headerlink" title="Büchi Condition"></a>Büchi Condition</h3><p>To express the meaning of “some state from the set of <em>accepting states</em> is reached <strong>infinitely often</strong>“, we can rewrite our accpeing condition $Acc$ into Büchi Condition $\small\text{BÜCHI} \normalsize(F)$. Here, $\small\text{BÜCHI} \normalsize(F)$ is a set of <em>infinite word</em>:</p>
<blockquote>
<p>$\textbf{Definition 2.4. } \text{ The } \textit{Büchi Condition } \small\text{BÜCHI} \normalsize(F)\text{ on a set of states }F\subseteq Q\text{ is the set}$</p>
<p>$$\small\text{BÜCHI} \normalsize(F) &#x3D; \lbrace\alpha\in Q^\omega \mid \text{Inf}(\alpha) \cap F \neq \varnothing\rbrace$$</p>
<p>$\text{An automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,Acc)\text{ with }Acc&#x3D;\small\text{BÜCHI} \normalsize(F)\text{ is called a }\textit{Büchi automaton.}\newline \text{The set }F\text{ is called the }\textit{set of accepting states.}$</p>
</blockquote>
<h2 id="Constrcution-of-Complete-Buchi-Automaton"><a href="#Constrcution-of-Complete-Buchi-Automaton" class="headerlink" title="Constrcution of Complete Büchi Automaton"></a>Constrcution of Complete Büchi Automaton</h2><blockquote>
<p>$\textbf{Theorem 2.1. } \textit{For every Büchi Automaton }\mathcal{A},\text{ there is a complete Büchi Automaton }\mathcal{A}’ \newline \textit{such that }\mathcal{L}(\mathcal{A}) &#x3D; \mathcal{L}(\mathcal{A}’)$</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Let $\mathcal{A}$ be the automaton from <a href="../agv2-2/#eg1">Example 2.1</a> with Büchi acceptance condition $\small\text{BÜCHI}\normalsize (\lbrace D\rbrace)$. The language of the automaton consists of a single word:<br>$$\mathcal{L}(\mathcal{A})&#x3D;\lbrace aabbaabbaabb\dots\rbrace$$</p>
<p>For a Büchi Automaton $\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{BÜCHI} \normalsize(F))$,<br>we define the <strong>complete</strong> Büchi Automaton $\mathcal{A’} &#x3D; (\Sigma,Q’,I’,T’,\small\text{BÜCHI} \normalsize (F’))$ using:</p>
<ul>
<li>$Q’$ &#x3D; $Q \cup \lbrace q_f\rbrace$ where $q_f$ is a fresh state</li>
<li>$I’$ &#x3D; $I$</li>
<li>$T’$ &#x3D; $T \cup \lbrace (q,\sigma,q_f) \mid \nexists q’ . (q,\sigma,q’)\in T\rbrace\cup\lbrace (q_f,\sigma,q_f)\mid\sigma\in\Sigma\rbrace$</li>
<li>$F’$ &#x3D; $F$</li>
</ul>
<p><img src="/images/notes/uds/agv/2_3_eg.png"></p>
<h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>First, we add a <strong>fresh state</strong> $q_f$ the <em>set of state</em> $Q$ without changing the <em>initial</em> and <em>accepting</em> states.</p>
<p>A <em>complete Büchi Automaton</em> requires every states must have transitions for every letters in the alphabet.<br>So for each states orginally in $Q$, we construct new transitions that the letters are not yet used by the state.<br>(which is $\nexists q’ . (q,\sigma,q’)\in T$)</p>
<p>Finally, for all transitions from the fresh state are self transitioning, and they include all letters.<br>(which is $(q_f,\sigma,q_f)\mid\sigma\in\Sigma$)</p>
<h3 id="Formal-Proof"><a href="#Formal-Proof" class="headerlink" title="Formal Proof"></a>Formal Proof</h3><ul>
<li><p>The runs of $\mathcal{A’}$ are a <strong>superset</strong> of those of $\mathcal{A}$.</p>
<ul>
<li>During the construction of $\mathcal{A’}$, we have not removed any original transitions, but adding new fresh states.</li>
</ul>
</li>
<li><p>Furthermore, on <strong>any infinite input word</strong>, the accepting runs of $\mathcal{A}$ and $\mathcal{A’}$ are the same.</p>
<ul>
<li>If $\mathcal{A}$ accepts, $\mathcal{A’}$ also accepts because $\mathcal{A’}$ is a superset.</li>
<li>If a run reaches new fresh states $q_f$ stays in $q_f$ forever, and</li>
<li>since $q_f\notin F’$, such a run is not accepting.</li>
</ul>
</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>A <em>complete deterministic automaton</em> may be viewed as a <strong>total function</strong> from $\Sigma^\omega$ to $Q^\omega$.<br>A <em>complete (possibly nondeterministic) automaton</em> produces <strong>at least one run for every input word</strong>.</p>
<hr>
<p>Next chapter: <a href="../agv3-1/">Kleene’s Theorem</a></p>
<p>Further Reading: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%C3%BCchi_automaton">Büchi automaton</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Omega_language">Omega language</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">Previous</a></div><div class="pagination-next"><a href="/page/6/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li><li><a class="pagination-link" href="/page/6/">6</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="GreenMeeple"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">GreenMeeple</p><p class="is-size-6 is-block">M.Sc Cybersecurity at Saarland University</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Saarbrücken, Germany</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives/"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories/"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags/"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/GreenMeeple" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/GreenMeeple"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Linkedin" href="https://www.linkedin.com/in/alexcnli/"><i class="fab fa-linkedin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="LeetCode" href="https://leetcode.com/u/Alexli0/"><i class="fa-solid fa-laptop-code"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Email" href="mailto:alexcnli@yahoo.com"><i class="fa-solid fa-at"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://greenmeeple.github.io/MensaarLecker/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">MensaarLecker</span></span><span class="level-right"><span class="level-item tag">greenmeeple.github.io</span></span></a></li><li><a class="level is-mobile" href="https://mensaar.de/#/menu/sb" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Best Food Ever</span></span><span class="level-right"><span class="level-item tag">mensaar.de</span></span></a></li><li><a class="level is-mobile" href="https://cheesedseal.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cheesedseal</span></span><span class="level-right"><span class="level-item tag">cheesedseal.github.io</span></span></a></li><li><a class="level is-mobile" href="https://www.youtube.com/@meeplematch2582" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">米寶麻吉Meeple Match</span></span><span class="level-right"><span class="level-item tag">www.youtube.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">Advertisement</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5112876356744847" data-ad-slot="f08c47fec0942fa0" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-21T04:03:35.000Z">2025-03-21</time></p><p class="title"><a href="/projects/mensaarlog2/">MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaar/">🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#039; favourite menu using Selenium🥨 🍽</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T04:03:35.000Z">2025-03-20</time></p><p class="title"><a href="/projects/mensaarlog1/">MensaarLecker Development Log 1 -- Web Crawling</a></p><p class="categories"><a href="/categories/Projects/">Projects</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T19:12:54.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-3/">AGV 12.3 -- Complementation of Parity Tree Automata</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-16T18:11:08.000Z">2025-02-16</time></p><p class="title"><a href="/AGV/agv12-2/">AGV 12.2 -- Emptiness Game</a></p><p class="categories"><a href="/categories/Notes/">Notes</a> / <a href="/categories/Notes/UdS/">UdS</a></p></div></article></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Cantonese/"><span class="level-start"><span class="level-item">Cantonese</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Cantonese/Full-Course/"><span class="level-start"><span class="level-item">Full_Course</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Coding/"><span class="level-start"><span class="level-item">Coding</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/LeetCode/SQL-50/"><span class="level-start"><span class="level-item">SQL_50</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Notes/"><span class="level-start"><span class="level-item">Notes</span></span><span class="level-end"><span class="level-item tag">52</span></span></a><ul><li><a class="level is-mobile" href="/categories/Notes/UdS/"><span class="level-start"><span class="level-item">UdS</span></span><span class="level-end"><span class="level-item tag">52</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Projects/"><span class="level-start"><span class="level-item">Projects</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Site-Note/"><span class="level-start"><span class="level-item">Site_Note</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">March 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">February 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">January 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">December 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">November 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">October 2024</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AGV/"><span class="tag">AGV</span><span class="tag">50</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/App-Testing/"><span class="tag">App Testing</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Appium/"><span class="tag">Appium</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Automation/"><span class="tag">Automation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cantonese/"><span class="tag">Cantonese</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GitHub/"><span class="tag">GitHub</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTML/"><span class="tag">HTML</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LTS/"><span class="tag">LTS</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Language-Learning/"><span class="tag">Language Learning</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Latex/"><span class="tag">Latex</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mathjax/"><span class="tag">Mathjax</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Node-js/"><span class="tag">Node.js</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PV/"><span class="tag">PV</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Phonology/"><span class="tag">Phonology</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Scraper/"><span class="tag">Scraper</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Selenium/"><span class="tag">Selenium</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="GreenMeeple" height="28"></a><p class="is-size-7"><span>&copy; 2025 Alex Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Note" href="https://greenmeeple.github.io/studynotes"><i class="fa-solid fa-book"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Personal Blog" href="https://greenmeeple.github.io/SharkDeer"><i class="fa-solid fa-solid fa-blog"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>