<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GreenMeeple</title>
  <icon>https://greenmeeple.github.io/img/avatar.png</icon>
  <subtitle>Coding, Boardgames, Language learning.</subtitle>
  <link href="https://greenmeeple.github.io/atom.xml" rel="self"/>
  
  <link href="https://greenmeeple.github.io/"/>
  <updated>2025-04-03T16:19:07.372Z</updated>
  <id>https://greenmeeple.github.io/</id>
  
  <author>
    <name>Alex Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo Plugins and Personalization of this site</title>
    <link href="https://greenmeeple.github.io/personalize/"/>
    <id>https://greenmeeple.github.io/personalize/</id>
    <published>2025-04-03T15:02:08.000Z</published>
    <updated>2025-04-03T16:19:07.372Z</updated>
    
    
    <summary type="html">&lt;p&gt;Here are all the plugins and niche settings that personalize this blog and the &lt;a href=&quot;https://github.com/ppoffice/hexo-theme-icarus&quot;&gt;Icarus&lt;/a&gt; theme.&lt;/p&gt;
&lt;h2 id=&quot;Remove-Uppercase-Details&quot;&gt;&lt;a href=&quot;#Remove-Uppercase-Details&quot; class=&quot;headerlink&quot; title=&quot;Remove Uppercase Details&quot;&gt;&lt;/a&gt;Remove Uppercase Details&lt;/h2&gt;&lt;p&gt;The Uppercase characters overflowed the page and affects the aesthetic.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/site_notes/uppercase.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Find the css tag that contains the keyword &lt;strong&gt;Uppercase&lt;/strong&gt; and remove it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;&amp;#123;page.layout !== &amp;#39;page&amp;#39; ? &amp;lt;div class=&amp;quot;article-meta is-size-7 is-uppercase level is-mobile&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;Better-Sans-Font&quot;&gt;&lt;a href=&quot;#Better-Sans-Font&quot; class=&quot;headerlink&quot; title=&quot;Better Sans Font&quot;&gt;&lt;/a&gt;Better Sans Font&lt;/h2&gt;&lt;p&gt;In &lt;code&gt;_config.icarus.yml&lt;/code&gt;, find the following section &lt;code&gt;providers&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;yml&quot;&gt;providers:
    # Name or URL template of the JavaScript and/or stylesheet CDN provider
    cdn: jsdelivr
    # Name or URL template of the webfont CDN provider
    fontcdn: https://fonts.googleapis.com/css2?family=Noto+Sans+HK:wght@100..900&amp;amp;display=swap
    # Name or URL of the fontawesome icon font CDN provider
    iconcdn: fontawesome
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Choose your favorite font in &lt;a href=&quot;https://fonts.google.com/&quot;&gt;Google Fonts&lt;/a&gt;, and paste the url of the font to &lt;code&gt;fontcdn&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="SiteNote" scheme="https://greenmeeple.github.io/categories/SiteNote/"/>
    
    
    <category term="Hexo" scheme="https://greenmeeple.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</title>
    <link href="https://greenmeeple.github.io/projects/mensaarlog2/"/>
    <id>https://greenmeeple.github.io/projects/mensaarlog2/</id>
    <published>2025-03-21T04:03:35.000Z</published>
    <updated>2025-04-03T15:34:38.982Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Repository: &lt;a href=&quot;https://github.com/greenmeeple/MensaarLecker&quot;&gt;MensaarLecker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Fetching-Data-from-Web-Development&quot;&gt;&lt;a href=&quot;#Fetching-Data-from-Web-Development&quot; class=&quot;headerlink&quot; title=&quot;Fetching Data from Web Development&quot;&gt;&lt;/a&gt;Fetching Data from Web Development&lt;/h2&gt;&lt;p&gt;Continuing from last post, we have already implemented a script that collect the Mensa menu and stored it on Google Sheets. It is time to build our web interface to connect the database.&lt;/p&gt;
&lt;h3 id=&quot;Fetch-Data-from-Google-Sheets-using-Publish&quot;&gt;&lt;a href=&quot;#Fetch-Data-from-Google-Sheets-using-Publish&quot; class=&quot;headerlink&quot; title=&quot;Fetch Data from Google Sheets using Publish&quot;&gt;&lt;/a&gt;Fetch Data from Google Sheets using Publish&lt;/h3&gt;&lt;p&gt;First, we need to publish our spreadsheet so that it is public to fetch the data.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;In the Spreadsheet, click &lt;strong&gt;Share&lt;/strong&gt; ‚Üí Change access to Anyone with the link.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/images/projects/sheetshare.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Click &lt;strong&gt;File&lt;/strong&gt; ‚Üí &lt;strong&gt;Share&lt;/strong&gt; ‚Üí &lt;strong&gt;Publish&lt;/strong&gt; to the web.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Select &lt;strong&gt;Entire Document&lt;/strong&gt; ‚Üí &lt;strong&gt;Comma-separated values (.csv)&lt;/strong&gt; and click Publish.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Copy the public CSV link.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;SCRIPT_URL = &amp;#123;PUBLISH_LINK&amp;#125;

# Fetch JSON data
def fetch_menu():
    try:
        response = requests.get(SCRIPT_URL)
        response.raise_for_status()  # Raise error if bad response
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f&amp;quot;‚ùå Error fetching menu: &amp;#123;e&amp;#125;&amp;quot;)
        return []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, the script return no data, why?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;error&quot;&gt;Access to fetch at &amp;#39;https://docs.google.com/spreadsheets/...&amp;#39; from origin &amp;#39;null&amp;#39; has been blocked 
by CORS policy: No &amp;#39;Access-Control-Allow-Origin&amp;#39; header is present on the requested resource. 
If an opaque response serves your needs, set the request&amp;#39;s mode to &amp;#39;no-cors&amp;#39; to fetch the resource with CORS disabled.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;CORS-Policy-and-XSS&quot;&gt;&lt;a href=&quot;#CORS-Policy-and-XSS&quot; class=&quot;headerlink&quot; title=&quot;CORS Policy and XSS&quot;&gt;&lt;/a&gt;CORS Policy and XSS&lt;/h3&gt;</summary>
    
    
    
    <category term="Projects" scheme="https://greenmeeple.github.io/categories/Projects/"/>
    
    
    <category term="Python" scheme="https://greenmeeple.github.io/tags/Python/"/>
    
    <category term="Scraper" scheme="https://greenmeeple.github.io/tags/Scraper/"/>
    
    <category term="Selenium" scheme="https://greenmeeple.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>üçΩ ü•® MensaarLecker -- A beloved tool to find out Mensa Ladies&#39; favourite menu using Seleniumü•® üçΩ</title>
    <link href="https://greenmeeple.github.io/projects/mensaar/"/>
    <id>https://greenmeeple.github.io/projects/mensaar/</id>
    <published>2025-03-20T04:03:35.000Z</published>
    <updated>2025-04-03T15:34:42.286Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Repository: &lt;a href=&quot;https://github.com/greenmeeple/MensaarLecker&quot;&gt;MensaarLecker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As an &lt;a href=&quot;https://www.uni-saarland.de/start.html&quot;&gt;UdS&lt;/a&gt; Student,&lt;br&gt;Are you tired of seeing french friesüçü 3 times a week, or wondering when I can have the best pizza üçï in the Mensacafe?&lt;br&gt;MensaarLecker aims to collect all the data from Menu 1, 2, and Mensacafe to trace your favourite, or Mensa Ladies‚Äô, favourite menu!&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;ü•ó-Description&quot;&gt;&lt;a href=&quot;#ü•ó-Description&quot; class=&quot;headerlink&quot; title=&quot;ü•ó Description&quot;&gt;&lt;/a&gt;ü•ó Description&lt;/h2&gt;&lt;p&gt;A fully automated scraper and static website for the Saarbr√ºcken Mensa, powered by Python, Selenium, Google Sheets, and GitHub Actions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Get a clean and daily-updated overview of meals from &lt;a href=&quot;https://mensaar.de/&quot;&gt;mensaar.de&lt;/a&gt;, with searchable history, meal components, and frequency stats.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;üåê-Live-Demo&quot;&gt;&lt;a href=&quot;#üåê-Live-Demo&quot; class=&quot;headerlink&quot; title=&quot;üåê Live Demo&quot;&gt;&lt;/a&gt;üåê Live Demo&lt;/h2&gt;&lt;p&gt;üëâ &lt;a href=&quot;https://your-username.github.io/MensaarLecker&quot;&gt;View Website&lt;/a&gt;&lt;br&gt;üëâ &lt;a href=&quot;https://docs.google.com/spreadsheets/d/your-sheet-id-here&quot;&gt;View Data in Google Sheets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/projects/menu.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Projects" scheme="https://greenmeeple.github.io/categories/Projects/"/>
    
    
    <category term="Python" scheme="https://greenmeeple.github.io/tags/Python/"/>
    
    <category term="Scraper" scheme="https://greenmeeple.github.io/tags/Scraper/"/>
    
    <category term="Selenium" scheme="https://greenmeeple.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>MensaarLecker Development Log 1 -- Web Crawling</title>
    <link href="https://greenmeeple.github.io/projects/mensaarlog1/"/>
    <id>https://greenmeeple.github.io/projects/mensaarlog1/</id>
    <published>2025-03-20T04:03:35.000Z</published>
    <updated>2025-04-03T15:34:41.363Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Repository: &lt;a href=&quot;https://github.com/greenmeeple/MensaarLecker&quot;&gt;MensaarLecker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h2&gt;&lt;p&gt;Me and my friends &lt;del&gt;hate&lt;/del&gt;&lt;strong&gt;love&lt;/strong&gt; the UdS Mensa so much! The infinite frozen food and french fries menus give us so much energy and motivation for the 5-hour afternoon coding marathon. However, no one actually knows how many potatoes they have exterminated throughout the week. We have a genius webpage created by some &lt;a href=&quot;https://gibtesheuteschnitzel.de/&quot;&gt;Schnitzel lover&lt;/a&gt;. Personally, I like its minimalistic layout and determination on Schnitzel searching. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, we want more.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It‚Äôs not just Schnitzel; we want to know everything about their menu. We want to know what‚Äôs inside the mensa ladies‚Äô brains when they design next week‚Äôs menu.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The desire never ends. We need more data, more details, more, More, &lt;strong&gt;MORE!&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Developing-Process&quot;&gt;&lt;a href=&quot;#Developing-Process&quot; class=&quot;headerlink&quot; title=&quot;Developing Process&quot;&gt;&lt;/a&gt;Developing Process&lt;/h2&gt;&lt;p&gt;Our Goal here is simple:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Scrape the Mensa menu every weekday and store it to Google Sheets&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fetch the Data Collection from Google Sheets and update the website&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Web-Scraping&quot;&gt;&lt;a href=&quot;#Web-Scraping&quot; class=&quot;headerlink&quot; title=&quot;Web Scraping&quot;&gt;&lt;/a&gt;Web Scraping&lt;/h2&gt;</summary>
    
    
    
    <category term="Projects" scheme="https://greenmeeple.github.io/categories/Projects/"/>
    
    
    <category term="Python" scheme="https://greenmeeple.github.io/tags/Python/"/>
    
    <category term="Scraper" scheme="https://greenmeeple.github.io/tags/Scraper/"/>
    
    <category term="Selenium" scheme="https://greenmeeple.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>AGV 12.3 -- Complementation of Parity Tree Automata</title>
    <link href="https://greenmeeple.github.io/AGV/agv12-3/"/>
    <id>https://greenmeeple.github.io/AGV/agv12-3/</id>
    <published>2025-02-16T19:12:54.000Z</published>
    <updated>2025-04-03T07:41:15.411Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv12-2/&quot;&gt;Emptiness Game&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;We now prove that parity tree automata are closed under complementation. As discussed at the beginning of the section, our proof makes heavy use of the determinacy of parity games (with infinite game arenas) established in &lt;a href=&quot;../agv11-4&quot;&gt;Theorem 11.3&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Theorem 12.3. } &#92;textit{For every parity tree automaton }&#92;mathcal{A}&#92;textit{ over }&#92;Sigma&#92;textit{ there is a parity tree automaton }&#92;mathcal{A}‚Äô&#92;newline&#92;textit{ with }&#92;mathcal{L(A‚Äô)}&amp;#x3D;&#92;mathcal{T}_&#92;Sigma&#92;setminus&#92;mathcal{L(A)}.$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Proof&quot;&gt;&lt;a href=&quot;#Proof&quot; class=&quot;headerlink&quot; title=&quot;Proof&quot;&gt;&lt;/a&gt;Proof&lt;/h3&gt;&lt;p&gt;Let $&#92;mathcal{A}&amp;#x3D;(&#92;Sigma,Q,q_0,T,&#92;small&#92;text{PARITY} &#92;normalsize(C))$. By Theorem 12.1, a tree $(&#92;mathcal{T},t)$ is accepted by $&#92;mathcal{A}$ iff Player 0 has a winning strategy from position $(&#92;varepsilon,q_0)$ of the acceptance game $&#92;mathcal{G}_{&#92;mathcal{A},t}$. &lt;/p&gt;
&lt;p&gt;Since $&#92;mathcal{A}$ is a parity tree automaton, $&#92;mathcal{G}&lt;em&gt;{&#92;mathcal{A},t}$ is a parity game and therefore, by Theorem 11.3, memoryless determined. Hence, $&#92;mathcal{A}$ does not accept some tree $t$ iff Player 1 has a winning memoryless strategy $&#92;sigma$ in $&#92;mathcal{G}&lt;/em&gt;{&#92;mathcal{A},t}$ from $(&#92;varepsilon,q_0)$. &lt;/p&gt;
&lt;p&gt;The strategy $&#92;sigma:&#92;lbrace 0,1&#92;rbrace^&#92;ast&#92;times T&#92;rightarrow&#92;lbrace 0,1&#92;rbrace^&#92;ast&#92;times Q$ can be represented as a function $&#92;sigma‚Äô:&#92;lbrace 0,1&#92;rbrace^&#92;ast&#92;times T&#92;rightarrow&#92;lbrace 0,1&#92;rbrace$&lt;/p&gt;
&lt;p&gt;where $&#92;sigma(w,(q,&#92;sigma,q^0,q^1))&amp;#x3D;(wi,q^i)$ iff $&#92;sigma‚Äô(w,(q,&#92;sigma,q^0,q^1))&amp;#x3D;i$. Yet another representation of the same strategy is $&#92;sigma‚Äô:&#92;lbrace 0,1&#92;rbrace^&#92;ast&#92;rightarrow&#92;lbrace T&#92;rightarrow&#92;lbrace 0,1&#92;rbrace&#92;rbrace$,&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 12.2 -- Emptiness Game</title>
    <link href="https://greenmeeple.github.io/AGV/agv12-2/"/>
    <id>https://greenmeeple.github.io/AGV/agv12-2/</id>
    <published>2025-02-16T18:11:08.000Z</published>
    <updated>2025-04-03T07:41:15.436Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv12-1/&quot;&gt;Tree Automata and Acceptance Game&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Emptiness-Game&quot;&gt;&lt;a href=&quot;#Emptiness-Game&quot; class=&quot;headerlink&quot; title=&quot;Emptiness Game&quot;&gt;&lt;/a&gt;Emptiness Game&lt;/h2&gt;&lt;p&gt;The acceptance game can also be used to test if the language of a given tree automaton is non-empty. For this purpose, we first translate the given automaton into an automaton with singleton alphabet.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Construction 12.1. } &#92;text{For a given tree automaton }&#92;mathcal{A}&#92;text{ over }&#92;Sigma&#92;text{-labeled trees, we consider the}&#92;newline&#92;text{following tree automaton }&#92;mathcal{A}‚Äô&#92;text{ over }&#92;lbrace1&#92;rbrace&#92;text{-labeled trees, such that }&#92;mathcal{L(A)}&amp;#x3D;&#92;varnothing&#92;text{ iff }&#92;mathcal{L(A‚Äô)}&amp;#x3D;&#92;varnothing:&#92;newline&lt;br&gt;&#92;begin{array}{l}&lt;br&gt;&#92;hspace{1cm} &#92;cdot &#92; Q‚Äô&amp;#x3D;Q &#92;newline&lt;br&gt;&#92;hspace{1cm} &#92;cdot &#92; q_0‚Äô&amp;#x3D;q_0&#92;newline&lt;br&gt;&#92;hspace{1cm} &#92;cdot &#92; T‚Äô&amp;#x3D;&#92;lbrace(q,1,q‚Äô,q‚Äô‚Äô)&#92;mid(q,&#92;sigma,q‚Äô,q‚Äô‚Äô)&#92;in T,&#92;sigma&#92;in&#92;Sigma&#92;rbrace&#92;newline&lt;br&gt;&#92;hspace{1cm} &#92;cdot &#92; Acc‚Äô &amp;#x3D; Acc&lt;br&gt;&#92;end{array}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Because the subtrees of a $&#92;lbrace 1&#92;rbrace$-labeled binary tree are the same from all nodes, we can simplify its acceptance game such that only finitely many positions are needed. We call this game the &lt;strong&gt;emptiness game&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Definition 12.5. } &#92;text{Let }&#92;mathcal{A}&amp;#x3D;(&#92;Sigma,Q,q_0,T,Acc)&#92;text{ be a tree automaton. The }&#92;textit{emptiness game}&#92;text{ of }&#92;mathcal{A}&#92;newline &#92;text{ is the game }&#92;mathcal{G}_{&#92;mathcal{A}}&amp;#x3D;(&#92;mathcal{A}‚Äô,&#92;text{Win}‚Äô)&#92;text{ with the finite game arena }&#92;mathcal{A}‚Äô&amp;#x3D;(Q&#92;cup T, Q,T,E)&#92;text{, where}&#92;newline E&amp;#x3D;&#92;lbrace(q,&#92;tau)&#92;mid&#92;tau&amp;#x3D;(q,&#92;sigma,q^0,q^1),&#92;tau&#92;in T&#92;rbrace&#92;cup&#92;lbrace(&#92;tau,q‚Äô)&#92;mid&#92;tau&amp;#x3D;(&#92;rule{0.5em}{0.4pt},&#92;sigma,q^0,q^1)&#92;text{ and }(q‚Äô&amp;#x3D;q^0&#92;text{ or }q‚Äô&amp;#x3D;q^1)&#92;rbrace&#92;newline&#92;text{and Win‚Äô}&amp;#x3D;&#92;lbrace q(0)&#92;tau(0)q(1)&#92;tau(1)&#92;dots&#92;mid q(0)q(1)&#92;dots&#92;in Acc,&#92;tau(0)&#92;tau(1)&#92;dots&#92;in T^&#92;omega&#92;rbrace$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Theorem 12.2. } &#92;textit{The language of a tree automaton }&#92;mathcal{A}&#92;textit{ is non-empty iff Player 0 wins the}&#92;newline&#92;textit{emptiness game }&#92;mathcal{G}_{&#92;mathcal{A}}&#92;textit{ from position }q_0.$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Proof&quot;&gt;&lt;a href=&quot;#Proof&quot; class=&quot;headerlink&quot; title=&quot;Proof&quot;&gt;&lt;/a&gt;Proof&lt;/h3&gt;&lt;p&gt;The emptiness game corresponds to the acceptance game of the automaton from Construction 12.1 on the $&#92;lbrace 1&#92;rbrace$-labeled binary tree.&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 12.1 -- Tree Automata and Acceptance Game</title>
    <link href="https://greenmeeple.github.io/AGV/agv12-1/"/>
    <id>https://greenmeeple.github.io/AGV/agv12-1/</id>
    <published>2025-02-15T23:21:11.000Z</published>
    <updated>2025-04-03T07:41:15.408Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-6/&quot;&gt;A Remark on Undetermined Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Infinite games allow us to reason elegantly about infinite trees. A famous example of an argument that became significantly simpler with the introduction of game-theoretic ideas is the proof of &lt;strong&gt;Rabin‚Äôs theorem&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;Rabin‚Äôs theorem states that the satisfiability of &lt;strong&gt;monadic second-order logic with two successors (S2S)&lt;/strong&gt; is decidable. Like in &lt;a href=&quot;../agv6-5/&quot;&gt;Section 6&lt;/a&gt;, where we showed that S1S formulas can be translated to automata, we will show that S2S formulas can be translated to automata, this time, in order to accommodate more than one successor function, to automata over infinite trees. &lt;/p&gt;
&lt;p&gt;The most difficult part of the proof of Rabin‚Äôs theorem is to show that tree automata are &lt;em&gt;closed under complement&lt;/em&gt;. The original proof was purely combinatorial (and very difficult to understand), but the game-theoretic argument is simply based on &lt;strong&gt;the determinacy of the acceptance game of the tree automaton&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;the acceptance of a tree by a tree automaton &amp;#x3D; the existence of a winning strategy for Player 0,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;the non-acceptance &amp;#x3D; the absence of such a strategy &amp;#x3D; the existence of a winning strategy for Player 1.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can therefore complement the language of a given tree automaton by constructing a new automaton that verifies the existence of a winning strategy for Player 1. We begin this section with a discussion of tree automata. The logic S2S and the translation to tree automata will be introduced later in the section.&lt;/p&gt;
&lt;h2 id=&quot;Tree-Automata&quot;&gt;&lt;a href=&quot;#Tree-Automata&quot; class=&quot;headerlink&quot; title=&quot;Tree Automata&quot;&gt;&lt;/a&gt;Tree Automata&lt;/h2&gt;&lt;p&gt;We consider tree automata over infinite binary trees. We use the notation for trees introduced in &lt;a href=&quot;../agv7-1/&quot;&gt;Section 7.1&lt;/a&gt;. The (full) binary tree is the language $&#92;mathcal{T} &amp;#x3D;&#92;lbrace 0, 1&#92;rbrace^&#92;ast$. For an alphabet $&#92;Sigma, &#92;mathcal{T}_&#92;Sigma &amp;#x3D; &#92;lbrace(&#92;mathcal{T}, t)&#92;mid t:&#92;mathcal{T}&#92;rightarrow&#92;Sigma&#92;rbrace$ is the set of all binary $&#92;Sigma$-labeled trees.&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.6 -- A Remark on Undetermined Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-6/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-6/</id>
    <published>2025-02-15T12:55:54.000Z</published>
    <updated>2025-04-03T07:41:15.437Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-5/&quot;&gt;Muller Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since we have shown that &lt;a href=&quot;../agv11-2/&quot;&gt;reachability&lt;/a&gt;, &lt;a href=&quot;../agv11-3/&quot;&gt;B√ºchi&lt;/a&gt;, &lt;a href=&quot;../agv11-4/&quot;&gt;parity&lt;/a&gt;, and &lt;a href=&quot;../agv11-5/&quot;&gt;Muller&lt;/a&gt; games are all &lt;strong&gt;determined&lt;/strong&gt;, it might seem as if all games were determined. The purpose of this last subsection is to remark that this is not the case. By definition, every play is either won by Player 0 or by Player 1; however, it is entirely possible that neither Player 0 nor Player 1 has a winning strategy.&lt;/p&gt;
&lt;p&gt;We will construct a game with a winning condition that allows the players to &lt;em&gt;steal&lt;/em&gt; strategies in the sense that if Player i has a winning strategy œÉ, then Player 1‚àí$i$ has a strategy $&#92;tau$ that mimicks $&#92;sigma$ so that the play resulting from strategies œÉ and œÑ is won by Player 1-$i$: hence, strategy $&#92;sigma$ is not winning after all! &lt;/p&gt;
&lt;p&gt;We fix the alphabet $&#92;mathbb{B}&amp;#x3D;&#92;lbrace 0,1&#92;rbrace$. To define the winning condition, we introduce an &lt;em&gt;infinite&lt;/em&gt; $&#92;text{XOR}$ &lt;em&gt;function&lt;/em&gt; $f$. An infinite $&#92;text{XOR}$ function is a function $f:&#92;mathbb{B}^&#92;omega&#92;rightarrow&#92;mathbb{B}$ such that $f(&#92;alpha)&#92;neq f(&#92;beta)$ for all Œ±, Œ≤ ‚àà B œâ that have the exact same letter in every position except for exactly one position where they have different letters. &lt;/p&gt;
&lt;p&gt;To see that such a function exists, define an equivalence relation $&#92;sim$ such that $&#92;alpha&#92;sim&#92;beta$ iff there exists a position $n&#92;in&#92;mathbb{N}$ such that $&#92;alpha(i)&amp;#x3D;&#92;beta(i)$ for all $i&#92;geq n$. Let $S&#92;subseteq&#92;mathbb{B}^&#92;omega$ be a set that contains exactly one element from each $&#92;sim$-equivalence class, and let $r(&#92;alpha)$ be the unique $&#92;beta&#92;in S$ such that $&#92;alpha&#92;sim&#92;beta$. For every $&#92;alpha&#92;in&#92;mathbb{B}^&#92;omega$, the two sequences $&#92;alpha$ and $r(&#92;alpha)$ differ only in a finite number of positions. We define $f(&#92;alpha)&amp;#x3D;0$ if this number is even and $f(&#92;alpha)&amp;#x3D;1$ if it is odd. Hence, $f$ is indeed an infinite $&#92;text{XOR}$ function: if two sequences $&#92;alpha,&#92;beta&#92;in&#92;mathbb{B}^&#92;omega$ differ in exactly one position, then $f(&#92;alpha)&#92;neq f(&#92;beta)$. &lt;/p&gt;
&lt;p&gt;We now use the infinite $&#92;text{XOR}$ function $f$ to define the game. We‚Äôll describe the game somewhat informally in terms of rounds executed by the players; it is straightforward to translate this into an explicit arena and winning condition. Our game is played in rounds $n &amp;#x3D; 0, 1, 2,&#92;dots,$ where in round $n$, first Player 0 picks a finite word $w_{2n}&#92;in&#92;mathbb{B}^+$, then Player 1 picks $w_{2n+1}&#92;in&#92;mathbb{B}^+$. The resulting play $&#92;alpha&amp;#x3D;w_0,w_1,w_2,&#92;dots$ is winning for Player $f(&#92;alpha)$.&lt;/p&gt;
&lt;p&gt;We now use the ‚Äústrategy stealing‚Äù argument to show that no player has a winnig strategy in this game. A strategy for Player $i$ is a mapping $&#92;sigma:&#92;cup_{n&#92;in&#92;mathbb{N}}(&#92;mathbb{B}^+)^{2n+i}$, where we denote $(&#92;mathbb{B}^+)^0&amp;#x3D;&#92;varepsilon$.&lt;/p&gt;
&lt;p&gt;As usual, $&#92;sigma$ is a winning strategy for Player $i$ if Player $i$ wins every play that is consistent with $&#92;sigma_i$ . Now fix an arbitrary strategy $&#92;tau$ for Player 1. From $&#92;tau$, we construct two different strategies $&#92;sigma$ and $&#92;sigma‚Äô$ for Player 0. &lt;/p&gt;
&lt;p&gt;For the first round:&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.5 -- Muller Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-5/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-5/</id>
    <published>2025-02-13T17:01:42.000Z</published>
    <updated>2025-04-03T07:41:15.408Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-4/&quot;&gt;Parity Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Muller games differ from the games we have studied so far in that they are not memoryless determined. Consider, for example, a game arena consisting of three positions $v_0,v_1,v_2$, such that there are edges from $v_0$ and $v_2$ to $v_1$ and from $v_1$ to $v_0$ and $v_2$. Hence, the only choice in the game is in $v_1$, where Player 0 gets to choose between moving to $v_0$ or $v_2$:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/notes/uds/agv/11_5_muller.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;The Muller condition $&#92;mathcal{F}&amp;#x3D;&#92;lbrace&#92;lbrace v_0,v_1,v_2&#92;rbrace&#92;rbrace$ is only satisfied if all three positions are visited infinitely often. Player 0 can therefore not win the game with a memoryless strategy, because such a strategy would either visit $v_0$ and $v_1$ infinitely often, or $v_1$ and $v_2$, but not all three positions.  &lt;/p&gt;
&lt;p&gt;There is, however, a memoryful winning strategy: simply alternate between moving from $v_1$ to $v_0$ and to $v_2$.&lt;/p&gt;
&lt;p&gt;In the following, we solve Muller games via a reduction to parity games, i.e., we define a parity game such that we can translate the winning strategy in the parity game into a winning strategy in the Muller game.&lt;/p&gt;
&lt;p&gt;The fact that parity games are memoryless determined and Muller games are not, is not a contradiction: our reduction introduces additional state into the parity game, such that, on the extended state space, there exists a memoryless winning strategy. This augmentation of the state space is known as the &lt;strong&gt;latest appearence record&lt;/strong&gt;:&lt;/p&gt;
&lt;h2 id=&quot;Latest-Appearence-Record&quot;&gt;&lt;a href=&quot;#Latest-Appearence-Record&quot; class=&quot;headerlink&quot; title=&quot;Latest Appearence Record&quot;&gt;&lt;/a&gt;Latest Appearence Record&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Definition 11.11. } &#92;text{Let }V&#92;text{ be the set of positions of the game arena and let }{$}&#92;text{ be some fresh}&#92;newline&#92;text{symbol. A }&#92;textit{latest appearence record}&#92;text{ over }V&#92;text{ is a finite word over the alphabet }V&#92;cup&#92;lbrace{$}&#92;rbrace&#92;text{ where every}&#92;newline&#92;text{letter from }V&#92;cup&#92;lbrace{$}&#92;rbrace&#92;text{ appears exactly once and whose first letter is from }V&#92;text{ . The }&#92;textit{hit set}&#92;text{ of a latest}&#92;newline&#92;text{appearence record }&#92;ell&amp;#x3D;v_0v_1&#92;dots v_m{$}v_m+1&#92;dots v_n&#92;text{ is defined as }hit(&#92;ell)&amp;#x3D;&#92;lbrace v_0,&#92;dots v_m&#92;rbrace.$&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.4 -- Parity Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-4/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-4/</id>
    <published>2025-02-13T09:24:29.000Z</published>
    <updated>2025-04-03T07:41:15.438Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-3/&quot;&gt;B√ºchi Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Perhaps the most intriguing type of infinite games are &lt;strong&gt;parity games&lt;/strong&gt;. &lt;strong&gt;Parity games&lt;/strong&gt; play a key role in verification (in particular for $&#92;mu$-calculus model checking) and synthesis, and finding fast algorithms for parity games is an active research topic. &lt;/p&gt;
&lt;p&gt;The algorithm discussed in the following takes exponential time. There are also several quasi-polynomial-time algorithms for solving parity games (starting with a breakthrough result by Calude, Jain, Khoussainov, Li, and Stephan in 2017). In practice, however, these algorithms do not perform well (yet).&lt;/p&gt;
&lt;h2 id=&quot;Parity-Condition&quot;&gt;&lt;a href=&quot;#Parity-Condition&quot; class=&quot;headerlink&quot; title=&quot;Parity Condition&quot;&gt;&lt;/a&gt;Parity Condition&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Definition 11.10. }&#92;text{The }&#92;textit{parity condition }&#92;small&#92;text{PARITY} &#92;normalsize(C)&#92;text{ for a coloring function }c:V&#92;rightarrow&#92;mathbb{N}&#92;text{ is the set}$&lt;br&gt;$$&#92;small&#92;text{PARITY} &#92;normalsize(C)&amp;#x3D;&#92;lbrace&#92;alpha&#92;in V^&#92;omega&#92;mid&#92;text{max}&#92;lbrace c(q)&#92;mid q&#92;in&#92;text{Inf}(&#92;alpha)&#92;rbrace&#92;text{is even}&#92;rbrace.$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The parity condition is satisfied if the biggest number $q$ of the coloring function is even, among all positions that are visited infinitely often.&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/notes/uds/agv/11_4_parity.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.3 -- B√ºchi Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-3/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-3/</id>
    <published>2025-02-12T23:27:50.000Z</published>
    <updated>2025-04-03T07:41:15.408Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-2/&quot;&gt;Reachability Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Recurrence-Construction&quot;&gt;&lt;a href=&quot;#Recurrence-Construction&quot; class=&quot;headerlink&quot; title=&quot;Recurrence Construction&quot;&gt;&lt;/a&gt;Recurrence Construction&lt;/h2&gt;&lt;p&gt;In a B√ºchi game, the goal of Player 0 is to visit some accepting position &lt;strong&gt;infinitely often&lt;/strong&gt;. The attractor construction checks whether there is a strategy which enforces at least one visit to an accepting position. Reaching an accepting state at least once is indeed a necessary precondition, but we also have to ensure that from this position we can enforce a second visit to some accepting state, then a third, and so forth.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;recurrence construction&lt;/strong&gt; computes the largest subset of the accepting states from which Player 0 can enforce infinitely many subsequent visits to the subset.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Construction 11.2. } &#92;text{Let an arena }&#92;mathcal{A} &amp;#x3D; (V_0,V_1,E)&#92;text{ with }V&amp;#x3D;V_0&#92;cup V_1&#92;text{ be given. The }&#92;newline&#92;textit{recurrence construction}&#92;text{ on }&#92;mathcal{A}&#92;text{ is defined for all }n&#92;in&#92;mathbb{N}&#92;text{ and }F&#92;subseteq V&#92;text{ as:}$&lt;br&gt;$&#92;begin{array}{lll}&lt;br&gt;&#92;hspace{1cm} &#92;cdot &#92; W_n^1(F) &amp;amp;&amp;#x3D;&amp;amp; V&#92;setminus Attr^0(Recur_n(F))&#92;newline&lt;br&gt;&#92;hspace{1cm} &#92;cdot &#92; Recur_{0}(F)&amp;amp;&amp;#x3D;&amp;amp;F &#92;newline&lt;br&gt;&#92;hspace{1cm} &#92;cdot &#92; Recur_{n+1}(F)&amp;amp;&amp;#x3D;&amp;amp;Recur_{n}(F)&#92;setminus CPre^{1}(W_n^1(F)) &#92;newline&lt;br&gt;&#92;hspace{1cm} &#92;cdot &#92; Recur(F)&amp;amp;&amp;#x3D;&amp;amp;&#92;underset{n&#92;in&#92;mathbb{N}}{&#92;bigcap} Recur_{n}(R)&#92;newline&lt;br&gt;&#92;end{array}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The set $W_n^1(F)$ contains those positions in $V$ from which Player 1 can enforce that at most $n$ visits to $F$.&lt;/p&gt;
&lt;p&gt;The set $CPre^{1}(W_n^1(F))$ adds those positions in $V$ from which move to positions in $W_n^1(F)$, meaning that there are at most $n+1$ visits to $F$ in newly added positions.&lt;/p&gt;
&lt;p&gt;The set $Recur_{n}(F)$ contains the subset of $F$ from which Player 0 can enforce at least $n$ &lt;em&gt;further&lt;/em&gt; (i.e., a total of at least $n+1$) visits to $F$.&lt;/p&gt;
&lt;p&gt;The set $Recur(F)$ contains the subset of $F$ from which Player 0 can enforce infinitely many visits to $F$. The recurrence construction solves a game with winning condition $&#92;small&#92;text{B√úCHI} &#92;normalsize (F)$ as follows:&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.2 -- Reachability Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-2/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-2/</id>
    <published>2025-02-11T19:48:34.000Z</published>
    <updated>2025-04-03T07:41:15.439Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-1/&quot;&gt;Infinite Games (Basic Definitions)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Reachability-Condition&quot;&gt;&lt;a href=&quot;#Reachability-Condition&quot; class=&quot;headerlink&quot; title=&quot;Reachability Condition&quot;&gt;&lt;/a&gt;Reachability Condition&lt;/h2&gt;&lt;p&gt;We will now analyze infinite games for various types of winning conditions. We start with the simple &lt;strong&gt;reachability&lt;/strong&gt; condition.&lt;/p&gt;
&lt;p&gt;The reachability condition is given as a set $R$ of positions called the reachability set. The reachability condition is satisfied if the play reaches some position in $R$. Formally, for an infinite word $&#92;alpha$ over $&#92;Sigma$, we use $&#92;text{Occ}(&#92;alpha) :&amp;#x3D; &#92;lbrace&#92;sigma&#92;in&#92;Sigma&#92;mid&#92;exists n&#92;in&#92;mathbb{N}.&#92; &#92;alpha(n)&amp;#x3D;&#92;sigma&#92;rbrace$ to denote the set of all letters occurring in $&#92;alpha$.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Definition 11.11. } &#92;text{The }&#92;textit{reachability condition }&#92;small&#92;text{REACH} &#92;normalsize(R)&#92;text{ on a set of positions }R&#92;subseteq V&#92;text{ is the set}$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;&#92;small&#92;text{REACH} &#92;normalsize(R) &amp;#x3D; &#92;lbrace&#92;rho&#92;in V^&#92;omega&#92;mid&#92;text{Occ}(&#92;rho)&#92;cap R&#92;neq&#92;varnothing&#92;rbrace&#92;newline&#92;newline&#92;text{A game }&#92;mathcal{G}&amp;#x3D;(&#92;mathcal{A},&#92;text{Win})&#92;text{ with Win}&amp;#x3D;&#92;small&#92;text{REACH} &#92;normalsize(R)&#92;text{ is called a }&#92;textit{reachability game}&#92;text{ with reachability set }R&lt;br&gt;$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h3&gt;&lt;p&gt;$$&lt;br&gt;&#92;text{Position of Player 0: Circles;}&#92; &#92; &#92;text{Positions of Player 1: rectangles.}$$ &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/notes/uds/agv/11_2_reachability.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;$$&#92;mathcal{G}&amp;#x3D;(&#92;mathcal{A},&#92;small&#92;text{REACH} &#92;normalsize(R)),&#92; R&amp;#x3D;&#92;lbrace v_4,v_5&#92;rbrace&lt;br&gt;$$&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.1 -- Infinite Games (Basic Definitions)</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-1/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-1/</id>
    <published>2025-02-11T16:11:48.000Z</published>
    <updated>2025-04-03T07:41:15.408Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-5/&quot;&gt;From semi-deterministic B√ºchi to deterministic Muller&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;We now introduce &lt;em&gt;infinite two-player games on finite graphs&lt;/em&gt;. Infinite games are useful to solve the synthesis problem, where we are interested in finding a strategy that guarantees that a given specification is satisfied (cf. &lt;a href=&quot;../agv1.2/&quot;&gt;Section 1.2&lt;/a&gt;). As we will see, games also play a fundamental role in automata theory, in particular for automata over infinite trees.&lt;/p&gt;
&lt;h2 id=&quot;Basic-Definitions&quot;&gt;&lt;a href=&quot;#Basic-Definitions&quot; class=&quot;headerlink&quot; title=&quot;Basic Definitions&quot;&gt;&lt;/a&gt;Basic Definitions&lt;/h2&gt;&lt;p&gt;The game is played on a graph, called the &lt;strong&gt;arena&lt;/strong&gt;. The vertices of the graph are called &lt;strong&gt;positions&lt;/strong&gt; and are partitioned into the positions of Player 0 and the positions of Player 1. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A play of the game starts in some initial position&lt;/li&gt;
&lt;li&gt;In any positions, the player who &lt;strong&gt;owns the position chooses the edge&lt;/strong&gt; on which the play is continued.&lt;/li&gt;
&lt;li&gt;Player 0 wins if the play is an element of the &lt;strong&gt;winning condition&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The winner is determined by a winning condition, which, like the acceptance condition of an automaton on infinite words is a subset of the infinite words over the positions. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Definition 11.1. } &#92;text{A }&#92;textit{game arena}&#92;text{ is a tuple }&#92;mathcal{A} &amp;#x3D; (V,V_0,V_1,E)&#92;text{, where}&#92;newline&#92;begin{array}{l}&lt;br&gt;&#92;hspace{0.5cm} &#92;cdot &#92; V_0&#92;text{ and }V_1&amp;#x3D;V&#92;setminus V_0&#92;text{ are disjoint sets of positions,}&#92;newline&lt;br&gt;&#92;hspace{1cm} &#92;text{called the positions of Player 0 and Player 1.}&#92;newline&lt;br&gt;&#92;hspace{0.5cm} &#92;cdot &#92; E&#92;subseteq V&#92;times V&#92;text{ is a set of edges such that every position }v&#92;in V&#92;newline&lt;br&gt;&#92;hspace{1cm} &#92;text{has at least one outgoing edge }(v,v‚Äô)&#92;in E.&#92;newline&lt;br&gt;&#92;end{array}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Definition 11.2. } &#92;text{A }&#92;textit{play}&#92;text{ is an infinite sequence }  &#92;rho&#92;in V^&#92;omega&#92;text{ such that}$&lt;br&gt;$$&#92;forall n&#92;in&#92;mathbb{N}.(&#92;rho(n),&#92;rho(n+1))&#92;in E$$&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 10.5 -- From semi-deterministic B√ºchi to deterministic Muller</title>
    <link href="https://greenmeeple.github.io/AGV/agv10-5/"/>
    <id>https://greenmeeple.github.io/AGV/agv10-5/</id>
    <published>2025-02-11T07:41:39.000Z</published>
    <updated>2025-04-03T07:41:15.439Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-4/&quot;&gt;Semi-Deterministic B√ºchi Automata&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in</summary>
        
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 10.4 -- Semi-Deterministic B√ºchi Automata</title>
    <link href="https://greenmeeple.github.io/AGV/agv10-4/"/>
    <id>https://greenmeeple.github.io/AGV/agv10-4/</id>
    <published>2025-01-29T14:23:24.000Z</published>
    <updated>2025-04-03T07:41:15.407Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-3/&quot;&gt;Closure Properties of Muller automata Under Boolean Operations&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;To prove McNaughton‚Äôs theorem, in this subsection, we will introdue the &lt;strong&gt;semi-deterministic B√ºchi automata&lt;/strong&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;translate nondeterministic B√ºchi automata into semi-deterministic B√ºchi automata.&lt;/li&gt;
&lt;li&gt;translate from semi-deterministic B√ºchi automata to deterministic Muller automata.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Semi-deterministic-Buchi-Automata&quot;&gt;&lt;a href=&quot;#Semi-deterministic-Buchi-Automata&quot; class=&quot;headerlink&quot; title=&quot;Semi-deterministic B√ºchi Automata&quot;&gt;&lt;/a&gt;Semi-deterministic B√ºchi Automata&lt;/h2&gt;&lt;p&gt;A &lt;em&gt;semi-deterministic automaton&lt;/em&gt; is a (possibly nondeterministic) automaton where all accepting runs ultimately end up in a &lt;strong&gt;subset of the states&lt;/strong&gt; from which all transitions are deterministic.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Definition 10.2. } &#92;text{A B√ºchi automata }&#92;mathcal{A} &amp;#x3D; (&#92;Sigma,Q,I,T,&#92;small&#92;text{B√úCHI} &#92;normalsize(F))&#92;text{ is }&#92;textit{semi-deterministic}&#92;text{ if}&#92;newline Q &amp;#x3D; N &#92;uplus D&#92;text{ is a partition of }Q&#92;text{ such that }F&#92;subseteq D, pr_2(T&#92;cap(D&#92;times&#92;Sigma&#92;times Q))&#92;subseteq D&#92;text{, and }&#92;newline(&#92;Sigma,D,&#92;lbrace d&#92;rbrace,T&#92;cap(D&#92;times&#92;Sigma&#92;times D),&#92;small&#92;text{B√úCHI}&#92;normalsize(F)) &#92;text{ is deterministic for every }d&#92;in D.$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Explaination&quot;&gt;&lt;a href=&quot;#Explaination&quot; class=&quot;headerlink&quot; title=&quot;Explaination&quot;&gt;&lt;/a&gt;Explaination&lt;/h3&gt;&lt;p&gt;$Q &amp;#x3D; N &#92;uplus D:$ a &lt;em&gt;disjoint union symbol&lt;/em&gt; $&#92;uplus$ indicates that $N$ and $D$ are two seperated subset.&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>Appium commands that are commonly used on Mac</title>
    <link href="https://greenmeeple.github.io/appium/"/>
    <id>https://greenmeeple.github.io/appium/</id>
    <published>2025-01-01T18:36:48.000Z</published>
    <updated>2025-04-03T15:32:42.915Z</updated>
    
    
    <summary type="html">&lt;p&gt;In this example, we will use &lt;a href=&quot;https://github.com/appium/appium-inspector&quot;&gt;Appium Inspector&lt;/a&gt; to start a seesion on your emulator on &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Start-appium&quot;&gt;&lt;a href=&quot;#Start-appium&quot; class=&quot;headerlink&quot; title=&quot;Start appium&quot;&gt;&lt;/a&gt;Start appium&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/coding/appium/start.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;First, start the connection with Appium by &lt;code&gt;cmd appium --allow-cors&lt;/code&gt;. It also gives you the &lt;code&gt;remote url&lt;/code&gt; and the &lt;code&gt;automationName&lt;/code&gt; that can be used in the &lt;a href=&quot;https://github.com/appium/appium-inspector&quot;&gt;Appium Inspector&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/coding/appium/inspector.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Start-Session&quot;&gt;&lt;a href=&quot;#Start-Session&quot; class=&quot;headerlink&quot; title=&quot;Start Session&quot;&gt;&lt;/a&gt;Start Session&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;deviceName&lt;/strong&gt;:  &lt;code&gt;adb devices&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;platformName&lt;/strong&gt; - &lt;code&gt;appium driver list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;platformVersion&lt;/strong&gt; -  &lt;code&gt;adb shell getprop ro.build.version.release&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/coding/appium/session.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/coding/appium/inspector2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Now you can start a session in your emulator, but it always begins from the home page. To directly start a session on certain App, you also need to provide the  &lt;code&gt;appPackage&lt;/code&gt; and the &lt;code&gt;appActivity&lt;/code&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="Appium" scheme="https://greenmeeple.github.io/categories/Appium/"/>
    
    
    <category term="Appium" scheme="https://greenmeeple.github.io/tags/Appium/"/>
    
    <category term="App Testing" scheme="https://greenmeeple.github.io/tags/App-Testing/"/>
    
    <category term="Android" scheme="https://greenmeeple.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Automata, Games, and Verification (Portal)</title>
    <link href="https://greenmeeple.github.io/AGV/agv/"/>
    <id>https://greenmeeple.github.io/AGV/agv/</id>
    <published>2024-12-22T15:35:16.000Z</published>
    <updated>2025-04-03T07:41:15.405Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Chapter-1-Introduction&quot;&gt;&lt;a href=&quot;#Chapter-1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;Chapter 1. Introduction&quot;&gt;&lt;/a&gt;Chapter 1. Introduction&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Sections&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Exercise&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv1-1/&quot;&gt;1.1. Model Checking&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv1-2/&quot;&gt;1.2. Synthesis&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv1-3/&quot;&gt;1.3. The Logic-Automata Connection&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;Chapter-2-Buchi-Automata&quot;&gt;&lt;a href=&quot;#Chapter-2-Buchi-Automata&quot; class=&quot;headerlink&quot; title=&quot;Chapter 2. B√ºchi Automata&quot;&gt;&lt;/a&gt;Chapter 2. B√ºchi Automata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Sections&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Exercise&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv2-1/&quot;&gt;2.1. Preliminaries&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv2-2/&quot;&gt;2.2. Automata over Infinite Words&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv2-3/&quot;&gt;2.3. The B√ºchi Acceptance Condition&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;Chapter-3-Buchi‚Äôs-Characterization-Theorem&quot;&gt;&lt;a href=&quot;#Chapter-3-Buchi‚Äôs-Characterization-Theorem&quot; class=&quot;headerlink&quot; title=&quot;Chapter 3. B√ºchi‚Äôs Characterization Theorem&quot;&gt;&lt;/a&gt;Chapter 3. B√ºchi‚Äôs Characterization Theorem&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Sections&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Exercise&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv3-1/&quot;&gt;3.1. Kleene‚Äôs Theorem&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv3-2/&quot;&gt;3.2. $&#92;omega$-regular language&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv3-3/&quot;&gt;3.3 Closure Properties of the B√ºchi-recognizable languages (Intersection and Union)&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv3-4/&quot;&gt;3.4 Closure Properties of the B√ºchi-recognizable languages (Concatenations)&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv3-5/&quot;&gt;3.5 B√ºchi‚Äôs Characterization Theorem&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;Chapter-4-Deterministic-Buchi-Automata&quot;&gt;&lt;a href=&quot;#Chapter-4-Deterministic-Buchi-Automata&quot; class=&quot;headerlink&quot; title=&quot;Chapter 4. Deterministic B√ºchi Automata&quot;&gt;&lt;/a&gt;Chapter 4. Deterministic B√ºchi Automata&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Sections&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Exercise&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv4-1/&quot;&gt;4.1. Deterministic vs. Nondeterministic B√ºchi Automata&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;../agv4-2/&quot;&gt;4.2. Complementation of deterministic B√ºchi Automata&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;Chapter-5-Complementation-of-Buchi-automata&quot;&gt;&lt;a href=&quot;#Chapter-5-Complementation-of-Buchi-automata&quot; class=&quot;headerlink&quot; title=&quot;Chapter 5. Complementation of B√ºchi automata&quot;&gt;&lt;/a&gt;Chapter 5. Complementation of B√ºchi automata&lt;/h2&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>Cantonese Ch.1-6 -- Tones</title>
    <link href="https://greenmeeple.github.io/Canto/canto1-6/"/>
    <id>https://greenmeeple.github.io/Canto/canto1-6/</id>
    <published>2024-12-19T02:06:12.000Z</published>
    <updated>2025-04-03T07:41:15.401Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Golden Rule of becoming a native Cantonese speaker: &lt;strong&gt;Tones&lt;/strong&gt; &amp;gt; Everything!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this blog, we use &lt;a href=&quot;https://jyutping.org/en/docs/english/&quot;&gt;Jyutping&lt;/a&gt; to indicate the pronunciation of Cantonese characters.&lt;/p&gt;
&lt;p&gt;Previous lesson: &lt;a href=&quot;../canto1-3/&quot;&gt;Rimes with e&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;In this lesson, we talk about Rimes with &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;yu&lt;/code&gt;. Here we use &lt;code&gt;u&lt;/code&gt; similar to languages like German or Italian.&lt;/p&gt;
&lt;p&gt;And &lt;code&gt;yu&lt;/code&gt; is equivalent to ‚Äú√º‚Äù in German. Let‚Äôs take a look.&lt;/p&gt;
&lt;h2 id=&quot;Rimes-with-u&quot;&gt;&lt;a href=&quot;#Rimes-with-u&quot; class=&quot;headerlink&quot; title=&quot;Rimes with u&quot;&gt;&lt;/a&gt;Rimes with &lt;code&gt;u&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;For &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;ui&lt;/code&gt;, &lt;code&gt;un&lt;/code&gt;, &lt;code&gt;ut&lt;/code&gt;, u sounds like ‚Äúoo‚Äù in ‚Äúfoo‚Äù.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;ung&lt;/code&gt; and &lt;code&gt;uk&lt;/code&gt;, u sound like ‚Äúone‚Äù in ‚Äútone‚Äù.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;Jyutping&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Sounds in English&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Cantonese Example&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Jyutping&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Sounds in English&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;Cantonese Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;u&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;oo in foo&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;ruby&gt;Â§´&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;fu1&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;ut&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;oot in boot&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;ruby&gt;Èóä&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;fut3&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;ui&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;ewy in chewy&lt;sup&gt;1&lt;/sup&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;ruby&gt;ÁÅ∞&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;fui1&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;ung&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;one in tone&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;ruby&gt;È¢®&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;fung1&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;un&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;oon in cartoon&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;ruby&gt;Ê≠°&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;fun1&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;uk&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;ook in cook&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;ruby&gt;Á¶è&lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;fuk1&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="Cantonese" scheme="https://greenmeeple.github.io/categories/Cantonese/"/>
    
    <category term="Full_Course" scheme="https://greenmeeple.github.io/categories/Cantonese/Full-Course/"/>
    
    
    <category term="Cantonese" scheme="https://greenmeeple.github.io/tags/Cantonese/"/>
    
    <category term="Language Learning" scheme="https://greenmeeple.github.io/tags/Language-Learning/"/>
    
    <category term="Phonology" scheme="https://greenmeeple.github.io/tags/Phonology/"/>
    
  </entry>
  
  <entry>
    <title>AGV -- (Exercise 7.2) LTL to Alternating B√ºchi Automata</title>
    <link href="https://greenmeeple.github.io/AGV/agv7-2-eg/"/>
    <id>https://greenmeeple.github.io/AGV/agv7-2-eg/</id>
    <published>2024-12-17T03:02:09.000Z</published>
    <updated>2025-04-03T07:41:15.423Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous Exercise: &lt;a href&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is an example exercise to express LTL formula into Alternating B√ºchi Automata. For further definitions, you may check &lt;a href=&quot;../agv7-2/&quot;&gt;Section 7.2&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Question&quot;&gt;&lt;a href=&quot;#Question&quot; class=&quot;headerlink&quot; title=&quot;Question&quot;&gt;&lt;/a&gt;Question&lt;/h2&gt;&lt;p&gt;Use the &lt;a href=&quot;../agv7-2/&quot;&gt;construction from the lecture&lt;/a&gt; to construct an alternating B√ºchi automaton $&#92;mathcal{A}$ such that $$&#92;mathcal{L(A)&amp;#x3D;L}((&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q))$$&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;we build the following alternating B√ºchi automaton  $&#92;mathcal{A} &amp;#x3D; (2^{p,q},Q,&#92;varphi,&#92;delta,&#92;small&#92;text{B√úCHI} &#92;normalsize(F))$ which recognizes the models of $&#92;varphi&amp;#x3D;(&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q)$. First we consider the transition function $&#92;delta$ for an arbitrary symbol $a&#92;in2^{p,q}:$&lt;/p&gt;
&lt;p&gt;$&#92;begin{array}{lll}&lt;br&gt;&#92;hspace{1cm}&#92;bullet &amp;amp;&amp;amp;&#92;delta(&#92;square q,a)&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;delta(&#92;neg(&#92;textit{true}&#92; &#92;mathcal{U}&#92; &#92;neg q) ,a)&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;overline{&#92;delta(&#92;textit{true}&#92; &#92;mathcal{U}&#92; &#92;neg q ,a)}&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;overline{&#92;delta(&#92;neg q,a)&#92;vee(&#92;delta(&#92;textit{true},a)&#92;wedge(&#92;textit{true}&#92; &#92;mathcal{U}&#92; &#92;neg q))}&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;overline{&#92;delta(&#92;neg q,a)}&#92;wedge&#92;overline{(&#92;delta(&#92;textit{true},a)&#92;wedge (&#92;textit{true}&#92; &#92;mathcal{U}&#92; &#92;neg q))}&amp;amp;(&#92;textit{true}&#92;wedge &#92;psi&amp;#x3D;&#92;psi)&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;overline{&#92;delta(&#92;neg q,a)}&#92;wedge&#92;overline{(&#92;textit{true}&#92; &#92;mathcal{U}&#92; &#92;neg q)}&amp;amp;(&#92;text{Using line 1})&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;overline{&#92;delta(&#92;neg q,a)}&#92;wedge&#92;square q&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;left&#92;lbrace &#92;begin{array}{lll}&lt;br&gt;&#92;square q&amp;amp;&#92;text{if }q&#92;in a&#92;newline&lt;br&gt;&#92;textit{false}&amp;amp;&#92;text{if }q&#92;notin a&#92;newline&lt;br&gt;&#92;end{array}&#92;right.&lt;br&gt;&#92;end{array}&lt;br&gt;&#92; &#92;newline &#92; &#92;newline&lt;br&gt;&#92;begin{array}{lll}&lt;br&gt;&#92;hspace{1cm}&#92;bullet &amp;amp;&amp;amp;&#92;delta(&#92;Diamond p,a)&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;delta(&#92;textit{true}&#92; &#92;mathcal{U}&#92; p ,a)&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;delta(p,a)&#92;vee(&#92;delta(&#92;textit{true},a)&#92;wedge&#92;Diamond p)&amp;amp;(&#92;textit{true}&#92;wedge &#92;psi&amp;#x3D;&#92;psi)&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;delta(p,a)&#92;vee&#92;Diamond p&#92;newline&lt;br&gt;&amp;amp;&amp;#x3D;&amp;amp;&#92;left&#92;lbrace &#92;begin{array}{lll}&lt;br&gt;&#92;Diamond p&amp;amp;&#92;text{if }p&#92;notin a&#92;newline&lt;br&gt;&#92;textit{true}&amp;amp;&#92;text{if }p&#92;in a&#92;newline&lt;br&gt;&#92;end{array}&#92;right.&lt;br&gt;&#92;end{array}&lt;br&gt;$&lt;/p&gt;
&lt;p&gt;By Substitution above result into $&#92;delta((&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q),a)&amp;#x3D;&#92;delta(&#92;square q,a)&#92;vee(&#92;delta(&#92;Diamond p,a)&#92;wedge(&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q))$, we have:&lt;/p&gt;
&lt;p&gt;$$&#92;delta((&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q),a)&amp;#x3D;&#92;left&#92;lbrace&lt;br&gt;&#92;begin{array}{lll}&lt;br&gt;&#92;Diamond p&#92;wedge((&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q))&amp;amp;&#92;text{if }a &amp;#x3D;&#92;varnothing &amp;amp;(&#92;vee&#92; &#92;textit{false}&#92;text{ is omitted.})&#92;newline&lt;br&gt;(&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q)&amp;amp;&#92;text{if }a &amp;#x3D;&#92;lbrace p&#92;rbrace&amp;amp;(&#92;wedge&#92; &#92;textit{true}&#92;text{ is omitted.})&#92;newline&lt;br&gt;&#92;square q&#92;vee(&#92;Diamond p&#92;wedge((&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q)))&amp;amp;&#92;text{if }a &amp;#x3D;&#92;lbrace q&#92;rbrace&#92;newline&lt;br&gt;&#92;square q&#92;vee((&#92;Diamond p)&#92; &#92;mathcal{U}&#92; (&#92;square q))&amp;amp;&#92;text{if }a &amp;#x3D;&#92;lbrace p,q&#92;rbrace&amp;amp;(&#92;wedge&#92; &#92;textit{true}&#92;text{ is omitted.})&#92;newline&lt;br&gt;&#92;end{array}&#92;right.$$&lt;/p&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 10.3 -- Closure Properties of Muller automata Under Boolean Operations</title>
    <link href="https://greenmeeple.github.io/AGV/agv10-3/"/>
    <id>https://greenmeeple.github.io/AGV/agv10-3/</id>
    <published>2024-12-13T04:02:57.000Z</published>
    <updated>2025-04-03T07:41:15.440Z</updated>
    
    
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-2/&quot;&gt;From B√ºchi automata to Muller automata&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;We now show that deterministic Muller automata are closed, like nondeterministic B√ºchi automata, under the Boolean operations (&lt;code&gt;complementation&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, and &lt;code&gt;intersection&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;First we introduce the construction of these automaton with operations, then we will prove they are close by the runs under those constructions.&lt;/p&gt;
&lt;h2 id=&quot;Automata-construction-of-Complementation&quot;&gt;&lt;a href=&quot;#Automata-construction-of-Complementation&quot; class=&quot;headerlink&quot; title=&quot;Automata construction of Complementation&quot;&gt;&lt;/a&gt;Automata construction of Complementation&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;$&#92;textbf{Construction 10.3. } &#92;text{Let }&#92;mathcal{A} &amp;#x3D; (&#92;Sigma,Q,I,T,&#92;small&#92;text{MULLER} &#92;normalsize (&#92;mathcal{F}))&#92;text{ be a complete and deterministic Muller}&#92;newline&#92;text{automaton, where we assume w.l.o.g that }Q&#92;neq&#92;varnothing.&#92;text{ We construct the deterministic Muller}&#92;newline&#92;text{automaton }&#92;mathcal{A}^C &amp;#x3D; (&#92;Sigma,Q,I,T,&#92;small&#92;text{MULLER} &#92;normalsize(2^Q&#92;setminus&#92;mathcal{F}))&#92;text{ with }&#92;mathcal{L(A^C)}&amp;#x3D;&#92;Sigma&#92;setminus&#92;mathcal{L(A)}.$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Automata-construction-of-Intersection&quot;&gt;&lt;a href=&quot;#Automata-construction-of-Intersection&quot; class=&quot;headerlink&quot; title=&quot;Automata construction of Intersection&quot;&gt;&lt;/a&gt;Automata construction of Intersection&lt;/h2&gt;&lt;p&gt;We use the function $pr_n$ for $n&#92;in&#92;mathbb{N}$ to project to the (n+1)th component of a arbitrary length tuple, for example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$pr_0(x, y)&amp;#x3D;x$&lt;/li&gt;
&lt;li&gt;$pr_1(x, y)&amp;#x3D;y$&lt;/li&gt;
&lt;li&gt;$pr_2(x, y),pr_3(x, y),&#92;dots pr_n(x, y) &amp;#x3D;&#92;text{Undefined}$&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
</feed>
