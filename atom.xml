<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GreenMeeple</title>
  
  <subtitle>Coding, Boardgames, Language learning.</subtitle>
  <link href="https://greenmeeple.github.io/atom.xml" rel="self"/>
  
  <link href="https://greenmeeple.github.io/"/>
  <updated>2025-04-03T07:54:19.150Z</updated>
  <id>https://greenmeeple.github.io/</id>
  
  <author>
    <name>Alex Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow</title>
    <link href="https://greenmeeple.github.io/projects/mensaarlog2/"/>
    <id>https://greenmeeple.github.io/projects/mensaarlog2/</id>
    <published>2025-03-21T04:03:35.000Z</published>
    <updated>2025-04-03T07:54:19.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Repository: <a href="https://github.com/greenmeeple/MensaarLecker">MensaarLecker</a></p></blockquote><h2 id="Fetching-Data-from-Web-Development"><a href="#Fetching-Data-from-Web-Development" class="headerlink" title="Fetching Data from Web Development"></a>Fetching Data from Web Development</h2><p>Continuing from last post, we have already implemented a script that collect the Mensa menu and stored it on Google Sheets. It is time to build our web interface to connect the database.</p><h3 id="Fetch-Data-from-Google-Sheets-using-Publish"><a href="#Fetch-Data-from-Google-Sheets-using-Publish" class="headerlink" title="Fetch Data from Google Sheets using Publish"></a>Fetch Data from Google Sheets using Publish</h3><span id="more"></span><p>First, we need to publish our spreadsheet so that it is public to fetch the data.</p><ol><li><p>In the Spreadsheet, click <strong>Share</strong> ‚Üí Change access to Anyone with the link.</p><p> <img src="/images/projects/sheetshare.png"></p></li><li><p>Click <strong>File</strong> ‚Üí <strong>Share</strong> ‚Üí <strong>Publish</strong> to the web.</p></li><li><p>Select <strong>Entire Document</strong> ‚Üí <strong>Comma-separated values (.csv)</strong> and click Publish.</p></li><li><p>Copy the public CSV link.</p></li></ol><pre><code class="python">SCRIPT_URL = &#123;PUBLISH_LINK&#125;# Fetch JSON datadef fetch_menu():    try:        response = requests.get(SCRIPT_URL)        response.raise_for_status()  # Raise error if bad response        return response.json()    except requests.exceptions.RequestException as e:        print(f&quot;‚ùå Error fetching menu: &#123;e&#125;&quot;)        return []</code></pre><p>However, the script return no data, why?</p><pre><code class="error">Access to fetch at &#39;https://docs.google.com/spreadsheets/...&#39; from origin &#39;null&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. If an opaque response serves your needs, set the request&#39;s mode to &#39;no-cors&#39; to fetch the resource with CORS disabled.</code></pre><h3 id="CORS-Policy-and-XSS"><a href="#CORS-Policy-and-XSS" class="headerlink" title="CORS Policy and XSS"></a>CORS Policy and XSS</h3><blockquote><p>Cross-origin resource sharing (CORS) is an extension of the same-origin policy. You need it for authorized resource sharing with external third parties. ‚Äì Amazon Web Services</p></blockquote><p>This is a cyber security scheme to avoid <strong>XSS (Cross-site scripting)</strong>, in a nutshell, when we run the script, the code cannot proceed because it doesn‚Äôt login to any Google account! You can imagine the request is block by a imaginary login page and our program doesn‚Äôt know how to react.</p><h2 id="Second-Attempt-‚Äì-Google-Apps-Script"><a href="#Second-Attempt-‚Äì-Google-Apps-Script" class="headerlink" title="Second Attempt ‚Äì Google Apps Script"></a>Second Attempt ‚Äì Google Apps Script</h2><p>Google doesn‚Äôt allow users to fetch their data casually, except this is executed under Google‚Äôs server. This means we need to run our fetching function using Google‚Äôs service. <a href="https://developers.google.com/apps-script">Apps Script</a> provide a JavaScript editor to save your code.</p><p><img src="/images/projects/appscript.png"></p><pre><code class="JavaScript">function doGet() &#123;  var sheet = SpreadsheetApp.openById(&quot;PUT_YOUR_SHEET_ID_HERE&quot;).getActiveSheet();  var data = sheet.getDataRange().getValues();  var headers = data[0];  var jsonData = [];  for (var i = 1; i &lt; data.length; i++) &#123;    var row = &#123;&#125;;    for (var j = 0; j &lt; headers.length; j++) &#123;      row[headers[j]] = data[i][j];    &#125;    jsonData.push(row);  &#125;  var output = ContentService.createTextOutput(JSON.stringify(jsonData));  output.setMimeType(ContentService.MimeType.JSON);  return output;&#125;</code></pre><p>To get the sheet ID, we can simply open the sheet and it is part of the URL:</p><p><img src="/images/projects/sheetid.png"></p><h3 id="Deploying-the-function-and-fetch-the-data"><a href="#Deploying-the-function-and-fetch-the-data" class="headerlink" title="Deploying the function and fetch the data"></a>Deploying the function and fetch the data</h3><p>Afterwards, we can deploy this function and it will generate a unique URL for the function output and we can fetch the data (here we export the data in json format) and use it in our code.</p><p><img src="/images/projects/deploy.png"></p><p>You can also double check the URL and make sure it does return the value correctly ‚Üí <a href="https://script.google.com/macros/s/AKfycbzf5dQ0nWQBaxRV9B0AkFy5tdFIusaitiZdbTpEY1ZkvCGXG96cVXgbdZQf_LMeYsE/exec">link</a></p><pre><code class="python">SCRIPT_URL = &quot;URL_DEPLOYED_FROM_APP_SCRIPT&quot;;# Fetch JSON datadef fetch_menu():    try:        response = requests.get(SCRIPT_URL)        response.raise_for_status()  # Raise error if bad response        return response.json()    except requests.exceptions.RequestException as e:        print(f&quot;‚ùå Error fetching menu: &#123;e&#125;&quot;)        return []</code></pre><h2 id="Webpage-Implementation"><a href="#Webpage-Implementation" class="headerlink" title="Webpage Implementation"></a>Webpage Implementation</h2><p>To simplify our automation process on GitHub, we will continue implement our HTML code using Python. Our website should have two pages: <code>index.html</code> contains today‚Äôs menu, and <code>menu.html</code> contains the history of collected menus.</p><h3 id="Static-data-‚Äì-Tripe-Quotes"><a href="#Static-data-‚Äì-Tripe-Quotes" class="headerlink" title="Static data ‚Äì Tripe Quotes"></a>Static data ‚Äì Tripe Quotes</h3><p>We can put all the static code in strings. In Python we can store multi-line strings using <a href="https://www.geeksforgeeks.org/triple-quotes-in-python/">triple quotes</a>.</p><pre><code class="html">html = f&quot;&quot;&quot;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Mensaar Today&lt;/title&gt;    &lt;style&gt;        body &#123;&#123; font-family: Arial, sans-serif; padding: 20px; text-align: center; background-image: url('src/uds_spirit.jpg'); &#125;&#125;        h1 &#123;&#123;            background: rgba(255, 255, 255, 0.8);             color: #003C71;            padding: 10px 20px;            display: inline-block;             border-radius: 10px;             box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);         &#125;&#125;        .container &#123;&#123; width: 80%; margin: auto; &#125;&#125;        .closed-message &#123;&#123; font-size: 26px; color: red; font-weight: bold; padding: 20px; background: #fff3f3; border-radius: 10px; &#125;&#125;        .menu-card &#123;&#123; background: white; padding: 15px; margin: 10px 0; border-radius: 10px; box-shadow: 2px 2px 10px rgba(0,0,0,0.1); text-align: left; &#125;&#125;        .meal-title &#123;&#123; font-size: 20px; font-weight: bold; &#125;&#125;        .meal-components &#123;&#123; font-size: 16px; color: #666; &#125;&#125;        .meal-frequency &#123;&#123; font-size: 14px; color: #888; font-style: italic; &#125;&#125;        .button &#123;&#123; padding: 12px 20px; background: #007bff; color: white; border-radius: 5px; text-decoration: none; &#125;&#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Mensaar Menu for &#123;today&#125;&lt;/h1&gt;&lt;/br&gt;    &lt;a href=&quot;menu.html&quot; class=&quot;button&quot;&gt;üìú View Full Menu&lt;/a&gt;    &lt;div class=&quot;container&quot;&gt;    &quot;&quot;&quot;</code></pre><h3 id="Enhance-the-design-using-DataTable"><a href="#Enhance-the-design-using-DataTable" class="headerlink" title="Enhance the design using DataTable"></a>Enhance the design using <a href="https://datatables.net/">DataTable</a></h3><p>Since we will collect the menu everyday, the table in <code>menu.html</code> will become too long for loading and hard to check. We can use DataTable that provide basic table layout like filtering, searching, and sorting. Also, it is very easy to implement, simply include the JavaScript and CSS link in the HTML code and you can get the basic, but decent design.</p><h2 id="Automation-with-GitHub-Workflow"><a href="#Automation-with-GitHub-Workflow" class="headerlink" title="Automation with GitHub Workflow"></a>Automation with <a href="https://docs.github.com/en/actions/writing-workflows">GitHub Workflow</a></h2><p>Finally, after we deployed the code to GitHub, remember our original goal:</p><ol><li><p>Scrape the Mensa menu every weekday and store it to Google Sheets</p></li><li><p>Fetch the Data Collection from Google Sheets and update the website</p></li></ol><p>In fact, we can run the python script periodically using Github workflow, here are the steps:</p><ol><li><p>The workflow has to be implemented in <code>.yml</code> format, and stored in <code>.github/workflows/&#123;workflow_name&#125;.yml</code></p></li><li><p>Before running the python script, make sure python is set with all the dependencies installed:</p><pre><code class="yml">- name: üõ† Set up Python    uses: actions/setup-python@v4    with:        python-version: &quot;3.x&quot;- name: üì¶ Install dependencies    run: |        pip install requests selenium webdriver-manager gspread oauth2client- name: üöÄ Run Mensaar Scraper (update Google Sheets)    run: |        echo &quot;üß™ Starting Mensaar_scraper...&quot;        python Mensaar_scraper.py        echo &quot;‚úÖ Scraper completed.&quot;- name: üñºÔ∏è Run HTML Generator    run: |        echo &quot;üß™ Generating index.html &amp; menu.html&quot;        python generate_menu.py</code></pre></li><li><p>For the full workflow, you can find the skeleton code template on GitHub or you can check <a href="https://github.com/GreenMeeple/MensaarLecker/blob/main/.github/workflows/update_menu.yml">here</a>.</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Repository: &lt;a href=&quot;https://github.com/greenmeeple/MensaarLecker&quot;&gt;MensaarLecker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Fetching-Data-from-Web-Development&quot;&gt;&lt;a href=&quot;#Fetching-Data-from-Web-Development&quot; class=&quot;headerlink&quot; title=&quot;Fetching Data from Web Development&quot;&gt;&lt;/a&gt;Fetching Data from Web Development&lt;/h2&gt;&lt;p&gt;Continuing from last post, we have already implemented a script that collect the Mensa menu and stored it on Google Sheets. It is time to build our web interface to connect the database.&lt;/p&gt;
&lt;h3 id=&quot;Fetch-Data-from-Google-Sheets-using-Publish&quot;&gt;&lt;a href=&quot;#Fetch-Data-from-Google-Sheets-using-Publish&quot; class=&quot;headerlink&quot; title=&quot;Fetch Data from Google Sheets using Publish&quot;&gt;&lt;/a&gt;Fetch Data from Google Sheets using Publish&lt;/h3&gt;</summary>
    
    
    
    <category term="Projects" scheme="https://greenmeeple.github.io/categories/Projects/"/>
    
    
    <category term="Python" scheme="https://greenmeeple.github.io/tags/Python/"/>
    
    <category term="Scraper" scheme="https://greenmeeple.github.io/tags/Scraper/"/>
    
    <category term="Selenium" scheme="https://greenmeeple.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>üçΩ ü•® MensaarLecker -- A beloved tool to find out Mensa Ladies&#39; favourite menu using Seleniumü•® üçΩ</title>
    <link href="https://greenmeeple.github.io/projects/mensaar/"/>
    <id>https://greenmeeple.github.io/projects/mensaar/</id>
    <published>2025-03-20T04:03:35.000Z</published>
    <updated>2025-04-03T07:55:35.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Repository: <a href="https://github.com/greenmeeple/MensaarLecker">MensaarLecker</a></p></blockquote><p>As an <a href="https://www.uni-saarland.de/start.html">UdS</a> Student,<br>Are you tired of seeing french friesüçü 3 times a week, or wondering when I can have the best pizza üçï in the Mensacafe?<br>MensaarLecker aims to collect all the data from Menu 1, 2, and Mensacafe to trace your favourite, or Mensa Ladies‚Äô, favourite menu!</p><hr><h2 id="ü•ó-Description"><a href="#ü•ó-Description" class="headerlink" title="ü•ó Description"></a>ü•ó Description</h2><p>A fully automated scraper and static website for the Saarbr√ºcken Mensa, powered by Python, Selenium, Google Sheets, and GitHub Actions.</p><blockquote><p>Get a clean and daily-updated overview of meals from <a href="https://mensaar.de/">mensaar.de</a>, with searchable history, meal components, and frequency stats.</p></blockquote><span id="more"></span><hr><h2 id="üåê-Live-Demo"><a href="#üåê-Live-Demo" class="headerlink" title="üåê Live Demo"></a>üåê Live Demo</h2><p>üëâ <a href="https://your-username.github.io/MensaarLecker">View Website</a><br>üëâ <a href="https://docs.google.com/spreadsheets/d/your-sheet-id-here">View Data in Google Sheets</a></p><p><img src="/images/projects/menu.png"></p><hr><h2 id="üìÖ-Features"><a href="#üìÖ-Features" class="headerlink" title="üìÖ Features"></a>üìÖ Features</h2><ul><li>‚úÖ Scrapes the Saarbr√ºcken Mensa daily menu</li><li>‚úÖ Publishes structured data to a connected Google Sheet</li><li>‚úÖ Generates static HTML pages:<ul><li><strong><code>index.html</code></strong> ‚Äì Today‚Äôs menu with meal frequency counts</li><li><strong><code>menu.html</code></strong> ‚Äì Full searchable menu with DataTables</li></ul></li><li>‚úÖ Automatically updates via GitHub Actions at <strong>10:00 AM UTC on weekdays</strong></li><li>‚úÖ Beautiful card-style layout &amp; component display</li><li>‚úÖ No server required ‚Äî 100% static</li></ul><hr><h2 id="üß†-Meal-Frequency-Display-Example"><a href="#üß†-Meal-Frequency-Display-Example" class="headerlink" title="üß† Meal Frequency Display Example"></a>üß† Meal Frequency Display Example</h2><p>The homepage shows how often each meal has been served based on historical data since 2025.03.20:</p><p><strong>üçΩÔ∏è Pasta mit Tomatenso√üe</strong><br><em>üìä Seen since 2025.03.20</em><br>‚úÖ Geriebener K√§se<br>‚úÖ Rucola</p><p><img src="/images/projects/main.png"></p><hr><h2 id="üìÅ-Project-Structure"><a href="#üìÅ-Project-Structure" class="headerlink" title="üìÅ Project Structure"></a>üìÅ Project Structure</h2><pre><code class="bash">.‚îú‚îÄ‚îÄ Mensaar_scraper.py         # Scrapes from mensaar.de and writes to Google Sheet‚îú‚îÄ‚îÄ generate_menu.py           # Reads the sheet and generates index.html and menu.html‚îú‚îÄ‚îÄ credentials.json           # Google service account key (excluded from repo)‚îú‚îÄ‚îÄ index.html                 # Main website page with today&#39;s menu‚îú‚îÄ‚îÄ menu.html                  # Full searchable table of meals‚îú‚îÄ‚îÄ .github/workflows/‚îÇ   ‚îî‚îÄ‚îÄ update_menu.yml        # GitHub Actions automation‚îú‚îÄ‚îÄ src/‚îÇ   ‚îî‚îÄ‚îÄ uds_spirit.jpg         # Soul of this project‚îî‚îÄ‚îÄ README.md</code></pre><h2 id="üìù-Development-Log"><a href="#üìù-Development-Log" class="headerlink" title="üìù Development Log"></a>üìù Development Log</h2><p><a href="../mensaarlog1">MensaarLecker Development Log 1 ‚Äì Web Crawling</a><br><a href="../mensaarlog2">MensaarLecker Development Log 2 ‚Äì Web Developing and GitHub Workflow</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Repository: &lt;a href=&quot;https://github.com/greenmeeple/MensaarLecker&quot;&gt;MensaarLecker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As an &lt;a href=&quot;https://www.uni-saarland.de/start.html&quot;&gt;UdS&lt;/a&gt; Student,&lt;br&gt;Are you tired of seeing french friesüçü 3 times a week, or wondering when I can have the best pizza üçï in the Mensacafe?&lt;br&gt;MensaarLecker aims to collect all the data from Menu 1, 2, and Mensacafe to trace your favourite, or Mensa Ladies‚Äô, favourite menu!&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;ü•ó-Description&quot;&gt;&lt;a href=&quot;#ü•ó-Description&quot; class=&quot;headerlink&quot; title=&quot;ü•ó Description&quot;&gt;&lt;/a&gt;ü•ó Description&lt;/h2&gt;&lt;p&gt;A fully automated scraper and static website for the Saarbr√ºcken Mensa, powered by Python, Selenium, Google Sheets, and GitHub Actions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Get a clean and daily-updated overview of meals from &lt;a href=&quot;https://mensaar.de/&quot;&gt;mensaar.de&lt;/a&gt;, with searchable history, meal components, and frequency stats.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Projects" scheme="https://greenmeeple.github.io/categories/Projects/"/>
    
    
    <category term="Python" scheme="https://greenmeeple.github.io/tags/Python/"/>
    
    <category term="Scraper" scheme="https://greenmeeple.github.io/tags/Scraper/"/>
    
    <category term="Selenium" scheme="https://greenmeeple.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>MensaarLecker Development Log 1 -- Web Crawling</title>
    <link href="https://greenmeeple.github.io/projects/mensaarlog1/"/>
    <id>https://greenmeeple.github.io/projects/mensaarlog1/</id>
    <published>2025-03-20T04:03:35.000Z</published>
    <updated>2025-04-03T07:54:31.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Repository: <a href="https://github.com/greenmeeple/MensaarLecker">MensaarLecker</a></p></blockquote><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>Me and my friends <del>hate</del><strong>love</strong> the UdS Mensa so much! The infinite frozen food and french fries menus give us so much energy and motivation for the 5-hour afternoon coding marathon. However, no one actually knows how many potatoes they have exterminated throughout the week. We have a genius webpage created by some <a href="https://gibtesheuteschnitzel.de/">Schnitzel lover</a>. Personally, I like its minimalistic layout and determination on Schnitzel searching. </p><blockquote><p>However, we want more.</p></blockquote><p>It‚Äôs not just Schnitzel; we want to know everything about their menu. We want to know what‚Äôs inside the mensa ladies‚Äô brains when they design next week‚Äôs menu.</p><blockquote><p>The desire never ends. We need more data, more details, more, More, <strong>MORE!</strong></p></blockquote><span id="more"></span><h2 id="Developing-Process"><a href="#Developing-Process" class="headerlink" title="Developing Process"></a>Developing Process</h2><p>Our Goal here is simple:</p><ol><li><p>Scrape the Mensa menu every weekday and store it to Google Sheets</p></li><li><p>Fetch the Data Collection from Google Sheets and update the website</p></li></ol><h2 id="Web-Scraping"><a href="#Web-Scraping" class="headerlink" title="Web Scraping"></a>Web Scraping</h2><p>To collect the data, we can use Python libraries to simplfied the process. But the basic idea it the same: we try to find the pattern of the HTML tag and locate the desired data.</p><h3 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">Beautiful Soup</a></h3><p>I started my journey with Beautiful Soup, one of the most popular Python web scraper packages. However, as a Uni that is well-known for its computer science program, all the menus are rendered using JavaScript. And beautiful can only scrape HTML and XML tags. So the scraper can only see an empty skeleton page:</p><p><img src="/images/projects/mensaar_empty.png"></p><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a><a href="https://selenium-python.readthedocs.io/">Selenium</a></h3><p>Basically, Selenium is a <a href="https://www.selenium.dev/documentation/webdriver/">Webdriver</a> that opens a browser naturally, like a human user. Then from there we can scrape the rendered information. Things get simpler once we can see the website as we see it on the browser. We just need to find the tag that contains the information we need and save it for storage.</p><h3 id="Desired-Data-and-Tags"><a href="#Desired-Data-and-Tags" class="headerlink" title="Desired Data and Tags"></a>Desired Data and Tags</h3><table><thead><tr><th align="left">Data</th><th align="left">Tag</th></tr></thead><tbody><tr><td align="left">menus</td><td align="left"><code>&lt;div class=&quot;counter&quot;&gt;</code></td></tr><tr><td align="left">date</td><td align="left"><code>&lt;div class=&quot;cursor-pointer active list-group-item&quot;&gt;</code></td></tr><tr><td align="left">main dish</td><td align="left"><code>&lt;span class=&quot;meal-title&quot;&gt;</code></td></tr><tr><td align="left">side dish</td><td align="left"><code>&lt;div class=&quot;component&quot;&gt;</code></td></tr></tbody></table><p>The first part of the task is to get the daily menu. We also get the date on the website to make the following work easier.</p><p>By the <code>find_element</code> and <code>find_elements</code> functions in Selenium, we can create a simple scraper like this:</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.by import Bydriver = webdriver.Firefox()driver.get(&quot;https://mensaar.de/#/menu/sb&quot;)counters = driver.find_elements(By.CLASS_NAME, &quot;counter&quot;)for counter in counters:    meal_title = meal.find_element(By.CLASS_NAME, &quot;meal-title&quot;).text.strip()</code></pre><p>However, on the webpage there is also a counter called <code>Wahlessen.</code> Which refers to a more pricy and unpredictable menu, and we want to exclude its data:</p><pre><code class="python">counter_title = counter.find_element(By.CLASS_NAME, &quot;counter-title&quot;).text.strip()# Filter for specified counter titlesif counter_title in [&quot;Men√º 1&quot;, &quot;Men√º 2&quot;, &quot;Mensacaf√©&quot;]:    meal_title = meal.find_element(By.CLASS_NAME, &quot;meal-title&quot;).text.strip()</code></pre><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>In order to make the database easy to be accessed by other users&#x2F;students, we decided to deploy the data set to Google SpreadSheets.</p><pre><code class="python">with open(output_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:    json.dump(result, f, ensure_ascii=False, indent=2)print(f&quot;Results saved to &#123;output_file&#125;&quot;)# Save the updated occurrence counts to the JSON filecount_result = &#123;    &quot;meal_counts&quot;: dict(meal_count),    &quot;component_counts&quot;: dict(component_count)&#125;with open(count_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:    json.dump(count_result, f, ensure_ascii=False, indent=2)print(f&quot;Counts saved to &#123;count_file&#125;&quot;)</code></pre><h3 id="Change-the-time-format"><a href="#Change-the-time-format" class="headerlink" title="Change the time format"></a>Change the time format</h3><p>Once we fetch data, you may notice that the website display the date in german format e.g. ‚ÄúFreitag, 21. M√§rz 2025‚Äù, which is not recognized by Google Sheets directly. So we need to make a function to convert them before uploading:</p><pre><code class="python">GERMAN_MONTHS = &#123;    &quot;Januar&quot;: &quot;01&quot;, &quot;Februar&quot;: &quot;02&quot;, &quot;M√§rz&quot;: &quot;03&quot;, &quot;April&quot;: &quot;04&quot;,    &quot;Mai&quot;: &quot;05&quot;, &quot;Juni&quot;: &quot;06&quot;, &quot;Juli&quot;: &quot;07&quot;, &quot;August&quot;: &quot;08&quot;,    &quot;September&quot;: &quot;09&quot;, &quot;Oktober&quot;: &quot;10&quot;, &quot;November&quot;: &quot;11&quot;, &quot;Dezember&quot;: &quot;12&quot;&#125;def format_date(german_date):    match = re.search(r&quot;(\d&#123;1,2&#125;)\. (\w+) (\d&#123;4&#125;)&quot;, german_date)    if match:        day, month, year = match.groups()        month_number = GERMAN_MONTHS.get(month, &quot;00&quot;)        return f&quot;&#123;year&#125;-&#123;month_number&#125;-&#123;int(day):02d&#125;&quot;    return &quot;0000-00-00&quot;</code></pre><h2 id="Upload-the-data-to-Google-Sheets"><a href="#Upload-the-data-to-Google-Sheets" class="headerlink" title="Upload the data to Google Sheets"></a>Upload the data to Google Sheets</h2><p>In order to interact with the Google Sheets, we need to use Google API. First, go to <a href="https://console.cloud.google.com/">Google Cloud Console</a>.</p><p><img src="/images/projects/googleapi.png"></p><p>Create a new project. Next, go to <strong>API and Services</strong>, click <strong>Enable API and Services</strong></p><p><img src="/images/projects/apiservices.png"></p><p>Search <strong>Google Sheets API</strong>, select it and choose <strong>Enable</strong>„ÄÇ</p><p><img src="/images/projects/googlesheet.png"></p><p>Move <strong>Credentials</strong> from the sidebar, then choose <strong>Create credentials</strong> ‚Üí <strong>Create service account</strong></p><p><img src="/images/projects/credentials.png"></p><p>In step 2, choose the role <strong>Editor</strong></p><p><img src="/images/projects/editor.png"></p><p>Now, when you come back to the <strong>Credentials</strong> page, you should see a newly generated email under <strong>Service Accounts</strong>, click it and select the tab <strong>Keys</strong></p><p><img src="/images/projects/key.png"></p><p>Select <strong>Create new key</strong>, choose <strong>JSON</strong> format, the file should start downloading automatically.</p><blockquote><p><strong><code>Important Notice</code></strong><br><code>This JSON file contains sensitive data, you should NEVER directly use it in your code, save it as an environment variable or save it as a secret on Github</code></p></blockquote><p><img src="/images/projects/secret.png"></p><p>With this key we can login the email we just created in <strong>Service Accounts</strong>, so that it is treated as a virtual users when running the script. Same as human users, in order to access the sheet we need to add this email as an editor in Google Sheets.</p><pre><code class="python">try:    # Read and validate credentials.json before using it    if not os.path.exists(&quot;credentials.json&quot;):        print(&quot;‚ùå credentials.json not found!&quot;)        return    with open(&quot;credentials.json&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:        raw_creds = f.read()        creds_data = json.loads(raw_creds)    # Save to a temp file just in case gspread needs it as a file    temp_path = &quot;parsed_credentials.json&quot;    with open(temp_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:        json.dump(creds_data, f)    creds = ServiceAccountCredentials.from_json_keyfile_name(temp_path, scope)    client = gspread.authorize(creds)    sheet = client.open(SHEET_NAME).sheet1    print(&quot;‚úÖ Google Sheets Auth OK&quot;)</code></pre><h2 id="End-of-Scraping"><a href="#End-of-Scraping" class="headerlink" title="End of Scraping"></a>End of Scraping</h2><p>Now we all set! Next, we need to display our collected results on web interfaces.</p><p>Continue Reading: <a href="../mensaarlog2">MensaarLecker Development Log 2 ‚Äì Web Developing and GitHub Workflow</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Repository: &lt;a href=&quot;https://github.com/greenmeeple/MensaarLecker&quot;&gt;MensaarLecker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Motivation&quot;&gt;&lt;a href=&quot;#Motivation&quot; class=&quot;headerlink&quot; title=&quot;Motivation&quot;&gt;&lt;/a&gt;Motivation&lt;/h2&gt;&lt;p&gt;Me and my friends &lt;del&gt;hate&lt;/del&gt;&lt;strong&gt;love&lt;/strong&gt; the UdS Mensa so much! The infinite frozen food and french fries menus give us so much energy and motivation for the 5-hour afternoon coding marathon. However, no one actually knows how many potatoes they have exterminated throughout the week. We have a genius webpage created by some &lt;a href=&quot;https://gibtesheuteschnitzel.de/&quot;&gt;Schnitzel lover&lt;/a&gt;. Personally, I like its minimalistic layout and determination on Schnitzel searching. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, we want more.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It‚Äôs not just Schnitzel; we want to know everything about their menu. We want to know what‚Äôs inside the mensa ladies‚Äô brains when they design next week‚Äôs menu.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The desire never ends. We need more data, more details, more, More, &lt;strong&gt;MORE!&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Projects" scheme="https://greenmeeple.github.io/categories/Projects/"/>
    
    
    <category term="Python" scheme="https://greenmeeple.github.io/tags/Python/"/>
    
    <category term="Scraper" scheme="https://greenmeeple.github.io/tags/Scraper/"/>
    
    <category term="Selenium" scheme="https://greenmeeple.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>AGV 12.3 -- Complementation of Parity Tree Automata</title>
    <link href="https://greenmeeple.github.io/AGV/agv12-3/"/>
    <id>https://greenmeeple.github.io/AGV/agv12-3/</id>
    <published>2025-02-16T19:12:54.000Z</published>
    <updated>2025-04-03T07:41:15.411Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv12-2/">Emptiness Game</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now prove that parity tree automata are closed under complementation. As discussed at the beginning of the section, our proof makes heavy use of the determinacy of parity games (with infinite game arenas) established in <a href="../agv11-4">Theorem 11.3</a>.</p><blockquote><p>$\textbf{Theorem 12.3. } \textit{For every parity tree automaton }\mathcal{A}\textit{ over }\Sigma\textit{ there is a parity tree automaton }\mathcal{A}‚Äô\newline\textit{ with }\mathcal{L(A‚Äô)}&#x3D;\mathcal{T}_\Sigma\setminus\mathcal{L(A)}.$</p></blockquote><h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Let $\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,\small\text{PARITY} \normalsize(C))$. By Theorem 12.1, a tree $(\mathcal{T},t)$ is accepted by $\mathcal{A}$ iff Player 0 has a winning strategy from position $(\varepsilon,q_0)$ of the acceptance game $\mathcal{G}_{\mathcal{A},t}$. </p><p>Since $\mathcal{A}$ is a parity tree automaton, $\mathcal{G}<em>{\mathcal{A},t}$ is a parity game and therefore, by Theorem 11.3, memoryless determined. Hence, $\mathcal{A}$ does not accept some tree $t$ iff Player 1 has a winning memoryless strategy $\sigma$ in $\mathcal{G}</em>{\mathcal{A},t}$ from $(\varepsilon,q_0)$. </p><p>The strategy $\sigma:\lbrace 0,1\rbrace^\ast\times T\rightarrow\lbrace 0,1\rbrace^\ast\times Q$ can be represented as a function $\sigma‚Äô:\lbrace 0,1\rbrace^\ast\times T\rightarrow\lbrace 0,1\rbrace$</p><p>where $\sigma(w,(q,\sigma,q^0,q^1))&#x3D;(wi,q^i)$ iff $\sigma‚Äô(w,(q,\sigma,q^0,q^1))&#x3D;i$. Yet another representation of the same strategy is $\sigma‚Äô:\lbrace 0,1\rbrace^\ast\rightarrow\lbrace T\rightarrow\lbrace 0,1\rbrace\rbrace$,</p><p>which can be understood as a labeling of $\mathcal{T}$ with finite ‚Äúlocal strategies‚Äù. Hence, A does not accept $(\mathcal{T},t)$ iff</p><ol><li>there is a $(T\rightarrow\lbrace 0,1\rbrace)$-labeled tree $(\mathcal{T},v)$ such that</li><li>for all i0i1i2 . . . ‚àà {0, 1}</li></ol><hr><p>Next chapter: <a href="../agv/"></a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv12-2/&quot;&gt;Emptiness Game&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://ci</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 12.2 -- Emptiness Game</title>
    <link href="https://greenmeeple.github.io/AGV/agv12-2/"/>
    <id>https://greenmeeple.github.io/AGV/agv12-2/</id>
    <published>2025-02-16T18:11:08.000Z</published>
    <updated>2025-04-03T07:41:15.436Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv12-1/">Tree Automata and Acceptance Game</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Emptiness-Game"><a href="#Emptiness-Game" class="headerlink" title="Emptiness Game"></a>Emptiness Game</h2><p>The acceptance game can also be used to test if the language of a given tree automaton is non-empty. For this purpose, we first translate the given automaton into an automaton with singleton alphabet.</p><blockquote><p>$\textbf{Construction 12.1. } \text{For a given tree automaton }\mathcal{A}\text{ over }\Sigma\text{-labeled trees, we consider the}\newline\text{following tree automaton }\mathcal{A}‚Äô\text{ over }\lbrace1\rbrace\text{-labeled trees, such that }\mathcal{L(A)}&#x3D;\varnothing\text{ iff }\mathcal{L(A‚Äô)}&#x3D;\varnothing:\newline<br>\begin{array}{l}<br>\hspace{1cm} \cdot \ Q‚Äô&#x3D;Q \newline<br>\hspace{1cm} \cdot \ q_0‚Äô&#x3D;q_0\newline<br>\hspace{1cm} \cdot \ T‚Äô&#x3D;\lbrace(q,1,q‚Äô,q‚Äô‚Äô)\mid(q,\sigma,q‚Äô,q‚Äô‚Äô)\in T,\sigma\in\Sigma\rbrace\newline<br>\hspace{1cm} \cdot \ Acc‚Äô &#x3D; Acc<br>\end{array}$</p></blockquote><p>Because the subtrees of a $\lbrace 1\rbrace$-labeled binary tree are the same from all nodes, we can simplify its acceptance game such that only finitely many positions are needed. We call this game the <strong>emptiness game</strong>.</p><blockquote><p>$\textbf{Definition 12.5. } \text{Let }\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,Acc)\text{ be a tree automaton. The }\textit{emptiness game}\text{ of }\mathcal{A}\newline \text{ is the game }\mathcal{G}_{\mathcal{A}}&#x3D;(\mathcal{A}‚Äô,\text{Win}‚Äô)\text{ with the finite game arena }\mathcal{A}‚Äô&#x3D;(Q\cup T, Q,T,E)\text{, where}\newline E&#x3D;\lbrace(q,\tau)\mid\tau&#x3D;(q,\sigma,q^0,q^1),\tau\in T\rbrace\cup\lbrace(\tau,q‚Äô)\mid\tau&#x3D;(\rule{0.5em}{0.4pt},\sigma,q^0,q^1)\text{ and }(q‚Äô&#x3D;q^0\text{ or }q‚Äô&#x3D;q^1)\rbrace\newline\text{and Win‚Äô}&#x3D;\lbrace q(0)\tau(0)q(1)\tau(1)\dots\mid q(0)q(1)\dots\in Acc,\tau(0)\tau(1)\dots\in T^\omega\rbrace$</p></blockquote><blockquote><p>$\textbf{Theorem 12.2. } \textit{The language of a tree automaton }\mathcal{A}\textit{ is non-empty iff Player 0 wins the}\newline\textit{emptiness game }\mathcal{G}_{\mathcal{A}}\textit{ from position }q_0.$</p></blockquote><h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>The emptiness game corresponds to the acceptance game of the automaton from Construction 12.1 on the $\lbrace 1\rbrace$-labeled binary tree.</p><hr><p>Next chapter: <a href="../agv11-3/">Complementation of Parity Tree Automata</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv12-1/&quot;&gt;Tree Automata and Acceptance Game&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in </summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 12.1 -- Tree Automata and Acceptance Game</title>
    <link href="https://greenmeeple.github.io/AGV/agv12-1/"/>
    <id>https://greenmeeple.github.io/AGV/agv12-1/</id>
    <published>2025-02-15T23:21:11.000Z</published>
    <updated>2025-04-03T07:41:15.408Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv11-6/">A Remark on Undetermined Games</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Infinite games allow us to reason elegantly about infinite trees. A famous example of an argument that became significantly simpler with the introduction of game-theoretic ideas is the proof of <strong>Rabin‚Äôs theorem</strong>. </p><p>Rabin‚Äôs theorem states that the satisfiability of <strong>monadic second-order logic with two successors (S2S)</strong> is decidable. Like in <a href="../agv6-5/">Section 6</a>, where we showed that S1S formulas can be translated to automata, we will show that S2S formulas can be translated to automata, this time, in order to accommodate more than one successor function, to automata over infinite trees. </p><p>The most difficult part of the proof of Rabin‚Äôs theorem is to show that tree automata are <em>closed under complement</em>. The original proof was purely combinatorial (and very difficult to understand), but the game-theoretic argument is simply based on <strong>the determinacy of the acceptance game of the tree automaton</strong>:</p><ul><li><p>the acceptance of a tree by a tree automaton &#x3D; the existence of a winning strategy for Player 0,</p></li><li><p>the non-acceptance &#x3D; the absence of such a strategy &#x3D; the existence of a winning strategy for Player 1.</p></li></ul><p>We can therefore complement the language of a given tree automaton by constructing a new automaton that verifies the existence of a winning strategy for Player 1. We begin this section with a discussion of tree automata. The logic S2S and the translation to tree automata will be introduced later in the section.</p><h2 id="Tree-Automata"><a href="#Tree-Automata" class="headerlink" title="Tree Automata"></a>Tree Automata</h2><p>We consider tree automata over infinite binary trees. We use the notation for trees introduced in <a href="../agv7-1/">Section 7.1</a>. The (full) binary tree is the language $\mathcal{T} &#x3D;\lbrace 0, 1\rbrace^\ast$. For an alphabet $\Sigma, \mathcal{T}_\Sigma &#x3D; \lbrace(\mathcal{T}, t)\mid t:\mathcal{T}\rightarrow\Sigma\rbrace$ is the set of all binary $\Sigma$-labeled trees.</p><blockquote><p>$\textbf{Definition 12.1. } \text{An }\textit{automaton over infinite binary trees }\mathcal{A}\text{ is a tuple }(\Sigma,Q,q_0,T,Acc)\text{, where}\newline<br>\begin{array}{l}<br>\hspace{1cm} \cdot \ \Sigma \text{ is a finite alphabet,} \newline<br>\hspace{1cm} \cdot \ Q \text{ is a finite set of states,} \newline<br>\hspace{1cm} \cdot \ q_0 \in Q \text{ is an initial states,} \newline<br>\hspace{1cm} \cdot \ T \subseteq Q \times \Sigma \times Q \times Q, \newline<br>\hspace{1cm} \cdot \ Acc \subseteq Q^\omega \text{ is the accepting condition}<br>\end{array}$</p></blockquote><p>In the following, we will refer to automata over infinite binary trees simply as tree automata. Note that a transition of a tree automaton has two successor states, rather than a successor state as for word automata. The two states correspond to the two directions 0 and 1 of the input tree, the automaton may transition into different states for the different directions.</p><blockquote><p>$\textbf{Definition 12.2. } \text{A }\textit{run }\text{of a tree automata }\mathcal{A}\text{ on an infinite }\Sigma\text{-labeled binary tree }(\mathcal{T},t)\newline\text{ is a }Q\text{-labeled binary tree }(\mathcal{T},r)\text{ such that the following hold:}\newline<br>\begin{array}{l}<br>\hspace{0.5cm} \cdot \ r(\varepsilon)&#x3D;q_0 \hspace{2.5cm} \cdot \ (r(n),t(n),r(n0),r(n1))\in T\text{ for all }n\in\lbrace 0,1\rbrace^\ast<br>\end{array}$</p></blockquote><p>Note that $n0$ and $n1$ are the children of node $n$ in direction 0 and 1, respectively. The <strong>accepting runs</strong> are defined as for alternating automata in <a href="../agv7-1/">Section 7.1</a>: we apply the acceptance condition to the branches of the run tree. (Note that a run of an alternating automaton may have finite and infinite branches. The acceptance condition is only checked on infinite branches. Here, all branches are infinite.)</p><blockquote><p>$\textbf{Definition 12.3. } \text{A }\textit{run }(\mathcal{T},r)\text{ is }\textit{accepting}\text{ iff, for every infinite branch }n_0n_1n_2\dots,$<br>$$r(n_0)r(n_1)r(n_2)\dots\in Acc$$</p></blockquote><p>The language of the tree automaton $\mathcal{A}$ consists of the set of accepted $\Sigma$-labeled trees.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>The following B√ºchi tree automaton $\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,\small\text{B√úCHI}\normalsize(F))$ accepts all $\lbrace a,b\rbrace$-labeled trees with infinitely many $b$‚Äôs on each branch.</p><ul><li>$\Sigma &#x3D; \lbrace a,b\rbrace$</li><li>$Q&#x3D;\lbrace q_a,q_b\rbrace; q_0&#x3D;q_a$</li><li>$T&#x3D;\lbrace(q_a,a,q_a,q_a),(q_b,a,q_a,q_a),(q_a,b,q_b,q_b),(q_b,b,q_b,q_b)\rbrace$</li><li>$F &#x3D; \lbrace q_b\rbrace$</li></ul><p>Consider the $\Sigma$-labeled input tree $(\mathcal{T},t)$:</p><p><img src="/images/notes/uds/agv/12_1_inputtree.png"></p><p>The following $Q$-labeled tree is a run $(\mathcal{T},r)$ of $\mathcal{A}$ on $(\mathcal{T},t)$:</p><p><img src="/images/notes/uds/agv/12_1_runtree.png"></p><h2 id="Acceptance-Game"><a href="#Acceptance-Game" class="headerlink" title="Acceptance Game"></a>Acceptance Game</h2><p>The acceptance mechanism of a tree automaton is also characterized via its <strong>acceptance game</strong>. Player 0 can choose the alphabet $t(w)$ and Player 1 can choose the next state $q‚Äô$:</p><blockquote><p>$\textbf{Definition 12.4. } \text{Let }\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,Acc)\text{ be a tree automata and let }(\mathcal{T},t)\text{ be a }\Sigma\text{-labeled}\newline\text{binary tree. Then the }\textit{acceptance game}\text{ of }\mathcal{A}\text{ on }(\mathcal{T},t)\text{ is the game }\mathcal{G}_{\mathcal{A},t}&#x3D;(\mathcal{A}‚Äô,\text{Win}‚Äô)\text{ with the}\newline\text{infinite game arena }\mathcal{A}‚Äô&#x3D;(V‚Äô,V_0‚Äô,V_1‚Äô,E‚Äô)\text{ and the winning condition Win‚Äô defined as follows:}\newline<br>\begin{array}{lll}<br>\hspace{1cm} \cdot \ V_0‚Äô&amp;&#x3D;&amp;\lbrace(w,q)\mid w\in\lbrace0,1\rbrace^\ast,q\in Q\rbrace\newline<br>\hspace{1cm} \cdot \ V_1‚Äô&amp;&#x3D;&amp;\lbrace(w,\tau)\mid w\in\lbrace0,1\rbrace^\ast,\tau\in T\rbrace\newline<br>\hspace{1cm} \cdot \ E‚Äô&amp;&#x3D;&amp;\lbrace((w,q),(w,\tau))\mid\tau&#x3D;(q,t(w),q^0,q^1),\tau\in T\rbrace\ \cup \newline<br>&amp;&amp;\lbrace((w,\tau),(w,q‚Äô))\mid\tau&#x3D;(q,\sigma,q^0,q^1)\text{ and}\newline<br>&amp;&amp;\hspace{3.65cm}w‚Äô&#x3D;w0\text{ and }q‚Äô&#x3D;q^0\text{ or }w‚Äô&#x3D;w1\text{ and }q‚Äô&#x3D;q^1\rbrace\newline<br>\hspace{1cm} \cdot \ \text{Win}‚Äô &amp;&#x3D;&amp; \lbrace(w[0,0],q(0))(w[0,0],\tau(0))(w[0,1],q(1))(w[0,1],\tau(1))\dots\mid\newline<br>&amp;&amp; \hspace{1cm} q(0)q(1)\dots\in Acc, w(0)w(1)\dots\in\lbrace 0,1\rbrace^\omega,\tau(0)\tau(1)\dots\in T^\omega\rbrace<br>\end{array}$</p></blockquote><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>The following is a part of the acceptance game of automaton $\mathcal{A}$ from the example above:</p><p><img src="/images/notes/uds/agv/12_1_accgame.png"></p><blockquote><p>$\textbf{Theorem 12.1. } \textit{A tree automaton }\mathcal{A}&#x3D;(\Sigma,Q,q_0,T,Acc)\textit{ accepts an input tree }(\mathcal{T},r)\newline\textit{ if and only if Player 0 wins the acceptance game }\mathcal{G}_{\mathcal{A},t}&#x3D;(\mathcal{A}‚Äô,\text{Win}‚Äô)\textit{ from position }(\varepsilon,q_0).$</p></blockquote><h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p><strong>If the input tree is accepted, there is a winning strategy for Player 0</strong></p><p>Given an accepting run $(\mathcal{T},r)$ of $\mathcal{A}$, we construct a memoryless winning strategy $\sigma:V_0‚Äô\rightarrow V‚Äô$ for Player 0:</p><p>$$\sigma(w,q)&#x3D;(w,(r(w),t(w),r(w0),r(w1)))$$</p><p><strong>If there is a winning strategy for Player 0, the input tree is accepted</strong></p><p>Given a winning strategy $\sigma:V‚Äô^\ast V_0‚Äô\rightarrow V‚Äô$, we construct an accepting run $(\mathcal{T},r)$ where $r(\varepsilon)&#x3D;q_0$ and for all $w\in\lbrace 0,1 \rbrace^\ast$</p><p>$$r(w0)&#x3D;q\text{ for }\sigma(\Delta(w))&#x3D;(w,(\rule{0.5em}{0.4pt},\rule{0.5em}{0.4pt},q,\rule{0.5em}{0.4pt}))\ \text{ and }\ r(w1)&#x3D;q\text{ for }\sigma(\Delta(w))&#x3D;(w,(\rule{0.5em}{0.4pt},\rule{0.5em}{0.4pt},\rule{0.5em}{0.4pt}q))$$</p><p>where $\Delta(\varepsilon)&#x3D;(\varepsilon,q_0)\ \text{ and }\ \Delta(wd)&#x3D;\Delta(w)\cdot\sigma(\Delta(w))\cdot(wd,r(wd))\text{ for }d\in\lbrace0,1\rbrace.$</p><hr><p>Next chapter: <a href="../agv12-2/">Emptiness Game</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-6/&quot;&gt;A Remark on Undetermined Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a </summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.6 -- A Remark on Undetermined Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-6/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-6/</id>
    <published>2025-02-15T12:55:54.000Z</published>
    <updated>2025-04-03T07:41:15.437Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv11-5/">Muller Games</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><p>Since we have shown that <a href="../agv11-2/">reachability</a>, <a href="../agv11-3/">B√ºchi</a>, <a href="../agv11-4/">parity</a>, and <a href="../agv11-5/">Muller</a> games are all <strong>determined</strong>, it might seem as if all games were determined. The purpose of this last subsection is to remark that this is not the case. By definition, every play is either won by Player 0 or by Player 1; however, it is entirely possible that neither Player 0 nor Player 1 has a winning strategy.</p><p>We will construct a game with a winning condition that allows the players to <em>steal</em> strategies in the sense that if Player i has a winning strategy œÉ, then Player 1‚àí$i$ has a strategy $\tau$ that mimicks $\sigma$ so that the play resulting from strategies œÉ and œÑ is won by Player 1-$i$: hence, strategy $\sigma$ is not winning after all! </p><p>We fix the alphabet $\mathbb{B}&#x3D;\lbrace 0,1\rbrace$. To define the winning condition, we introduce an <em>infinite</em> $\text{XOR}$ <em>function</em> $f$. An infinite $\text{XOR}$ function is a function $f:\mathbb{B}^\omega\rightarrow\mathbb{B}$ such that $f(\alpha)\neq f(\beta)$ for all Œ±, Œ≤ ‚àà B œâ that have the exact same letter in every position except for exactly one position where they have different letters. </p><p>To see that such a function exists, define an equivalence relation $\sim$ such that $\alpha\sim\beta$ iff there exists a position $n\in\mathbb{N}$ such that $\alpha(i)&#x3D;\beta(i)$ for all $i\geq n$. Let $S\subseteq\mathbb{B}^\omega$ be a set that contains exactly one element from each $\sim$-equivalence class, and let $r(\alpha)$ be the unique $\beta\in S$ such that $\alpha\sim\beta$. For every $\alpha\in\mathbb{B}^\omega$, the two sequences $\alpha$ and $r(\alpha)$ differ only in a finite number of positions. We define $f(\alpha)&#x3D;0$ if this number is even and $f(\alpha)&#x3D;1$ if it is odd. Hence, $f$ is indeed an infinite $\text{XOR}$ function: if two sequences $\alpha,\beta\in\mathbb{B}^\omega$ differ in exactly one position, then $f(\alpha)\neq f(\beta)$. </p><p>We now use the infinite $\text{XOR}$ function $f$ to define the game. We‚Äôll describe the game somewhat informally in terms of rounds executed by the players; it is straightforward to translate this into an explicit arena and winning condition. Our game is played in rounds $n &#x3D; 0, 1, 2,\dots,$ where in round $n$, first Player 0 picks a finite word $w_{2n}\in\mathbb{B}^+$, then Player 1 picks $w_{2n+1}\in\mathbb{B}^+$. The resulting play $\alpha&#x3D;w_0,w_1,w_2,\dots$ is winning for Player $f(\alpha)$.</p><p>We now use the ‚Äústrategy stealing‚Äù argument to show that no player has a winnig strategy in this game. A strategy for Player $i$ is a mapping $\sigma:\cup_{n\in\mathbb{N}}(\mathbb{B}^+)^{2n+i}$, where we denote $(\mathbb{B}^+)^0&#x3D;\varepsilon$.</p><p>As usual, $\sigma$ is a winning strategy for Player $i$ if Player $i$ wins every play that is consistent with $\sigma_i$ . Now fix an arbitrary strategy $\tau$ for Player 1. From $\tau$, we construct two different strategies $\sigma$ and $\sigma‚Äô$ for Player 0. </p><p>For the first round:</p><ul><li><p>$\sigma(\varepsilon)&#x3D;0$</p></li><li><p>$\sigma‚Äô(\varepsilon)&#x3D;1w_1$ where $w_1&#x3D;\tau(0)$</p></li></ul><p>and for all subsequent rounds:</p><ul><li><p>$\sigma(0,w_1,w_2,\dots,w_{2n+1})&#x3D;\tau(1w_1,w_2,\dots,w_{2n+1})$</p></li><li><p>$\sigma‚Äô(1w_1,w_2,\dots,w_{2n+1})&#x3D;\tau(0,w_1,w_2,\dots,w_{2n+1})$</p></li></ul><p>i.e., $\sigma$ continues to mimick $\tau$. Consider now the plays $\alpha$, resulting from playing strategies $\sigma$ and $\tau$, and $\alpha‚Äô$ resulting from playing strategies $\sigma‚Äô$ and $\tau$. By construction, $\alpha&#x3D; 0w_1w_2w_3\dots$ and $\alpha‚Äô&#x3D; 1w_1w_2\dots$ are the same except for the first position, where $\alpha$ has a 0 and $\alpha‚Äô$ has a 1. Hence, we have that $f(\alpha)\neq f(\alpha‚Äô)$: one of the two plays is won by Player 0, the other by Player 1. Hence, $\tau$ cannot be a winning strategy for Player 1! </p><p>The construction of the stealing strategies $\tau$, $\tau‚Äô$ for Player 1 from a given strategy œÉ of Player 0 is analogous. </p><p>For the first round:</p><ul><li><p>$\tau(w_0)&#x3D;0$ for $W_0&#x3D;\sigma(\varepsilon)$</p></li><li><p>$\tau‚Äô(w_0)&#x3D;1w_1$ for $w_1&#x3D;\sigma(0,w_0)$</p></li></ul><p>and for all subsequent rounds:</p><ul><li><p>$\tau(w_0,0,w_2,\dots,w_{2n+1})&#x3D;\sigma(w_0,1w_1,w_2,\dots,w_{2n+1})$</p></li><li><p>$\tau‚Äô(w_0,1w_1,w_2,\dots,w_{2n+1})&#x3D;\sigma(w_0,0,w_1,w_2,\dots,w_{2n+1})$</p></li></ul><p>Again, the resulting plays only differ in exactly one position and are, hence, won by different players. Thus, strategy $\sigma$ cannot be winning for Player 0 either.</p><hr><p>Next chapter: <a href="../agv12-1/">Tree Automata and Acceptance Game</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-5/&quot;&gt;Muller Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cisp</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.5 -- Muller Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-5/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-5/</id>
    <published>2025-02-13T17:01:42.000Z</published>
    <updated>2025-04-03T07:41:15.408Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv11-4/">Parity Games</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><p>Muller games differ from the games we have studied so far in that they are not memoryless determined. Consider, for example, a game arena consisting of three positions $v_0,v_1,v_2$, such that there are edges from $v_0$ and $v_2$ to $v_1$ and from $v_1$ to $v_0$ and $v_2$. Hence, the only choice in the game is in $v_1$, where Player 0 gets to choose between moving to $v_0$ or $v_2$:</p><p><img src="/images/notes/uds/agv/11_5_muller.png"></p><p>The Muller condition $\mathcal{F}&#x3D;\lbrace\lbrace v_0,v_1,v_2\rbrace\rbrace$ is only satisfied if all three positions are visited infinitely often. Player 0 can therefore not win the game with a memoryless strategy, because such a strategy would either visit $v_0$ and $v_1$ infinitely often, or $v_1$ and $v_2$, but not all three positions.  </p><p>There is, however, a memoryful winning strategy: simply alternate between moving from $v_1$ to $v_0$ and to $v_2$.</p><p>In the following, we solve Muller games via a reduction to parity games, i.e., we define a parity game such that we can translate the winning strategy in the parity game into a winning strategy in the Muller game.</p><p>The fact that parity games are memoryless determined and Muller games are not, is not a contradiction: our reduction introduces additional state into the parity game, such that, on the extended state space, there exists a memoryless winning strategy. This augmentation of the state space is known as the <strong>latest appearence record</strong>:</p><h2 id="Latest-Appearence-Record"><a href="#Latest-Appearence-Record" class="headerlink" title="Latest Appearence Record"></a>Latest Appearence Record</h2><blockquote><p>$\textbf{Definition 11.11. } \text{Let }V\text{ be the set of positions of the game arena and let }{$}\text{ be some fresh}\newline\text{symbol. A }\textit{latest appearence record}\text{ over }V\text{ is a finite word over the alphabet }V\cup\lbrace{$}\rbrace\text{ where every}\newline\text{letter from }V\cup\lbrace{$}\rbrace\text{ appears exactly once and whose first letter is from }V\text{ . The }\textit{hit set}\text{ of a latest}\newline\text{appearence record }\ell&#x3D;v_0v_1\dots v_m{$}v_m+1\dots v_n\text{ is defined as }hit(\ell)&#x3D;\lbrace v_0,\dots v_m\rbrace.$</p></blockquote><p>We denote the set of all <strong>latest appearence records</strong> by $\text{LAR}$. Each latest appearence record represents a permutation of $V$ plus a position indicated by ${$}$.</p><p>We will construct the parity game in such a way that whenever the play visits $v_i$, $v_i$ is moved to the beginning of the word, and the ${$}$-symbol is moved to $v_i$‚Äôs previous position. </p><p>In this way, every play will reach a position such that, from then on, the <strong>hit set</strong> (i.e., the set of game positions to the left of ${$}$) is always a subset of the infinity set, and infinitely often equal to the infinity set. The winning condition in the parity game thus only needs to ensure that the infinity set is actually one that satisfies the Muller condition. </p><p>For this purpose, we assign even colors to hit sets (multiply the size of hit sets by 2) that appear in the table of the Muller condition, and odd colors to hit sets (multiply the size of hit sets by 2 then -1) that do not appear in the table. Since the hit set corresponds to subsets of the infinity set, we need to make sure that odd colors that result from strict subsets of entries in the table are ignored.</p><p>We do this by increasing the colors depending on the position of the ${$}$-symbol. In this way, the color of the appearence records corresponding to the full infinity set is more important than the colors of the subsets that appear in-between occurrences of the full infinity set.</p><blockquote><p>$\textbf{Definition 11.4. } \text{Let a Muller game }\mathcal{G}&#x3D;(\mathcal{A},\small\text{MULLER} \normalsize(\mathcal{F}))\text{ with arena }\mathcal{A} &#x3D; (V,V_0,V_1,E)\newline\text{be given. We compute a parity game }\mathcal{G}‚Äô&#x3D;(\mathcal{A}‚Äô,\small\text{PARITY}\normalsize(\mathcal{c}) )\text{ with arena }\mathcal{A}‚Äô &#x3D; (V‚Äô,V_0‚Äô,V_1‚Äô,E‚Äô)\newline\text{ as follows.}$<br>$\begin{array}{l}<br>  \hspace{0.5cm} \cdot \ V‚Äô&#x3D;V\times\text{LAR},V_0‚Äô&#x3D;V_0\times\text{LAR},V_1‚Äô&#x3D;V_1\times\text{LAR} \newline<br>  \hspace{0.5cm} \cdot \ E‚Äô&#x3D;\lbrace((v,v_0v_1\dots v_m{$}v_{m+1}\dots v_n),(v‚Äô,v_0‚Äôv_1‚Äô\dots v_{j-1}{$}v_{j+1}\dots v_{m+1}\dots v_n))\mid(v,v‚Äô)\in E,v‚Äô&#x3D;v_j\rbrace\newline<br>  \hspace{0.5cm} \cdot \ c(v,\ell)&#x3D; \left\lbrace\begin{array}{ll}<br>    2\cdot |hit(\ell)| &amp; \text{if }hit(\ell)\in\mathcal{F}\newline<br>    2\cdot |hit(\ell)|-1 &amp; \text{if }hit(\ell)\notin\mathcal{F}\newline<br>  \end{array}\right. \newline<br>\end{array}$</p></blockquote><p>In order to solve a given Muller game, we solve the constructed parity game. To determine if a player has a winning strategy from some position $v$ of the Muller game, we then simply check if the same player wins from the corresponding position of the parity game.</p><p>In principle, we could use any position of the parity game where $v$ appears in the first component of the position of the parity game. In the following theorem, we arbitrarily fix the position $(v,v_0v_1\dots v_n{$})$.</p><blockquote><p>$\textbf{Theorem 11.4. } \textit{For every Muller game }\mathcal{G}&#x3D;(\mathcal{A},\small\text{MULLER} \normalsize(\mathcal{F}))\textit{ with arena }\mathcal{A} &#x3D; (V,V_0,V_1,E),\newline\textit{there is a parity game }\mathcal{G}‚Äô&#x3D;(\mathcal{A}‚Äô,\small\text{PARITY}\normalsize(\mathcal{c}) )\text{ with arena }\mathcal{A}‚Äô &#x3D; (V‚Äô,V_0‚Äô,V_1‚Äô,E‚Äô)\textit{ where}\newline V‚Äô&#x3D;V\times\text{LAR}\textit{ such that each player has a winning strategy from a position }v\in V\textit{ of the Muller}\newline\textit{game iff the same player has a winning strategy from position }(v,v_0v_1\dots v_n{$})\textit{ of the parity game.}$</p></blockquote><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Consider the following game with winning condition $\small\text{MULLER} \normalsize(\lbrace\lbrace v_0,v_1\rbrace\rbrace)$:</p><p><img src="/images/notes/uds/agv/11_5_example.png"></p><p>We construct the following parity game:</p><p><img src="/images/notes/uds/agv/11_5_parity.png"></p><p>(Shown is only the reachable part of the arena from positions $(v_0, v_0v_1{$})$ and $(v_1, v_0v_1{$})$.) Since Player 0 wins from every position of the parity game, we conclude that the same is true for every position of the Muller game.</p><hr><p>Next chapter: <a href="../agv11-6/">A Remark on Undetermined Games</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-4/&quot;&gt;Parity Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cisp</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.4 -- Parity Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-4/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-4/</id>
    <published>2025-02-13T09:24:29.000Z</published>
    <updated>2025-04-03T07:41:15.438Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv11-3/">B√ºchi Games</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Perhaps the most intriguing type of infinite games are <strong>parity games</strong>. <strong>Parity games</strong> play a key role in verification (in particular for $\mu$-calculus model checking) and synthesis, and finding fast algorithms for parity games is an active research topic. </p><p>The algorithm discussed in the following takes exponential time. There are also several quasi-polynomial-time algorithms for solving parity games (starting with a breakthrough result by Calude, Jain, Khoussainov, Li, and Stephan in 2017). In practice, however, these algorithms do not perform well (yet).</p><h2 id="Parity-Condition"><a href="#Parity-Condition" class="headerlink" title="Parity Condition"></a>Parity Condition</h2><blockquote><p>$\textbf{Definition 11.10. }\text{The }\textit{parity condition }\small\text{PARITY} \normalsize(C)\text{ for a coloring function }c:V\rightarrow\mathbb{N}\text{ is the set}$<br>$$\small\text{PARITY} \normalsize(C)&#x3D;\lbrace\alpha\in V^\omega\mid\text{max}\lbrace c(q)\mid q\in\text{Inf}(\alpha)\rbrace\text{is even}\rbrace.$$</p></blockquote><p>The parity condition is satisfied if the biggest number $q$ of the coloring function is even, among all positions that are visited infinitely often.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/11_4_parity.png"></p><ul><li><p>The winning region for Player 0: $W_0(\mathcal{G})&#x3D;\lbrace v_3,v_6,v_7\rbrace$</p><ul><li>Strategy: $\sigma(v_3) &#x3D; v_6, \sigma(v_7) &#x3D; v_4, \sigma(v_7) &#x3D; v_6$ ($v_8$ have no choices and $v_1$ is arbitrary)</li></ul></li><li><p>The winning region for Player 1: $W_1(\mathcal{G})&#x3D;\lbrace v_0,v_1,v_2,v_4,v_5,v_8\rbrace$</p><ul><li>Strategy: $\tau(v_0) &#x3D; v_1, \tau(v_2) &#x3D; v_5, \tau(v_4) &#x3D; v_0, \tau(v_5) &#x3D; v_1$</li></ul></li></ul><p>We first prove that parity games are memoryless determined, then derive an algorithm for solving parity games. In the following theorem, we emphasize that determinacy holds also for (countably) infinite game arenas. </p><p>This will be helpful when we use the determinacy to complement tree automata, because the acceptance game of a tree automaton refers to the infinite input tree and is therefore infinite.</p><blockquote><p>$\textbf{Theorem 11.3. } \textit{Parity games are memoryless determined with uniform winning strategies}\newline\textit{for game arenas with a countable set of positions and a finite number of colors.}$</p></blockquote><p>Here, we try to construct a uniform winning strategy for an arbitrary parity game.</p><h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>Let $k&#x3D;\text{max}\lbrace c(v)\mid v\in V\rbrace$ be the highest color in the given parity game. We prove that parity games are memoryless determined by induction on $k$.</p><p><strong>Case</strong> $k&#x3D;0$: If the highest color is 0, then all plays are winning. $W_0(\mathcal{G})&#x3D;V, W_1(\mathcal{G})&#x3D;\varnothing$. For the memoryless winning strategy $\sigma$, we fix an arbitrary total order on $V$ and choose $\sigma(v)&#x3D;\text{min}\lbrace v‚Äô\in V\mid(v,v‚Äô)\in E\rbrace$.</p><p><strong>Case</strong> $k&gt;0$: If $k$ is even, consider Player $i$, otherwise Player (1-$i$). Let $W_{i-1}$ be the set of positions where Player (1-$i$) has a memoryless winning strategy. We show that Player $i$ has a memoryless winning strategy $\sigma$ from $V\setminus W_{1‚àíi}$ . Consider the subgame $\mathcal{G‚Äô}$:</p><ul><li>$V_0‚Äô &#x3D; V_0\setminus W_{1-i},V_i‚Äô&#x3D;V_1\setminus W_{1-i}, V‚Äô&#x3D;V_0‚Äô\cup V_1‚Äô$</li><li>$E‚Äô&#x3D;E\cap(V‚Äô\times V‚Äô)$</li><li>$c‚Äô(v)&#x3D;c(v)\text{ for all }v\in V‚Äô$</li></ul><p>Note that $\mathcal{G‚Äô}$ is still a game:</p><ul><li>for $v\in V_i‚Äô$, there is a $v\in V\setminus W_{1-i}$ with $(v,v‚Äô)\in E‚Äô$, otherwise $v$ would be in $W_{1-i}$</li><li>for $v\in V_{1-i}‚Äô$, for all $v‚Äô\in V$ with $(v,v‚Äô)\in E‚Äô$, $v‚Äô\in V\setminus W_{1-i}$, hence there is a $v‚Äô\in V‚Äô$ with $(v,v‚Äô)\in E$.</li></ul><p>Let $c‚Äô^{‚àí1}(k)&#x3D;\lbrace v\in V‚Äô\mid c‚Äô(v)&#x3D;k\rbrace$ (set of highest color positions in $V‚Äô$), and<br>Let $Y&#x3D;Attr_i‚Äô(c‚Äô^{-1}(k))$. (attractor here means the set of positions that at least visit $c‚Äô^{-1}(k)$ once)<br>Let $\sigma_A$ be the corresponding attractor strategy on $\mathcal{G‚Äô}$ into $c‚Äô^{-1}(k)$, as defined in the proof of <a href="../agv11-2/">Theorem 11.1</a>.</p><p>Now consider the subgame $\mathcal{G‚Äô‚Äô}$:</p><ul><li>$V_0‚Äô‚Äô &#x3D; V_0‚Äô\setminus Y,V_i‚Äô‚Äô&#x3D;V_1‚Äô\setminus Y, V‚Äô‚Äô&#x3D;V_0‚Äô‚Äô\cup V_1‚Äô‚Äô$</li><li>$E‚Äô‚Äô&#x3D;E‚Äô\cap(V‚Äô‚Äô\times V‚Äô‚Äô)$</li><li>$c‚Äô‚Äô:V‚Äô‚Äô\rightarrow\lbrace 0,\dots,k-1\rbrace;c‚Äô‚Äô(v)&#x3D;c‚Äô(v)\text{ for all }v\in V‚Äô‚Äô$</li></ul><p>Note that $\mathcal{G‚Äô‚Äô}$ is still a game, and that the maximal color in $\mathcal{G‚Äô‚Äô}$ is at most $k‚àí1$ (we removed position that color as $k$ and positions that can visit it by Player $i$). By induction hypothesis, that $\mathcal{G‚Äô‚Äô}$ is memoryless determined. </p><p>It is also clear that $W_{1-i}‚Äô‚Äô$, the set of positions in game $\mathcal{G‚Äô‚Äô}$ where Player (1‚àí$i$) has a memoryless winning strategy, is empty, because $W_{1-i}‚Äô‚Äô$ is a subset of $W_{1-i}$: </p><p>assume Player (1‚àí$i$) had a memoryless winning strategy from some position in $V‚Äô‚Äô$. Then this strategy would win in $\mathcal{G}$, too, since Player $i$ has no opportunity to leave $\mathcal{G‚Äô‚Äô}$ other than to $W_{1-i}$. </p><p>Hence, there is a uniform winning memoryless winning strategy $\sigma_{IH}$ for player $i$ from all positions in $V‚Äô‚Äô$. We define the following uniform strategy $\sigma$ for Player $i$ in game $\mathcal{G}$:</p><p>$$\sigma(v)&#x3D;\left\lbrace\begin{array}{ll}<br>\sigma_{IH}(v)&amp;\text{if }\ v\in V‚Äô‚Äô\newline<br>\sigma_{A}(v)&amp;\text{if }\ v\in V\setminus c‚Äô^{-1}(k)\newline<br>\text{min. successor in }V\setminus W_{1-i}&amp;\text{if }\ v\in V\cap c‚Äô^{-1}(k)\newline<br>\text{min. successor in }V&amp;\text{otherwise.}\newline<br>\end{array}\right.<br>$$</p><p>The strategy $\sigma$ is winning for Player 0 on $V\setminus W_{1‚àí\sigma}$. Consider a play that is consistent with $\sigma$, it can be either:</p><ol><li><p>$Y$ (Set of positions that Player 0 can visit the highest color $k$) is visited infinitely often. Thus, Player $i$ wins.</p></li><li><p>Eventually only positions in $V‚Äô‚Äô$ are visited. Hence, since Player $i$ follows $\sigma_{IH}$, Player $i$ wins.</p></li></ol><h2 id="Construct-W-1‚àíi-with-McNaughton‚Äôs-algorithm"><a href="#Construct-W-1‚àíi-with-McNaughton‚Äôs-algorithm" class="headerlink" title="Construct $W_{1‚àíi}$ with McNaughton‚Äôs algorithm"></a>Construct $W_{1‚àíi}$ with McNaughton‚Äôs algorithm</h2><p>The proof above is non-constructive in the sense that we begin the argument by considering (rather than computing) the set $W_{1‚àíi}$ of positions where the opponent, Player (1‚àí$i$), has a memoryless winning strategy. McNaughton‚Äôs algorithm, one of the classic algorithms for parity games over finite arenas, computes this set iteratively, with repeated recursive calls:</p><blockquote><p>$\textbf{Construction 11.3. } \text{Let a finite parity game }\mathcal{G} &#x3D; (\mathcal{A},\small\text{PARITY} \normalsize(C))\text{ be given. We compute the}\newline\text{winning regions }W_0(\mathcal{G})\text{ and }W_1(\mathcal{G})\text{ as follows. (To avoid confusion we indicate in each attractor}\newline\text{construction explicitly the game it refers to.)}$<br>$\newline<br>\text{Function }\textit{McNaughton}(\mathcal{G})&#x3D;\newline<br>\begin{array}{ll}<br>  \hspace{1cm} 1. &amp; k:&#x3D;\text{ highest color in }\mathcal{G}\newline<br>  \hspace{1cm} 2. &amp; \textbf{if }k&#x3D;0\text{ or }V&#x3D;\varnothing\newline<br>  &amp;\textbf{then return }(V,\varnothing)\newline<br>  \hspace{1cm} 3. &amp; i:&#x3D;k\text{ mod }2\newline<br>  \hspace{1cm} 4. &amp; W_{1-i}:&#x3D;\varnothing\newline<br>  \hspace{1cm} 5. &amp; \textbf{repeat}\newline<br>  &amp;\begin{array}{ll}<br>    \hspace{0.5cm} (a) &amp; \mathcal{G}‚Äô:&#x3D;\mathcal{G}\setminus Attr^i(c^{-1}(k),\mathcal{G})\newline<br>    \hspace{0.5cm} (b) &amp; (W_0‚Äô,W_1‚Äô):&#x3D;\textit{McNaughton}(\mathcal{G}‚Äô)\newline<br>    \hspace{0.5cm} (c) &amp; \textbf{if }(W_{1-i}‚Äô&#x3D;\varnothing)\textbf{ then}\newline<br>    &amp;\begin{array}{rl}<br>      \ \text{i.}  &amp; W_i:&#x3D;V\setminus W_{1-i}\newline<br>      \ \text{ii.} &amp; \textbf{return }(W_0,W_1)\newline<br>    \end{array}\newline<br>    \hspace{0.5cm} (d) &amp; W_{1-i}:&#x3D;W_{1-i}\cup Attr^{1-i}(W_{1-i}‚Äô,\mathcal{G})\newline<br>    \hspace{0.5cm} (e) &amp; \mathcal{G}‚Äô:&#x3D;\mathcal{G}\setminus Attr^{1-i}(c^{-1}(W_{1-i}‚Äô,\mathcal{G})\newline<br>  \end{array}<br>\end{array}$</p></blockquote><h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p><strong>(Line 1):</strong> The construction begins by determining the highest color $k$ that appears in the arena. </p><p><strong>(Line 2):</strong> If this color is 0 (or the arena is empty), then Player 0 wins the game from all positions, function ends.</p><p><strong>(Line 3):</strong> Otherwise we continue by analyzing the game from the perspective of Player $i &#x3D; 0$ if $k$ is even and from the perspective of Player $i &#x3D; 1$ if $k$ is odd. </p><p><strong>(Line 4):</strong> We initialize the winning region for the opponent to $\varnothing$ and repeat the following: </p><p><strong>(Line 5a):</strong> First, we eliminate all positions where Player $i$ can enforce a visit to the highest color $k$ (which, if visited infinitely often, is beneficial for Player $i$). </p><p><strong>(Line 5b):</strong> We recursively solve the resulting subgame $\mathcal{G}‚Äô$. </p><p><strong>(line 5c):</strong> If the oppoent does not have any winning positions in the subgame, then we are done: </p><ul><li><p>If the play of $\mathcal{G}$ stays in the subgame, then Player $i$ wins with the winning strategy of the subgame.</p></li><li><p>If the play leaves the subgame, then Player $i$ can enforce a visit to the highest color.</p></li></ul><p>So either the play eventually stays in the subgame forever, and Player $i$ wins there, or it infinitely often leaves the subgame, and Player $i$ wins by visiting the highest color infinitely often. </p><p><strong>(line 5d):</strong> If the opponent wins from some non-empty winning region $W_{1‚àíi}‚Äô$ of the subgame, then we add the opponent‚Äôs attractor of $W_{1‚àíi}‚Äô$ to the winning region of $\mathcal{G}$.</p><ul><li><p>The opponent is sure to win from every position in the attractor by first ensuring a visit to $W_{1‚àíi}‚Äô$ and then staying there forever applying its winning strategy inside $\mathcal{G}‚Äô$.</p></li><li><p>Player $i$ cannot force the game out of the subgame, because $\mathcal{G}‚Äô$ was constructed by removing Player $i$‚Äôs attractor from $\mathcal{G}$.</p></li></ul><p><strong>(line 5e):</strong> We remove the entire attractor from $\mathcal{G}$ (line 5e) and continue with the resulting subgame.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>Consider again the example above. </p><p><strong>(line 1):</strong> The highest color is $k&#x3D;4$,<br><strong>(line 3):</strong> k is even, hence $i&#x3D;0$.<br><strong>(line 5a):</strong> We have that $c^{-1}(4)&#x3D;\lbrace v_4, v_8\rbrace$ and $Attr^0(c^{-1}(4))&#x3D;Attr^0(\lbrace v_4,v_8\rbrace)&#x3D;\lbrace v_3,v_4,v_6,v_7,v_8\rbrace$. Hence, $\mathcal{G}‚Äô$ is the subgame consisting of positions $v_0$, $v_1$, $v_2$, and $v_5$:</p><p><img src="/images/notes/uds/agv/11_4_eg1.png"></p><p><strong>(line 5b):</strong> The recursive call returns $W_0‚Äô&#x3D;\varnothing, W_1‚Äô&#x3D;\lbrace v_0,v_1,v_2,v_5\rbrace$. (We skip over the evaluation of the recursive call here, note that Player 1 wins from every position with a strategy that moves from $v_2$ to $v_5$.)<br><strong>(line 5d):</strong> We have that $Attr^1(\lbrace v_0,v_1,v_2,v_5\rbrace)&#x3D;\lbrace v_0,v_1,v_2,v_4,v_5,v_8\rbrace$. Hence, $W_1$ is set to $\lbrace v_0,v_1,v_2,v_4,v_5,v_8\rbrace$,<br><strong>(line 5e):</strong> And $\mathcal{G}$ is reduced to the subgame consisting of positions $v_3$, $v_6$ and $v_7$:</p><p><img src="/images/notes/uds/agv/11_4_eg2.png"></p><p><strong>(line 5b):</strong> Now, the game does not contain any positions with color 4 anymore, we therefore call the algorithm recursively. It returns $W_0‚Äô&#x3D;\lbrace v_3,v_6,v_7\rbrace, W_1‚Äô&#x3D;\varnothing$. (We again skip over the evaluation of the recursive call, note that all plays are winning for Player 0.)<br><strong>(line 5ci):</strong> Since $W_1‚Äô&#x3D;\varnothing$, we set $W_0$ to $V\setminus W_1$,<br><strong>(line 5cii):</strong> Return the final result $W_0&#x3D;\lbrace v_3,v_6,v_7\rbrace$, $W_1&#x3D;\lbrace v_0,v_1,v_2,v_4,v_5,v_8\rbrace$.</p><hr><p>Next chapter: <a href="../agv8811-5/">Muller Games</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-3/&quot;&gt;B√ºchi Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.3 -- B√ºchi Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-3/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-3/</id>
    <published>2025-02-12T23:27:50.000Z</published>
    <updated>2025-04-03T07:41:15.408Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv11-2/">Reachability Games</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Recurrence-Construction"><a href="#Recurrence-Construction" class="headerlink" title="Recurrence Construction"></a>Recurrence Construction</h2><p>In a B√ºchi game, the goal of Player 0 is to visit some accepting position <strong>infinitely often</strong>. The attractor construction checks whether there is a strategy which enforces at least one visit to an accepting position. Reaching an accepting state at least once is indeed a necessary precondition, but we also have to ensure that from this position we can enforce a second visit to some accepting state, then a third, and so forth.</p><p>The <strong>recurrence construction</strong> computes the largest subset of the accepting states from which Player 0 can enforce infinitely many subsequent visits to the subset.</p><blockquote><p>$\textbf{Construction 11.2. } \text{Let an arena }\mathcal{A} &#x3D; (V_0,V_1,E)\text{ with }V&#x3D;V_0\cup V_1\text{ be given. The }\newline\textit{recurrence construction}\text{ on }\mathcal{A}\text{ is defined for all }n\in\mathbb{N}\text{ and }F\subseteq V\text{ as:}$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ W_n^1(F) &amp;&#x3D;&amp; V\setminus Attr^0(Recur_n(F))\newline<br>\hspace{1cm} \cdot \ Recur_{0}(F)&amp;&#x3D;&amp;F \newline<br>\hspace{1cm} \cdot \ Recur_{n+1}(F)&amp;&#x3D;&amp;Recur_{n}(F)\setminus CPre^{1}(W_n^1(F)) \newline<br>\hspace{1cm} \cdot \ Recur(F)&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcap} Recur_{n}(R)\newline<br>\end{array}$</p></blockquote><p>The set $W_n^1(F)$ contains those positions in $V$ from which Player 1 can enforce that at most $n$ visits to $F$.</p><p>The set $CPre^{1}(W_n^1(F))$ adds those positions in $V$ from which move to positions in $W_n^1(F)$, meaning that there are at most $n+1$ visits to $F$ in newly added positions.</p><p>The set $Recur_{n}(F)$ contains the subset of $F$ from which Player 0 can enforce at least $n$ <em>further</em> (i.e., a total of at least $n+1$) visits to $F$.</p><p>The set $Recur(F)$ contains the subset of $F$ from which Player 0 can enforce infinitely many visits to $F$. The recurrence construction solves a game with winning condition $\small\text{B√úCHI} \normalsize (F)$ as follows:</p><blockquote><p>$$<br>W_0(\mathcal{G})&#x3D;Attr^0(Recur(F)),\ W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})<br>$$</p></blockquote><p>$$<br>\text{Position of Player 0: Circles;}\ \ \text{Positions of Player 1: rectangles.}$$ </p><p><img src="/images/notes/uds/agv/11_3_recur1.png"></p><p><img src="/images/notes/uds/agv/11_3_recur2.png"></p><p><img src="/images/notes/uds/agv/11_3_recur3.png"></p><blockquote><p>$\textbf{Theorem 11.2. } \textit{B√ºchi games are memoryless determined. It holds that}\newline W_0(\mathcal{G})&#x3D;Attr^0(Recur(F)), W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})\textit{. Both players have a uniform winning strategy.}$</p></blockquote><h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We show for all positions $v\in V$ that</p><p>If $v\in Attr^0(Recur(F))$, then $v\in W_0(\mathcal{G})$, with the following uniform memoryless strategy $\sigma$:</p><ul><li><p>We fix some arbitrary total ordering on $V$. For $v\in (Attr^0(Recur(F))\setminus Recur(F))\cap V_0$, we follow the attractor strategy from the proof of <a href="../agv11-2/">Theorem 11.1</a>. </p></li><li><p>For $v\in Recur(F)\cap V_0$, we choose the smallest $v‚Äô\in V$ with $(v,v‚Äô)\in E$ and $v‚Äô\in Attr^0(Recur(F))$. Such a successor must exist, because otherwise $v\in CPre^{1}(W_n^1(F))$ for some $n\in\mathbb{N}$, and hence $v\notin Recur(F)$.</p></li><li><p>Every play that is consistent with $\sigma$ visits $Recur(F)\subseteq F$ infinitely often. Hence, $\sigma$ is winning for Player 0.</p></li></ul><p>If $v\in V\setminus Attr^0(Recur (F))$, then $v\in W_1(\mathcal{G})$, with the following uniform memoryless strategy $\tau$:</p><ul><li><p>We again fix an arbitrary total ordering on $V$. We define the memoryless strategies $\tau$ such taht, for $n\in\mathbb{N}$, if a play starts in $v\in W_n^1&#x3D;V\setminus Attr^0(Recur_n(F))$ and is consistent with $\tau$, there are at most $n$ visits to $F$.</p><ul><li><p>For $n&#x3D;0$ let $\tau(v)$ be the smallest $v‚Äô\in V$ such that $(v,v‚Äô)\in E$ and $v‚Äô\in V\setminus Attr^0(F)$. </p></li><li><p>For $n&gt;0$ let $\tau(v)$ be the smallest $v‚Äô\in W_{n-1}^1(F)$ with $(v,v‚Äô)\in E$ if $v\in CPre^1(W_{n-1}^1(F))$, otherwise be the smallest $v‚Äô$ in $W_{n}^1(F)$ with $(v,v‚Äô)\in E$. Such a $v‚Äô$ always exists as otherwise $v\in Attr^0(Recur (F))$.</p></li></ul></li></ul><h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p><strong>Strategy for Player 0</strong></p><ul><li><p>If a position $v$ belongs to $(Attr^0(Recur(F))\setminus Recur(F))\cap V_0$, it must have edges to $Recur(F)$, then choose the smallest $v‚Äô$ among those.</p></li><li><p>If a position $v$ belongs to $Recur(F)\cap V_0$, we need to ensure it will visit $F$ again, so we need to choose an edge that belongs to $Attr^0(Recur(F))$.</p></li></ul><p><strong>Strategy for Player 1</strong></p><ul><li><p>Every position from Player 1 must belong to $W_n^1$, that ensures that only at most n times visits to $F$, otherwise Player 1 has no choice (belongs to $Attr^0(F)$)</p></li><li><p>For such $n &#x3D; 0$, we can ensure it never visit $F$ by choosing smallest $v‚Äô$ that does not move to $Attr^0(F)$.</p></li><li><p>For such $n &gt; 0$, if $v$ belongs to $W_{n-1}^1$, then it must have edge(s) that also belongs to $W_{n-1}^1$, otherwise there exist edge(s) belongs to $W_{n}^1$, so that it can stays in winning region of Player 1 without visiting $Attr^0(F)$.</p></li></ul><hr><p>Next chapter: <a href="../agv11-4/">Parity Games</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-2/&quot;&gt;Reachability Games&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.2 -- Reachability Games</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-2/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-2/</id>
    <published>2025-02-11T19:48:34.000Z</published>
    <updated>2025-04-03T07:41:15.439Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv11-1/">Infinite Games (Basic Definitions)</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Reachability-Condition"><a href="#Reachability-Condition" class="headerlink" title="Reachability Condition"></a>Reachability Condition</h2><p>We will now analyze infinite games for various types of winning conditions. We start with the simple <strong>reachability</strong> condition.</p><p>The reachability condition is given as a set $R$ of positions called the reachability set. The reachability condition is satisfied if the play reaches some position in $R$. Formally, for an infinite word $\alpha$ over $\Sigma$, we use $\text{Occ}(\alpha) :&#x3D; \lbrace\sigma\in\Sigma\mid\exists n\in\mathbb{N}.\ \alpha(n)&#x3D;\sigma\rbrace$ to denote the set of all letters occurring in $\alpha$.</p><blockquote><p>$\textbf{Definition 11.11. } \text{The }\textit{reachability condition }\small\text{REACH} \normalsize(R)\text{ on a set of positions }R\subseteq V\text{ is the set}$</p><p>$$<br>\small\text{REACH} \normalsize(R) &#x3D; \lbrace\rho\in V^\omega\mid\text{Occ}(\rho)\cap R\neq\varnothing\rbrace\newline\newline\text{A game }\mathcal{G}&#x3D;(\mathcal{A},\text{Win})\text{ with Win}&#x3D;\small\text{REACH} \normalsize(R)\text{ is called a }\textit{reachability game}\text{ with reachability set }R<br>$$</p></blockquote><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>$$<br>\text{Position of Player 0: Circles;}\ \ \text{Positions of Player 1: rectangles.}$$ </p><p><img src="/images/notes/uds/agv/11_2_reachability.png"></p><p>$$\mathcal{G}&#x3D;(\mathcal{A},\small\text{REACH} \normalsize(R)),\ R&#x3D;\lbrace v_4,v_5\rbrace<br>$$</p><ul><li>The winning region for Player 0: $W_0(\mathcal{G})&#x3D;\lbrace v_3,v_4,v_5,v_6,v_7,v_8\rbrace$<ul><li>Strategy: $\sigma(v_1) &#x3D; v_2, \sigma(v_3) &#x3D; v_4, \sigma(v_7) &#x3D; v_8, \sigma(v_8) &#x3D; v_5$</li></ul></li></ul><h2 id="Attractor-Construction"><a href="#Attractor-Construction" class="headerlink" title="Attractor Construction"></a>Attractor Construction</h2><p>Reachability games can be solved with a simple fixed point construction called the <strong>attractor construction</strong>.</p><p>The attractor construction computes the winning region for Player 0 iteratively by the <strong>reachability set</strong>:</p><ol><li>adds all positions owned by Player 0 that <strong>have an edge</strong> into the winning region,</li><li>then adds all positions owned by Player 1 where <strong>all edges</strong> lead into the winning region. (no choices)</li><li>Repeats until no more positions can be added.</li></ol><p>In the following, we give a slightly more general definition of the attractor construction that can be applied also to Player 1. We do this in preparation for the constructions for other winning conditions, which will use the attractor construction as a subroutine.</p><blockquote><p>$\textbf{Construction 11.1. } \text{Let an arena }\mathcal{A} &#x3D; (V,V_0,V_1,E)\text{ be given. The }\textit{attractor construction}\text{ on}\newline\mathcal{A}\text{ is defined for each Player }i\text{, for all }n\in\mathbb{N}\text{ and }R\subseteq V\text{ as follows.}$<br>$\begin{array}{lll}<br>\hspace{1cm} \cdot \ CPre^{i}(R) &amp;&#x3D;&amp; \lbrace v\in V_i\mid\exists v‚Äô\in V.(v, v‚Äô)\in E\wedge v‚Äô\in R\rbrace\cup\ \newline<br>&amp;&amp;\lbrace v\in V_{1-i}\mid\forall v‚Äô\in V.(v, v‚Äô)\in E\rightarrow v‚Äô\in R\rbrace\newline<br>\hspace{1cm} \cdot \ Attr_{0}^{i}(R)&amp;&#x3D;&amp;R \newline<br>\hspace{1cm} \cdot \ Attr_{n+1}^{i}(R)&amp;&#x3D;&amp;Attr_{n}^{i}(R)\cup CPre^{i}(Attr_{n}^{i}(R)) \newline<br>\hspace{1cm} \cdot \ Attr^{i}(R)&amp;&#x3D;&amp;\underset{n\in\mathbb{N}}{\bigcup} Attr_{n}^{i}(R)\newline<br>\end{array}$</p></blockquote><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/11_2_attractor.png"></p><p>In general, the attractor construction solves a game with winning condition $\small\text{REACH} \normalsize(R)$ as follows: $W_0(\mathcal{G})&#x3D;Attr^0(R), W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})$. We can furthermore give a uniform memoryless winning strategy. These results are summarized in the following theorem.</p><blockquote><p>$\textbf{Theorem 11.1. } \textit{Reachability games are memoryless determined. It holds that}\newline W_0(\mathcal{G})&#x3D;Attr^0(R), W_1(\mathcal{G})&#x3D;V\setminus W_0(\mathcal{G})\textit{. Both players have a uniform winning strategy.}$</p></blockquote><h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>We show for all positions $v\in V$ that</p><p>If $v\in Attr^0(R)$, then $v\in W_0(\mathcal{G})$, with the following uniform memoryless strategy $\sigma$:</p><ul><li>We fix an arbitrary total ordering on $V$ . For $v\in (Attr^0(R)\setminus R)\cap V_0$, let $n &#x3D; min\lbrace n\in\mathbb{N}\mid v\in Attr_{n}^0(R)\rbrace$. Then, let $\sigma(v)$ be the smallest $v‚Äô\in Attr_{n-1}^0(R)$ with $(v, v‚Ä≤)\in E$</li><li>For every other position $v\in V_0\setminus(Attr^0(R)\setminus R)$, let $\sigma(v)$ be the smallest $v‚Äô\in V$ with $(v, v‚Ä≤)\in E$</li><li>We show, by induction on $n\in\mathbb{N}$, that any play that starts in $v\in Attr_{n}^0(R)$<br>and is consistent with $\sigma$ reaches $R$ within at most $n$ steps.</li></ul><p>If $v\in V\setminus Attr^0(R)$, then $v\in W_1(\mathcal{G})$, with the following uniform memoryless strategy $\tau$:</p><ul><li>We again fix an arbitrary total ordering on $V$. For $v\in V_1\setminus Attr^0(R)$, let $\tau(v)$ be the smallest $v‚Äô\in V\setminus Attr^0(R)$ such that $(v, v‚Ä≤)\in E$. Such a successor $v‚Äô$ always exists, because otherwise $v\in Attr^0(R)$.</li><li>For every other position $v\in V_1\cap Attr^0(R)$ let $\tau(v)$ be the smallest $v‚Äô\in V\setminus Attr^0(R)$ with $(v, v‚Ä≤)\in E$. Now let $\rho$ be an arbitrary play that is consistent with $\tau$.</li><li>We show, by induction on $n$, that $\rho(n)\notin Attr^0(R)$ and, hence, $\rho(n)\notin R$, for all $n\in\mathbb{N}$.</li></ul><h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p><strong>Strategy for Player 0</strong></p><ul><li>A position $v$ belongs to $Attr_{n}^0(R)\setminus R$, must have edges to $v‚Äô\in Attr_{n-1}^0(R)$, then choose the smallest $v‚Äô$</li><li>If a position $v$ does not belong to $Attr^0(R)\setminus R$, simply choose the smallest $v‚Äô$ from its edges.</li></ul><p><strong>Strategy for Player 1</strong></p><ul><li>If a position $v$ does not belong to $Attr_{n}^0(R)$, it must have any one edge does not move to $Attr^0(R)$, choose the smallest $v‚Äô$ among those.</li><li>If a position $v$ belongs to $Attr_{n}^0(R)$, since all its edges move to some positions in $Attr_{n}^0(R)$, simply choose the smallest $v‚Äô$ from its edges.</li></ul><hr><p>Next chapter: <a href="../agv11-3/">B√ºchi Games</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv11-1/&quot;&gt;Infinite Games (Basic Definitions)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 11.1 -- Infinite Games (Basic Definitions)</title>
    <link href="https://greenmeeple.github.io/AGV/agv11-1/"/>
    <id>https://greenmeeple.github.io/AGV/agv11-1/</id>
    <published>2025-02-11T16:11:48.000Z</published>
    <updated>2025-04-03T07:41:15.408Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv10-5/">From semi-deterministic B√ºchi to deterministic Muller</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now introduce <em>infinite two-player games on finite graphs</em>. Infinite games are useful to solve the synthesis problem, where we are interested in finding a strategy that guarantees that a given specification is satisfied (cf. <a href="../agv1.2/">Section 1.2</a>). As we will see, games also play a fundamental role in automata theory, in particular for automata over infinite trees.</p><h2 id="Basic-Definitions"><a href="#Basic-Definitions" class="headerlink" title="Basic Definitions"></a>Basic Definitions</h2><p>The game is played on a graph, called the <strong>arena</strong>. The vertices of the graph are called <strong>positions</strong> and are partitioned into the positions of Player 0 and the positions of Player 1. </p><ul><li>A play of the game starts in some initial position</li><li>In any positions, the player who <strong>owns the position chooses the edge</strong> on which the play is continued.</li><li>Player 0 wins if the play is an element of the <strong>winning condition</strong>.</li></ul><p>The winner is determined by a winning condition, which, like the acceptance condition of an automaton on infinite words is a subset of the infinite words over the positions. </p><blockquote><p>$\textbf{Definition 11.1. } \text{A }\textit{game arena}\text{ is a tuple }\mathcal{A} &#x3D; (V,V_0,V_1,E)\text{, where}\newline\begin{array}{l}<br>\hspace{0.5cm} \cdot \ V_0\text{ and }V_1&#x3D;V\setminus V_0\text{ are disjoint sets of positions,}\newline<br>\hspace{1cm} \text{called the positions of Player 0 and Player 1.}\newline<br>\hspace{0.5cm} \cdot \ E\subseteq V\times V\text{ is a set of edges such that every position }v\in V\newline<br>\hspace{1cm} \text{has at least one outgoing edge }(v,v‚Äô)\in E.\newline<br>\end{array}$</p></blockquote><blockquote><p>$\textbf{Definition 11.2. } \text{A }\textit{play}\text{ is an infinite sequence }  \rho\in V^\omega\text{ such that}$<br>$$\forall n\in\mathbb{N}.(\rho(n),\rho(n+1))\in E$$</p></blockquote><p>We say a play $\rho$ starts in a position $v$ iff $v&#x3D;\rho(0)$. We denote the set of all possible plays on $\mathcal{A}$ with $\text{Plays}(\mathcal{A})$ and the set of all possible plays starting in position $v$ with $\text{Plays}(\mathcal{A},v)$.</p><blockquote><p>$\textbf{Definition 11.3. }\text{A }\textit{game }\mathcal{G}&#x3D;(\mathcal{A},\text{Win})\text{ consists of an arena }\mathcal{A}\text{ and a }\textit{winning condition}\newline\text{Win}\subseteq V^\omega\text{. We call a play }\rho\textit{ winning for Player 0}\text{ iif }\rho\in\text{Win and }\textit{winning for Player 1}\text{ otherwise.}$ </p></blockquote><p>When it is Player $i$‚Äôs turn, the current vertex must be a <strong>position</strong> of Player $i$ ($V_i$), all the prefix of the play seen so far (including current vertex) is called the <strong>history</strong> of the <strong>play</strong>, which is an element of $V^\ast V_i$.</p><p>A <strong>strategy</strong> fixes the decisions of a player based on the <strong>history</strong> of the play. A <strong>strategy</strong> for Player $i$ is a function $\sigma:V^\ast V_i\rightarrow V$ that selects for each such history a successor position.</p><blockquote><p>$\textbf{Definition 11.4. }\text{A }\textit{strategy}\text{ for Player }i\text{ is a function }\sigma:V^\ast V_i\rightarrow V\text{ such that }(v,v‚Äô)\in E\newline\text{whenever }\sigma(wv)&#x3D;v‚Äô\text{ for some }w\in V^\ast,v\in V_i$ </p></blockquote><p>In the following, we use $\sigma$ and $\tau$ to denote strategies for Player $i$ and the opponent Player $(1‚àíi)$, respectively.</p><blockquote><p>$\textbf{Definition 11.5. }\text{A play }\rho\text{ is }\textit{consistent}\text{ with a strategy }\sigma\text{ iff}$<br>$$\forall n\in\mathbb{N}.\text{if }\rho(n)\in V_i\text{ then }\rho(n+1)&#x3D;\sigma(\rho[n])$$</p></blockquote><p>We denote the set of all plays that begin in some position $v$ and are consistent with strategy $\sigma$ with $\text{Plays}(\mathcal{A}, \sigma, v)$. Note that the strategies $\sigma$ and $\tau$ of the two players together uniquely identify a specific play: $\mid \text{Plays}(\mathcal{A}, \sigma, v)\cap \text{Plays}(\mathcal{A}, \tau, v)\mid &#x3D; 1$. </p><p>Our definition of a strategy is very general in the sense that the decisions are based on the entire history of the play. Intuitively, this means that the players have infinite memory. It often suffices to work with simpler strategies, such as <strong>memoryless</strong> strategies. <strong>Memoryless</strong> strategies are often also called <strong>positional</strong>.</p><blockquote><p>$\textbf{Definition 11.6. }\text{A strategy }\sigma\text{ for Player }i\text{ is }\textit{memoryless}\text{ iff }\sigma(wv)&#x3D;\sigma(v)\text{ for all }w\in V^\ast,v\in V_i.$</p></blockquote><p>In a slight abuse of notation, memoryless strategies are often given directly as a function $\sigma:V_i\rightarrow V$ that maps the positions owned by Player $i$ to their successor positions. Next, we characterize <strong>winning</strong> strategies:</p><blockquote><p>$\textbf{Definition 11.7. }\text{A strategy }\sigma\text{ for Player }i\text{ is }\textit{winning}\text{ from a position }v\text{ if all plays that}\newline\text{start in }v\text{ and that are consistent with }\sigma\text{ are winning for Player }i.$</p></blockquote><p>Note that this definition refers to a specific position $v$ in which we start the play. The set of all positions where the player has a winning strategy is called the <strong>winning region</strong>.</p><blockquote><p>$\textbf{Definition 11.8. }\text{ The }\textit{winning region }W_i(\mathcal{G})\text{ of Player }i\text{ in a game }\mathcal{G}\text{ is defined as}\newline\text{the set of positions }v\in V\text{ for which there exists a strategy for Player }i\text{ that is winning from }v.$</p></blockquote><p>Note that the strategies for different positions in the winning region may be different. If a strategy $\sigma$ is winning from all positions of the winning region, we call $\sigma$ a <strong>uniform winning strategy</strong>.</p><p>It is easy to see that no position can be in the winning regions of both players. Otherwise there exists a position $v$ and strategies $\sigma$ and $\tau$ that are winning from $v$ for Player 0 and 1, respectively. Then the unique play that is consistent with $\sigma$ and $\tau$ need to be both in Win, because $\sigma$ is winning, and not in Win, because $\tau$ is winning. </p><p>A more difficult question is whether all positions are in some winning region, i.e., whether the winning regions form a partition of $V$. This property is called the <strong>determinacy</strong> of a game:</p><blockquote><p>$\textbf{Definition 11.9. }\text{A }\textit{game }\mathcal{G}\text{ is }\textit{determined }\text{if }V&#x3D;W_0(\mathcal{G})\cup W_1(\mathcal{G})$</p></blockquote><p>If the winning strategies are in fact memoryless, we say the game is <strong>memoryless</strong> (<strong>positionally</strong>) determined.</p><blockquote><p>$\textbf{Definition 11.10. }\text{A game is }\textit{memoryless determined }\text{if for every position }v\in V\text{, there exists}\newline\text{a memoryless stratey that is winning for some player from position }v.$</p></blockquote><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this section, we have learned:</p><ul><li><p><strong>Arena</strong>: the graph of the game, expressed as a tuple $\mathcal{A}&#x3D;(V,V_0,V_1,E)$</p><ul><li><strong>Position</strong>: vertex of Arena $v\in V$</li><li><strong>Positions of Player $i$</strong>: a disjoint set of position $V_i$</li></ul></li><li><p><strong>Play</strong>: an infinite sequence of $\rho\in V^\omega$</p><ul><li><strong>set of all Plays</strong>: $\text{Plays}(\mathcal{A})$</li><li><strong>set of all Plays in position $v$</strong>: $\text{Plays}(\mathcal{A},v)$</li><li><strong>starting position</strong>: $v &#x3D; \rho(0)$</li><li>the player who <strong>owns the position chooses the edge</strong> on which the play is continued ($\rho\in V_i$)</li></ul></li><li><p><strong>Game</strong>: consist of an arena and a winning condition $\mathcal{G}&#x3D;(\mathcal{A},\text{Win})$</p><ul><li><strong>winning condition</strong>: $\text{Win}\subseteq V^\omega$</li><li><strong>winning play for Player 0</strong>: $\rho\in\text{Win}$</li><li><strong>winning play for Player 1</strong>: $\rho\notin\text{Win}$</li></ul></li><li><p><strong>history</strong>: all previous positions $V^\ast$</p></li><li><p><strong>Strategy</strong>: decisions of a player based on history of the play</p><ul><li><strong>Strategy of Player $i$</strong>: $\sigma:V^\ast V_i\rightarrow V$</li><li><strong>Strategy of Player 0</strong>: $\sigma$</li><li><strong>Strategy of Player 1</strong>: $\tau$</li></ul></li><li><p><strong>Memoryless (positional) Strategy</strong>: $\sigma(wv)&#x3D;\sigma(v)\text{ for all }w\in V^\ast,v\in V_i$</p></li><li><p><strong>Winning Region</strong>: set of all positions that Player $i$ has a winning strategy $W_i(\mathcal{G})\in V$  </p><ul><li><strong>Uniform Winning Strategy</strong>: one strategy that can apply to any position in a winning region.</li></ul></li><li><p><strong>Determinacy</strong>: $\mathcal{G}$ is determined if every position is in some player‚Äôs winning region $V&#x3D;W_0(\mathcal{G})\cup W_1(\mathcal{G})$</p><ul><li>A determined game have winning strategy in every positions.</li></ul></li><li><p><strong>Memoryless Game</strong>: all strategies are memoryless in every position of a determined game</p></li></ul><hr><p>Next chapter: <a href="../agv11-2/">Reachability Games</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-5/&quot;&gt;From semi-deterministic B√ºchi to deterministic Muller&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning </summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 10.5 -- From semi-deterministic B√ºchi to deterministic Muller</title>
    <link href="https://greenmeeple.github.io/AGV/agv10-5/"/>
    <id>https://greenmeeple.github.io/AGV/agv10-5/</id>
    <published>2025-02-11T07:41:39.000Z</published>
    <updated>2025-04-03T07:41:15.439Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv10-4/">Semi-Deterministic B√ºchi Automata</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>From the semi-deterministic B√ºchi automaton we now build a deterministic Muller automaton. The idea of the construction is to continuously simulate, in the deterministic automaton, the nondeterministic part of the semi-deterministic automaton and to ‚Äùattempt‚Äù a transition into the deterministic part whenever possible.</p><p>In the state of the deterministic automaton we maintain an ‚Äúarray‚Äù of states that correspond to these attempts. Along each run of the automaton, there may of course be infinitely many such attempts; we only need a finite array, however, because we do not need to keep track of two different attempts to enter the deterministic part, if they both reach the same state (in this case, we simply track the attempt that entered the deterministic part earlier). </p><p>We use an array of size $2m$, where m is the number of states of the deterministic part. The factor two allows us to leave a position of the array empty (‚Äú‚ê£‚Äù) if an attempt is not continued. This is necessary to distinguish a situation where a previously started attempt failed and, at the same time, a new attempt enters the deterministic part, from the situation where the same attempt ran continuously. The deterministic automaton accepts if there is at least one attempt that runs forever after some point and reaches an accepting state infinitely often.</p><hr><p>Next chapter: <a href="../agv11-1/">Infinite Games (Basic Definitions)</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-4/&quot;&gt;Semi-Deterministic B√ºchi Automata&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in </summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 10.4 -- Semi-Deterministic B√ºchi Automata</title>
    <link href="https://greenmeeple.github.io/AGV/agv10-4/"/>
    <id>https://greenmeeple.github.io/AGV/agv10-4/</id>
    <published>2025-01-29T14:23:24.000Z</published>
    <updated>2025-04-03T07:41:15.407Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv10-3/">Closure Properties of Muller automata Under Boolean Operations</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>To prove McNaughton‚Äôs theorem, in this subsection, we will introdue the <strong>semi-deterministic B√ºchi automata</strong>.</p><ol><li>translate nondeterministic B√ºchi automata into semi-deterministic B√ºchi automata.</li><li>translate from semi-deterministic B√ºchi automata to deterministic Muller automata.</li></ol><h2 id="Semi-deterministic-Buchi-Automata"><a href="#Semi-deterministic-Buchi-Automata" class="headerlink" title="Semi-deterministic B√ºchi Automata"></a>Semi-deterministic B√ºchi Automata</h2><p>A <em>semi-deterministic automaton</em> is a (possibly nondeterministic) automaton where all accepting runs ultimately end up in a <strong>subset of the states</strong> from which all transitions are deterministic.</p><blockquote><p>$\textbf{Definition 10.2. } \text{A B√ºchi automata }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{B√úCHI} \normalsize(F))\text{ is }\textit{semi-deterministic}\text{ if}\newline Q &#x3D; N \uplus D\text{ is a partition of }Q\text{ such that }F\subseteq D, pr_2(T\cap(D\times\Sigma\times Q))\subseteq D\text{, and }\newline(\Sigma,D,\lbrace d\rbrace,T\cap(D\times\Sigma\times D),\small\text{B√úCHI}\normalsize(F)) \text{ is deterministic for every }d\in D.$</p></blockquote><h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p>$Q &#x3D; N \uplus D:$ a <em>disjoint union symbol</em> $\uplus$ indicates that $N$ and $D$ are two seperated subset.</p><p>$D:$ firstly, set of accepting states in part of $D$ ($F\subseteq D$). Then for all transistion starts from $D$ ($T\cap(D\times\Sigma\times Q)$), their successors are also in $D$ ($pr_2(T\cap(D\times\Sigma\times Q))\subseteq D$).</p><p>Therefore, we can split such automaton into nondeterministic part $N$ and determinstic part $D$, and the accepting run will end up stays in $D$.</p><h2 id="From-Nondeterministic-to-Semi-deterministic-Buchi-Automata"><a href="#From-Nondeterministic-to-Semi-deterministic-Buchi-Automata" class="headerlink" title="From Nondeterministic to Semi-deterministic B√ºchi Automata"></a>From Nondeterministic to Semi-deterministic B√ºchi Automata</h2><p>The translation is based on a <strong>subset construction</strong>, where we collect two sets of states:</p><ol><li>the states that are reachable on the given input word, and</li><li>the states that are reachable on some path through an accepting state.</li></ol><p>A state of the semi-deterministic automaton is accepting if the <strong>two sets become equal</strong>; when this happens, the second set is reinitialized with the subset of accepting states that appear in the first component.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/images/notes/uds/agv/10_4_nonde.png"></p><p><img src="/images/notes/uds/agv/10_4_subset.png"></p><p>The subset construction produces a <em>deterministic</em> automaton that accepts a subset of the words accepted by the original automaton. If the two sets are equal infinitely often, we can construct a run of the original automaton that goes through accepting states infinitely often:</p><p>intuitively, we can go ‚Äúbackwards‚Äù from each position where the two sets have become equal and select a path segment for the original automaton where an accepting state is visited (in the proof below we give a more precise argument using K√∂nig‚Äôs lemma).</p><p>There is no general guarantee that the set of reachable states from some position of an accepting run and the set of states reachable on a path through some accepting state are the same. This is illustrated by the following example.</p><p><img src="/images/notes/uds/agv/10_4_counter.png"></p><p>Let the input word be $\alpha^\omega$. From the initial position of some run, which starts in the initial state $p$, all states are reachable, but only $r$ and $s$ are reachable on paths from $s$.</p><p>Ultimately, however, every accepting run must reach (and remain in) positions where the <strong>set of reachable states</strong> and the <strong>set of states reachable on a path through some accepting state</strong> are the same. This is because the set of reachable states can only become smaller finitely often; hence, at some point, the set of reachable states will remain the same from all subsequent positions, including those (future) positions of the accepting run where the run visits an accepting state.</p><p>In our semi-deterministic automaton, we therefore start by simulating the given nondeterministic automaton. At any point we allow a nondeterministic transition into the (from then on) deterministic subset construction.</p><blockquote><p>$\textbf{Construction 10.5. } \text{For a B√ºchi automaton }\mathcal{A}&#x3D;(\Sigma,Q,I,T,\small\text{B√úCHI}\normalsize (F))\text{, we construct the semi-}\newline\text{deterministic B√ºchi automaton }\mathcal{A‚Äô} &#x3D; (\Sigma,Q‚Äô,I‚Äô,T‚Äô,\small\text{B√úCHI}\normalsize (F‚Äô))\text{ with }\mathcal{L}(\mathcal{A‚Äô})&#x3D;\mathcal{L}(\mathcal{A})\text{ as follows:}$<br>$\begin{array}{l}<br>\hspace{1cm} \cdot \ Q‚Äô&#x3D;Q\uplus (2^Q\times2^Q)\newline<br>\hspace{1cm} \cdot \ I‚Äô&#x3D;I‚Äô \newline<br>\hspace{1cm} \cdot \ T‚Äô&#x3D;T\cup\lbrace(q,\sigma,(\lbrace q‚Äô\rbrace,\varnothing))\mid(q,\sigma,q‚Äô)\in T\rbrace \newline<br>\hspace{2.85cm}\cup \ \lbrace((L_1,L_2),\sigma,(L‚Äô_1,L‚Äô_2))\mid L_1\neq L_2\newline<br>\hspace{3.8cm}L‚Äô_1&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times Q)\newline<br>\hspace{3.8cm}L‚Äô_2&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times F)\cup pr_2(T\cap L_2\times\lbrace\sigma\rbrace\times Q)\rbrace\newline<br>\hspace{2.85cm}\cup \ \lbrace((L_1,L_2),\sigma,(L‚Äô_1,L‚Äô_2))\mid L_1&#x3D; L_2\newline<br>\hspace{3.8cm}L‚Äô_1&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times Q)\newline<br>\hspace{3.8cm}L‚Äô_2&#x3D;pr_2(T\cap L_1\times\lbrace\sigma\rbrace\times F)\newline<br>\hspace{1cm} \cdot \ F‚Äô&#x3D;\lbrace(L,L)\in(2^Q\times2^Q)\mid L\neq\varnothing\rbrace\newline<br>\end{array}$</p></blockquote><blockquote><p>$\textbf{Lemma 10.1. } \textit{For every B√ºchi automaton }\mathcal{A}\textit{ there exists a semi-deterministic B√ºchi}\newline\textit{automaton }\mathcal{A‚Äô}\textit{ with }\mathcal{L}(\mathcal{A})&#x3D;\mathcal{L}(\mathcal{A‚Äô}).$</p></blockquote><h2 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h2><p>$\mathcal{L}(\mathcal{A‚Äô})\subseteq\mathcal{L}(\mathcal{A})$</p><p>Let $\alpha\in\mathcal{L}(\mathcal{A‚Äô})$ and let $r‚Äô&#x3D;q_0q_1\dots q_{n-1}(L_n,L‚Äô<em>n)(L</em>{n+1},L‚Äô<em>{n+1})\dots$ be an accepting run of $\mathcal{A‚Äô}$ on $\alpha$. Since $r‚Äô$ is accepting, there is an infinite sequence $i_0i_1\dots$ of indices such that $i_0&#x3D;n$, and, for all $j\geq1$, $L</em>{i_j} &#x3D; L‚Äô<em>{i_j}$ and $L‚Äô</em>{i_j}\neq\varnothing$. For every $j\geq1$, and every $q‚Äô\in L_{i_j}$ there exists a state $q\in L_{i_{j‚àí1}}$ and a sequence $q &#x3D; q_{i_{j‚àí1}} , q_{i_{j‚àí1}+1},\dots, q_{i_j} &#x3D; q‚Äô$ such that $(q_k, \alpha(k), q_{k+1})\in T$ for all $k\in \lbrace i_{j‚àí1},\dots,i_j ‚àí 1\rbrace$ and $q_k\in F$ for some $k\in\lbrace i_{j‚àí1}+1,\dots,i_j\rbrace$. We use the following notation: $\textit{predecessor}(q‚Äô,i_j) :&#x3D; q, \textit{run}(q‚Äô,i_0) &#x3D; q_0q_1\dots q_{n‚àí1}q‚Äô$ for $L_{i_0} &#x3D; \lbrace q‚Äô\rbrace$, and $\textit{run}(q‚Äô,i_j)&#x3D;(q_{i_{j‚àí1}+1})(q_{i_{j‚àí1}+2})\dots q_{i_j}$, for $j\geq1$. </p><p>Now consider the  j‚ààN Lij √ó {j} -labeled tree where the root is labeled with (q ‚Ä≤ , 0) for Li0 &#x3D; {q ‚Ä≤}, and the parent of each node with a label (q ‚Ä≤ , j) is labeled with (predecessor(q ‚Ä≤ , ij ), j ‚àí 1). The tree is infinite and finite-branching, and, hence, by K¬®onig‚Äôs Lemma, has an infinite branch (qi0 , i0),(qi1 , i1), . . ., corresponding to an accepting run of A: run(qi0 , i0) ¬∑ run(qi1 , i1) ¬∑ run(qi2 , i2) ¬∑ . . . </p><p>L(A) ‚äÜ L(A‚Ä≤ ): Let Œ± ‚àà L(A) and let r &#x3D; q0, q1, . . . be an accepting run of A on Œ±. Let i ‚àà N be an index s.t. qi ‚àà F and for all j ‚â• i there exists a k &gt; j, such that {q ‚àà Q | qi Œ±[i,k] ‚àí‚àí‚àí‚Üí q} &#x3D; {q ‚àà Q | qj Œ±[j,k] ‚àí‚àí‚àí‚Üí q}. The index i exists: ‚Äù‚äá‚Äù holds for all i, because there is a path through qj . Assume, by way of contradiction, that for all i ‚àà N, there is a j ‚â• i s.t for all k &gt; j ‚Äù‚äã‚Äù holds. Then there exists an i ‚Ä≤ s.t. {q ‚àà Q | qi ‚Ä≤ Œ±[i ‚Ä≤ ,k] ‚àí‚àí‚àí‚àí‚Üí q} &#x3D; ‚àÖ for all k &gt; i‚Ä≤ . Contradiction. We define a run r ‚Ä≤ of A‚Ä≤ : r ‚Ä≤ &#x3D; q0 . . . qi‚àí1({qi}, ‚àÖ)(L1, L‚Ä≤ 1 )(L2, L‚Ä≤ 2 ). . . where Lj and L ‚Ä≤ j are determined by the definition of A‚Ä≤ . To prove that r ‚Ä≤ is accepting, assume otherwise, and let m ‚àà N be an index such that Ln Ã∏&#x3D; L ‚Ä≤ n for all n ‚â• m. Then, let j &gt; m be some index with qj ‚àà F; hence qj ‚àà L ‚Ä≤ j . There exists a k &gt; j such that L ‚Ä≤ k+1 &#x3D; {q ‚àà Q | qj Œ±[j,k] ‚àí‚àí‚àí‚Üí q} &#x3D; {q ‚àà Q | qi Œ±[i,k] ‚àí‚àí‚àí‚Üí q} &#x3D; Lk+1. Contradiction.</p><hr><p>Next chapter: <a href="../agv10-5/">From semi-deterministic B√ºchi to deterministic Muller</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-3/&quot;&gt;Closure Properties of Muller automata Under Boolean Operations&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a </summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>Appium commands that are commonly used on Mac</title>
    <link href="https://greenmeeple.github.io/appium/"/>
    <id>https://greenmeeple.github.io/appium/</id>
    <published>2025-01-01T18:36:48.000Z</published>
    <updated>2025-04-03T07:41:15.319Z</updated>
    
    <content type="html"><![CDATA[<p>In this example, we will use <a href="https://github.com/appium/appium-inspector">Appium Inspector</a> to start a seesion on your emulator on <a href="https://developer.android.com/studio">Android Studio</a>.</p><h2 id="Start-appium"><a href="#Start-appium" class="headerlink" title="Start appium"></a>Start appium</h2><p><img src="/images/coding/appium/start.png"></p><p>First, start the connection with Appium by <code>cmd appium --allow-cors</code>. It also gives you the <code>remote url</code> and the <code>automationName</code> that can be used in the <a href="https://github.com/appium/appium-inspector">Appium Inspector</a></p><p><img src="/images/coding/appium/inspector.png"></p><h2 id="Start-Session"><a href="#Start-Session" class="headerlink" title="Start Session"></a>Start Session</h2><ul><li><strong>deviceName</strong>:  <code>adb devices</code></li><li><strong>platformName</strong> - <code>appium driver list</code></li><li><strong>platformVersion</strong> -  <code>adb shell getprop ro.build.version.release</code></li></ul><p><img src="/images/coding/appium/session.png"></p><p><img src="/images/coding/appium/inspector2.png"></p><p>Now you can start a session in your emulator, but it always begins from the home page. To directly start a session on certain App, you also need to provide the  <code>appPackage</code> and the <code>appActivity</code>.</p><h2 id="Session-with-Apps"><a href="#Session-with-Apps" class="headerlink" title="Session with Apps"></a>Session with Apps</h2><p>If your app is downloaded from the PlayStore. It is possible that the apk file name&#x2F;path is hidden. However, you can You can simply open the app and check its name by <code>adb shell dumpsys window | grep mCurrentFocus</code>.</p><p>It returns the <code>appPackage</code> and the current <code>appActivity</code> of the App, which are both necessary for our seesion to start. However, sometimes the current activity may not be directly opened. Then we need to check all the possible activities this App contans and try them out.</p><p>To check the activity list, we can use <code>adb shell dumpsys package YOUR_APP_appPackage | grep -i activity</code>.</p><p><img src="/images/coding/appium/activity.png"></p><p>Now, we can start our emulator, and run the command <code>adb shell am start -n YOUR_APP_appPackage/YOUR_APP_appActivity</code> to see whether it can start the App successfully. If it works we can use it in our inspector.</p><p><img src="/images/coding/appium/cici.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;In this example, we will use &lt;a href=&quot;https://github.com/appium/appium-inspector&quot;&gt;Appium Inspector&lt;/a&gt; to start a seesion on your emulato</summary>
      
    
    
    
    <category term="Coding" scheme="https://greenmeeple.github.io/categories/Coding/"/>
    
    
    <category term="Appium" scheme="https://greenmeeple.github.io/tags/Appium/"/>
    
    <category term="Automation" scheme="https://greenmeeple.github.io/tags/Automation/"/>
    
    <category term="App Testing" scheme="https://greenmeeple.github.io/tags/App-Testing/"/>
    
    <category term="Android" scheme="https://greenmeeple.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Automata, Games, and Verification (Portal)</title>
    <link href="https://greenmeeple.github.io/AGV/agv/"/>
    <id>https://greenmeeple.github.io/AGV/agv/</id>
    <published>2024-12-22T15:35:16.000Z</published>
    <updated>2025-04-03T07:41:15.405Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1. Introduction"></a>Chapter 1. Introduction</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv1-1/">1.1. Model Checking</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv1-2/">1.2. Synthesis</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv1-3/">1.3. The Logic-Automata Connection</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-2-Buchi-Automata"><a href="#Chapter-2-Buchi-Automata" class="headerlink" title="Chapter 2. B√ºchi Automata"></a>Chapter 2. B√ºchi Automata</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv2-1/">2.1. Preliminaries</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv2-2/">2.2. Automata over Infinite Words</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv2-3/">2.3. The B√ºchi Acceptance Condition</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-3-Buchi‚Äôs-Characterization-Theorem"><a href="#Chapter-3-Buchi‚Äôs-Characterization-Theorem" class="headerlink" title="Chapter 3. B√ºchi‚Äôs Characterization Theorem"></a>Chapter 3. B√ºchi‚Äôs Characterization Theorem</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv3-1/">3.1. Kleene‚Äôs Theorem</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv3-2/">3.2. $\omega$-regular language</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv3-3/">3.3 Closure Properties of the B√ºchi-recognizable languages (Intersection and Union)</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv3-4/">3.4 Closure Properties of the B√ºchi-recognizable languages (Concatenations)</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv3-5/">3.5 B√ºchi‚Äôs Characterization Theorem</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-4-Deterministic-Buchi-Automata"><a href="#Chapter-4-Deterministic-Buchi-Automata" class="headerlink" title="Chapter 4. Deterministic B√ºchi Automata"></a>Chapter 4. Deterministic B√ºchi Automata</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv4-1/">4.1. Deterministic vs. Nondeterministic B√ºchi Automata</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv4-2/">4.2. Complementation of deterministic B√ºchi Automata</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-5-Complementation-of-Buchi-automata"><a href="#Chapter-5-Complementation-of-Buchi-automata" class="headerlink" title="Chapter 5. Complementation of B√ºchi automata"></a>Chapter 5. Complementation of B√ºchi automata</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv5-1/">5.1. Infinite Directed Acyclic Graph (DAG)</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv5-2/">5.2. Ranking of DAG</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv5-3/">5.3. Complement B√ºchi Automaton with Odd Ranking</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-6-Logics-over-Infinite-Sequences"><a href="#Chapter-6-Logics-over-Infinite-Sequences" class="headerlink" title="Chapter 6. Logics over Infinite Sequences"></a>Chapter 6. Logics over Infinite Sequences</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv6-1/">6.1. Linear-Time Temporal Logic (LTL)</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv6-2/">6.2. Expressing Program Properties using LTL</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv6-3/">6.3. LTL and Counting Languages</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv6-4/">6.4. Quantified Propositional Temporal Logic (QPTL)</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv6-5/">6.5. Monadic Second-Order Logic of One Successor (S1S)</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv6-6/">6.6. Express QPTL using S1S</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv6-7/">6.7. S1S$_0$ and B√ºchi-recognizable LanguageB√ºchi-recognizable</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-7-Alternating-Buchi-Automata"><a href="#Chapter-7-Alternating-Buchi-Automata" class="headerlink" title="Chapter 7. Alternating B√ºchi Automata"></a>Chapter 7. Alternating B√ºchi Automata</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv7-1/">7.1. Alternating B√ºchi Automata</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv7-2/">7.2. From LTL to Alternating B√ºchi Automata</a></td><td align="left"><a href="../agv7-2/">$\varphi&#x3D;(\Diamond p)\ \mathcal{U}\ (\square q)$</a></td></tr><tr><td align="left"><a href="../agv7-3/">7.3. Translating Alternating to Nondeterministic automata</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-8-Linear-Arithmetic"><a href="#Chapter-8-Linear-Arithmetic" class="headerlink" title="Chapter 8. Linear Arithmetic"></a>Chapter 8. Linear Arithmetic</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv8-1/">8.1. Linear Arithmetic (Theory)</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv8-2/">8.2 Encoding real numbers</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv8-3/">8.3 Translation from Linear Arithmetic to Automata</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv8-4/">8.4 Homogenous Inequality Testing is Automatic</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv8-5/">8.5 From Linear Arithmetic to Automata</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-9-LTL-Model-Checking"><a href="#Chapter-9-LTL-Model-Checking" class="headerlink" title="Chapter 9. LTL Model Checking"></a>Chapter 9. LTL Model Checking</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv9-1/">9.1 Automata-based LTL Model Checking with Sequential Circuits</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv9-2/">9.2 Nested depth-first search</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv9-3/">9.3 The Emerson-Lei algorithm</a></td><td align="left"></td></tr></tbody></table><h2 id="Chapter-10-McNaughton‚Äôs-Theorem"><a href="#Chapter-10-McNaughton‚Äôs-Theorem" class="headerlink" title="Chapter 10. McNaughton‚Äôs Theorem"></a>Chapter 10. McNaughton‚Äôs Theorem</h2><table><thead><tr><th align="left">Sections</th><th align="left">Exercise</th></tr></thead><tbody><tr><td align="left"><a href="../agv10-1/">10.1 The Muller Acceptance Condition</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv10-2/">10.2 From B√ºchi automata to Muller automata</a></td><td align="left"></td></tr><tr><td align="left"><a href="../agv10-3/">10.3 Closure Properties of Muller Automata under Boolean Operations</a></td><td align="left"></td></tr></tbody></table><hr><p>Next chapter: <a href="../agv/"></a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, UdS. Taught by Bernd Finkbeiner&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>Cantonese Ch.1-6 -- Tones</title>
    <link href="https://greenmeeple.github.io/Canto/canto1-6/"/>
    <id>https://greenmeeple.github.io/Canto/canto1-6/</id>
    <published>2024-12-19T02:06:12.000Z</published>
    <updated>2025-04-03T07:41:15.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Golden Rule of becoming a native Cantonese speaker: <strong>Tones</strong> &gt; Everything!</p></blockquote><p>In this blog, we use <a href="https://jyutping.org/en/docs/english/">Jyutping</a> to indicate the pronunciation of Cantonese characters.</p><p>Previous lesson: <a href="../canto1-3/">Rimes with e</a></p><hr><p>In this lesson, we talk about Rimes with <code>u</code>, <code>yu</code>. Here we use <code>u</code> similar to languages like German or Italian.</p><p>And <code>yu</code> is equivalent to ‚Äú√º‚Äù in German. Let‚Äôs take a look.</p><h2 id="Rimes-with-u"><a href="#Rimes-with-u" class="headerlink" title="Rimes with u"></a>Rimes with <code>u</code></h2><p>For <code>u</code>, <code>ui</code>, <code>un</code>, <code>ut</code>, u sounds like ‚Äúoo‚Äù in ‚Äúfoo‚Äù.</p><p>For <code>ung</code> and <code>uk</code>, u sound like ‚Äúone‚Äù in ‚Äútone‚Äù.</p><table><thead><tr><th align="left">Jyutping</th><th align="left">Sounds in English</th><th align="left">Cantonese Example</th><th align="left">Jyutping</th><th align="left">Sounds in English</th><th align="left">Cantonese Example</th></tr></thead><tbody><tr><td align="left">u</td><td align="left">oo in foo</td><td align="left"><ruby>Â§´<rp>(</rp><rt>fu1</rt><rp>)</rp></ruby></td><td align="left">ut</td><td align="left">oot in boot</td><td align="left"><ruby>Èóä<rp>(</rp><rt>fut3</rt><rp>)</rp></ruby></td></tr><tr><td align="left">ui</td><td align="left">ewy in chewy<sup>1</sup></td><td align="left"><ruby>ÁÅ∞<rp>(</rp><rt>fui1</rt><rp>)</rp></ruby></td><td align="left">ung</td><td align="left">one in tone</td><td align="left"><ruby>È¢®<rp>(</rp><rt>fung1</rt><rp>)</rp></ruby></td></tr><tr><td align="left">un</td><td align="left">oon in cartoon</td><td align="left"><ruby>Ê≠°<rp>(</rp><rt>fun1</rt><rp>)</rp></ruby></td><td align="left">uk</td><td align="left">ook in cook</td><td align="left"><ruby>Á¶è<rp>(</rp><rt>fuk1</rt><rp>)</rp></ruby></td></tr></tbody></table><p><sup>1</sup>‚ÄúChewy‚Äù is two syllables, but in Cantonese this is a diphthong. So try to blend it into one sound, treat the ‚Äúew‚Äù as the major sound and the ‚Äúj‚Äù as a small tip at the end of the syllable.</p><h2 id="Rimes-with-yu"><a href="#Rimes-with-yu" class="headerlink" title="Rimes with yu"></a>Rimes with <code>yu</code></h2><p>Unfortunately, in English there is no word sound exactly as <code>yu</code>.</p><p>But you can imitate it by positioning your tongue more forward, closer to your front teeth (not touching them!), and try to say the word ‚Äúfoo‚Äù.</p><p>In some accents, when people say the word ‚Äúo<strong>ccu</strong>py‚Äù or ‚Äúe<strong>du</strong>cation‚Äù, they may use the <code>yu</code> sound as well.</p><table><thead><tr><th align="left">Jyutping</th><th align="left">Sounds in English</th><th align="left">Cantonese Example</th><th align="left">Jyutping</th><th align="left">Sounds in English</th><th align="left">Cantonese Example</th></tr></thead><tbody><tr><td align="left">yu</td><td align="left">u in occupy</td><td align="left"><ruby>Êõ∏<rp>(</rp><rt>syu1</rt><rp>)</rp></ruby></td><td align="left">yut</td><td align="left">uned in tuned</td><td align="left"><ruby>Èõ™<rp>(</rp><rt>syut3</rt><rp>)</rp></ruby></td></tr><tr><td align="left">yun</td><td align="left">une in tune</td><td align="left"><ruby>ÈÖ∏<rp>(</rp><rt>syun1</rt><rp>)</rp></ruby></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>Next lesson: <a href="../canto1-6/">Tones</a></p><hr><p>Further reading: <a href="https://jyutping.org/en/">Jyutping</a>, <a href="https://lshk.org/">The linguistic Society of Hong Kong</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Golden Rule of becoming a native Cantonese speaker: &lt;strong&gt;Tones&lt;/strong&gt; &amp;gt; Everything!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this blo</summary>
      
    
    
    
    <category term="Cantonese" scheme="https://greenmeeple.github.io/categories/Cantonese/"/>
    
    <category term="Full_Course" scheme="https://greenmeeple.github.io/categories/Cantonese/Full-Course/"/>
    
    
    <category term="Cantonese" scheme="https://greenmeeple.github.io/tags/Cantonese/"/>
    
    <category term="Language Learning" scheme="https://greenmeeple.github.io/tags/Language-Learning/"/>
    
    <category term="Phonology" scheme="https://greenmeeple.github.io/tags/Phonology/"/>
    
  </entry>
  
  <entry>
    <title>AGV -- (Exercise 7.2) LTL to Alternating B√ºchi Automata</title>
    <link href="https://greenmeeple.github.io/AGV/agv7-2-eg/"/>
    <id>https://greenmeeple.github.io/AGV/agv7-2-eg/</id>
    <published>2024-12-17T03:02:09.000Z</published>
    <updated>2025-04-03T07:41:15.423Z</updated>
    
    <content type="html"><![CDATA[<p>Previous Exercise: <a href=""></a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><p>This is an example exercise to express LTL formula into Alternating B√ºchi Automata. For further definitions, you may check <a href="../agv7-2/">Section 7.2</a>.</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Use the <a href="../agv7-2/">construction from the lecture</a> to construct an alternating B√ºchi automaton $\mathcal{A}$ such that $$\mathcal{L(A)&#x3D;L}((\Diamond p)\ \mathcal{U}\ (\square q))$$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>we build the following alternating B√ºchi automaton  $\mathcal{A} &#x3D; (2^{p,q},Q,\varphi,\delta,\small\text{B√úCHI} \normalsize(F))$ which recognizes the models of $\varphi&#x3D;(\Diamond p)\ \mathcal{U}\ (\square q)$. First we consider the transition function $\delta$ for an arbitrary symbol $a\in2^{p,q}:$</p><p>$\begin{array}{lll}<br>\hspace{1cm}\bullet &amp;&amp;\delta(\square q,a)\newline<br>&amp;&#x3D;&amp;\delta(\neg(\textit{true}\ \mathcal{U}\ \neg q) ,a)\newline<br>&amp;&#x3D;&amp;\overline{\delta(\textit{true}\ \mathcal{U}\ \neg q ,a)}\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)\vee(\delta(\textit{true},a)\wedge(\textit{true}\ \mathcal{U}\ \neg q))}\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\overline{(\delta(\textit{true},a)\wedge (\textit{true}\ \mathcal{U}\ \neg q))}&amp;(\textit{true}\wedge \psi&#x3D;\psi)\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\overline{(\textit{true}\ \mathcal{U}\ \neg q)}&amp;(\text{Using line 1})\newline<br>&amp;&#x3D;&amp;\overline{\delta(\neg q,a)}\wedge\square q\newline<br>&amp;&#x3D;&amp;\left\lbrace \begin{array}{lll}<br>\square q&amp;\text{if }q\in a\newline<br>\textit{false}&amp;\text{if }q\notin a\newline<br>\end{array}\right.<br>\end{array}<br>\ \newline \ \newline<br>\begin{array}{lll}<br>\hspace{1cm}\bullet &amp;&amp;\delta(\Diamond p,a)\newline<br>&amp;&#x3D;&amp;\delta(\textit{true}\ \mathcal{U}\ p ,a)\newline<br>&amp;&#x3D;&amp;\delta(p,a)\vee(\delta(\textit{true},a)\wedge\Diamond p)&amp;(\textit{true}\wedge \psi&#x3D;\psi)\newline<br>&amp;&#x3D;&amp;\delta(p,a)\vee\Diamond p\newline<br>&amp;&#x3D;&amp;\left\lbrace \begin{array}{lll}<br>\Diamond p&amp;\text{if }p\notin a\newline<br>\textit{true}&amp;\text{if }p\in a\newline<br>\end{array}\right.<br>\end{array}<br>$</p><p>By Substitution above result into $\delta((\Diamond p)\ \mathcal{U}\ (\square q),a)&#x3D;\delta(\square q,a)\vee(\delta(\Diamond p,a)\wedge(\Diamond p)\ \mathcal{U}\ (\square q))$, we have:</p><p>$$\delta((\Diamond p)\ \mathcal{U}\ (\square q),a)&#x3D;\left\lbrace<br>\begin{array}{lll}<br>\Diamond p\wedge((\Diamond p)\ \mathcal{U}\ (\square q))&amp;\text{if }a &#x3D;\varnothing &amp;(\vee\ \textit{false}\text{ is omitted.})\newline<br>(\Diamond p)\ \mathcal{U}\ (\square q)&amp;\text{if }a &#x3D;\lbrace p\rbrace&amp;(\wedge\ \textit{true}\text{ is omitted.})\newline<br>\square q\vee(\Diamond p\wedge((\Diamond p)\ \mathcal{U}\ (\square q)))&amp;\text{if }a &#x3D;\lbrace q\rbrace\newline<br>\square q\vee((\Diamond p)\ \mathcal{U}\ (\square q))&amp;\text{if }a &#x3D;\lbrace p,q\rbrace&amp;(\wedge\ \textit{true}\text{ is omitted.})\newline<br>\end{array}\right.$$</p><p>For each case, when we see $\vee$, that‚Äôs a <strong>nondeterministic transitions</strong>, we need draw two seperate transitions for each successors. On the other hand $\wedge$ is a <strong>universal transitions</strong>, it is a single transition towards both successors, we split the extra branches from the path to indicate that. Thus we have the following automaton $\mathcal{A}$:</p><p><img src="/images/notes/uds/agv/7_2_eg.png"></p><hr><p>Next Exercise: <a href="../agv/"></a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous Exercise: &lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a href=&quot;https://cispa.de/de&quot;&gt;CISPA&lt;/a&gt;, Ud</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 10.3 -- Closure Properties of Muller automata Under Boolean Operations</title>
    <link href="https://greenmeeple.github.io/AGV/agv10-3/"/>
    <id>https://greenmeeple.github.io/AGV/agv10-3/</id>
    <published>2024-12-13T04:02:57.000Z</published>
    <updated>2025-04-03T07:41:15.440Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv10-2/">From B√ºchi automata to Muller automata</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>We now show that deterministic Muller automata are closed, like nondeterministic B√ºchi automata, under the Boolean operations (<code>complementation</code>, <code>union</code>, and <code>intersection</code>).</p><p>First we introduce the construction of these automaton with operations, then we will prove they are close by the runs under those constructions.</p><h2 id="Automata-construction-of-Complementation"><a href="#Automata-construction-of-Complementation" class="headerlink" title="Automata construction of Complementation"></a>Automata construction of Complementation</h2><blockquote><p>$\textbf{Construction 10.3. } \text{Let }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F}))\text{ be a complete and deterministic Muller}\newline\text{automaton, where we assume w.l.o.g that }Q\neq\varnothing.\text{ We construct the deterministic Muller}\newline\text{automaton }\mathcal{A}^C &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize(2^Q\setminus\mathcal{F}))\text{ with }\mathcal{L(A^C)}&#x3D;\Sigma\setminus\mathcal{L(A)}.$</p></blockquote><h2 id="Automata-construction-of-Intersection"><a href="#Automata-construction-of-Intersection" class="headerlink" title="Automata construction of Intersection"></a>Automata construction of Intersection</h2><p>We use the function $pr_n$ for $n\in\mathbb{N}$ to project to the (n+1)th component of a arbitrary length tuple, for example:</p><ul><li>$pr_0(x, y)&#x3D;x$</li><li>$pr_1(x, y)&#x3D;y$</li><li>$pr_2(x, y),pr_3(x, y),\dots pr_n(x, y) &#x3D;\text{Undefined}$</li></ul><p>We can also apply the projection to a set and return a <strong>set of components</strong>: $pr_n(S) &#x3D; \bigcup_{s‚ààS}{pr_n(s)}.$</p><blockquote><p>$\textbf{Construction 10.4. } \text{For Muller automata }\mathcal{A_1} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F_1}))\text{ and}\newline\mathcal{A_2} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F_2}))\text{ over the same alphabet }\Sigma.\text{ We construct the Muller Automaton}\newline\mathcal{A}_\cap &#x3D; (\Sigma,Q_1\times Q_2,I_1\times I_2,T_\cap,\small\text{MULLER} \normalsize(\mathcal{F_\cap}))\text{ with }\mathcal{L(A_\cap)}&#x3D;\mathcal{L(A_1)}\cap\mathcal{L(A_2)}\text{ and where }\mathcal{A_\cap}\text{ is}\newline\text{deterministic if }\mathcal{A_1}\text{ and }\mathcal{A_2}\text{ are deterministic, as follows:}$</p><p>$\begin{array}{l}\hspace{1cm}\cdot \ T_\cap&#x3D;\lbrace((q_1,q_2),\sigma,(q‚Äô_1,q‚Äô_2))\mid(q_1,\sigma,q‚Äô_1)\in T_1,(q_2,\sigma,q‚Äô_2)\in T_2\rbrace\newline\hspace{1cm}\cdot \ \mathcal{F}_\cap &#x3D; \lbrace P\subseteq Q_1\times Q_2\mid pr_0(P)\in\mathcal{F_1},pr_1(P)\in\mathcal{F_2}\rbrace\end{array}$</p></blockquote><h2 id="Closure-Properties-of-under-Boolean-Operations"><a href="#Closure-Properties-of-under-Boolean-Operations" class="headerlink" title="Closure Properties of under Boolean Operations"></a>Closure Properties of under Boolean Operations</h2><blockquote><p>$\textbf{Theorem 10.3. } \textit{The languages recognizable by deterministic Muller automata are closed}\newline\textit{under Boolean operations (complementation, union, intersection).}.$</p></blockquote><h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-complementation"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-complementation" class="headerlink" title="Proof of Deterministic Muller automata are closed under complementation"></a>Proof of Deterministic Muller automata are closed under complementation</h3><p>For a deterministic Muller automaton $\mathcal{A}$, the automaton $\mathcal{A‚Äô}$ of Construction 10.3 recognizes the <code>complement</code> language, because any set $F\notin F$ has to be in the <code>complement</code>, i.e., $F\in2^Q\setminus F$.</p><h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-Intersection"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-Intersection" class="headerlink" title="Proof of Deterministic Muller automata are closed under Intersection"></a>Proof of Deterministic Muller automata are closed under Intersection</h3><p>For deterministic Muller automata $\mathcal{A_1}$ and $\mathcal{A_2}$, the automaton $\mathcal{A}_\cap$ of Construction 10.4 recognizes the <code>intersection</code>. Let $r_1 &#x3D; q^1_0q^1_1\dots$ and $r_2 &#x3D; q^2_0q^2_1\dots$ be accepting runs of $\mathcal{A_1}$ and $\mathcal{A_2}$ on some $\alpha$. Then $r&#x3D;(r^1_0,r^2_0)(r^1_1,r^2_1)\dots$ is an accepting run of $\mathcal{A}_\cap$ on $\alpha$ and vice versa.</p><h3 id="Proof-of-Deterministic-Muller-automata-are-closed-under-Union"><a href="#Proof-of-Deterministic-Muller-automata-are-closed-under-Union" class="headerlink" title="Proof of Deterministic Muller automata are closed under Union"></a>Proof of Deterministic Muller automata are closed under Union</h3><p>It can be proved by <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan‚Äôs laws</a> if they are closed under <code>complement</code> and <code>intersection</code>:</p><p>$$\Sigma\setminus(\mathcal{L(A_1)}\cap\mathcal{L(A_2)})&#x3D;(\Sigma\setminus\mathcal{L(A_1)})\cup(\Sigma\setminus\mathcal{L(A_2)})$$</p><h2 id="Regular-language-and-Limit-operator"><a href="#Regular-language-and-Limit-operator" class="headerlink" title="Regular language and Limit operator"></a>Regular language and Limit operator</h2><p>Similar to B√ºchi automata in <a href="../agv4-1/">section 4.1</a>, we can define an $\omega$-regular language from regular language, which is recognizable by deterministic Muller Automata:</p><blockquote><p>$\textbf{Theorem 10.4. }\textit{An language }L\textit{ is recognizable by a deterministic Muller Automata if and only}\newline\textit{if }L\textit{ is a Boolean combination of langauges }\overrightarrow{W}\textit{ where }W\subseteq\Sigma^*\text{ is regular.}$</p></blockquote><h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>$‚Äù\Leftarrow‚Äù$<br>If $W$ is regular, then $\overrightarrow{W}$ is recognizable by a deterministic B√ºchi automaton. Hence, $\overrightarrow{W}$ is recognizable by a deterministic Muller automaton. Thus, the boolean combination $\mathcal{L}$ is recognizable by a deterministic Muller automaton.</p><p>$‚Äù\Rightarrow‚Äù$<br>A deterministic Muller automaton $\mathcal{A}$ accepts some word $\alpha$ with a unique run $r$ if for some $F\in\mathcal{F}$ we have that $\text{Inf}(r)&#x3D;F$. Thus, there is some $F\in\mathcal{F}$ such that for all $q\in F$ we have that $\alpha\in\overrightarrow{W_q}$ and for all $q\notin F$ we have that $\alpha\notin\overrightarrow{W_q}$, where $\overrightarrow{W_q}&#x3D;\mathcal{L(A_q)}$ for the finite-word automaton $\mathcal{A}_q&#x3D;(\Sigma,Q,I,T,\lbrace q\rbrace)$. Hence,</p><p>$$\alpha\in\underset{F\in\mathcal{F}}{\bigcup}\left(\underset{q\in F}{\bigcap}\overrightarrow{W_q}\cap\underset{q\notin F}{\bigcap}(\Sigma^\omega\setminus\overrightarrow{W_q})\right)$$</p><hr><p>Next chapter: <a href="../agv10-4/">Semi-Deterministic B√ºchi Automata</a></p><p>Further Reading: <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">De Morgan‚Äôs laws</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-2/&quot;&gt;From B√ºchi automata to Muller automata&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a cours</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
  <entry>
    <title>AGV 10.2 -- From B√ºchi automata to Muller automata</title>
    <link href="https://greenmeeple.github.io/AGV/agv10-2/"/>
    <id>https://greenmeeple.github.io/AGV/agv10-2/</id>
    <published>2024-12-12T22:37:22.000Z</published>
    <updated>2025-04-03T07:41:15.407Z</updated>
    
    <content type="html"><![CDATA[<p>Previous chapter: <a href="../agv10-1/">The Muller Acceptance Condition</a></p><blockquote><p>This is a learning note of a course in <a href="https://cispa.de/de">CISPA</a>, UdS. Taught by Bernd Finkbeiner</p></blockquote><p>In this section, we want to prove that Muller automata is equivalent to B√ºchi Automata.</p><h2 id="Translate-Buchi-Automata-into-Muller-Automata"><a href="#Translate-Buchi-Automata-into-Muller-Automata" class="headerlink" title="Translate B√ºchi Automata into Muller Automata"></a>Translate B√ºchi Automata into Muller Automata</h2><blockquote><p>$\textbf{Construction 10.1. } \text{For a (deterministic) B√ºchi Automaton }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{B√úCHI}\normalsize (F))\newline\text{ we define the (deterministic) Muller automaton } \mathcal{A‚Äô} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\mathcal{F}))\text{ using}$</p><p>$$\mathcal{F}&#x3D;\lbrace S\subseteq Q\mid S\cap F\neq\varnothing\rbrace$$</p></blockquote><p>Since the construction does not modify the transitions, the Muller automaton is again deterministic if the B√ºchi automaton is deterministic. It is straightforward to see that the automata recognize the same language.</p><blockquote><p>$\textbf{Theorem 10.1. } \textit{For every (deterministic) B√ºchi automaton }\mathcal{A}\textit{, there is a (deterministic)}\newline\textit{Muller automaton }\mathcal{A‚Äô}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A‚Äô)}.$</p></blockquote><h3 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h3><p>The automaton $\mathcal{A‚Äô}$ of Construction 10.1 complies with our requirements, according to previous section:</p><p>$$\small\text{B√úCHI}\normalsize (F)&#x3D;\lbrace\alpha\in Q^\omega\mid\text{Inf}(\alpha)\cap F\neq\varnothing\rbrace&#x3D;\lbrace\alpha\in Q^\omega\mid\text{Inf}(\alpha)\in\mathcal{F}\rbrace&#x3D;\small\text{MULLER}\normalsize(\mathcal{F})$$</p><h2 id="Translate-Muller-Automata-into-Buchi-Automata"><a href="#Translate-Muller-Automata-into-Buchi-Automata" class="headerlink" title="Translate Muller Automata into B√ºchi Automata"></a>Translate Muller Automata into B√ºchi Automata</h2><p>A slightly more difficult construction is to translate the Muller automaton back into a B√ºchi automaton.</p><blockquote><p>$\textbf{Construction 10.2. } \text{Let }\mathcal{A} &#x3D; (\Sigma,Q,I,T,\small\text{MULLER} \normalsize (\lbrace F_1,\dots,F_n\rbrace))\text{ be a Muller automaton}\newline\text{and }&lt;\text{ some arbitrary total order on }Q.\text{ We construct the B√ºchi automaton }\mathcal{A‚Äô} &#x3D; (\Sigma,Q‚Äô,\newline I‚Äô,T‚Äô,\small\text{B√úCHI} \normalsize(F‚Äô))\text{ with }\mathcal{A‚Äô}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A‚Äô)}\text{ as follows:}$</p><p>$\begin{array}{llll}<br>\hspace{1cm} \cdot \ Q‚Äô&amp;&#x3D;Q\cup\overset{n}{\underset{i&#x3D;1}{\bigcup}}(\lbrace i\rbrace\times F_i\times F_i)\newline<br>\hspace{1cm} \cdot \ I‚Äô&amp;&#x3D;I\newline<br>\hspace{1cm} \cdot \ T‚Äô&amp;&#x3D;T\cup\lbrace(q,\sigma,(i,q‚Äô,q‚Äô))\mid 1\leq i\leq n,(q,\sigma,q‚Äô)\in T, q‚Äô\in F_i\rbrace\newline<br>&amp;\hspace{0.9cm}{}\cup\lbrace((i,q,p),\sigma,(i,q‚Äô,p‚Äô))\mid 1\leq i\leq n,(q,\sigma,q‚Äô)\in T,\newline<br>&amp;\hspace{1.5cm}p‚Äô&#x3D;\left\lbrace\begin{array}{ll} p &amp;\text{if } q\neq p\newline<br>\text{min}(F_i)&amp;\text{if } q&#x3D;p&#x3D;\text{max}(F_i)\newline<br>\text{min}(F_i\setminus\lbrace r\mid r\leq p\rbrace)&amp;\text{if } q&#x3D;p&lt;\text{max}(F_i),\end{array}\right.\newline&amp;\hspace{1.5cm}q,p,q‚Äô \in F_i\rbrace\newline<br>\hspace{1cm} \cdot \ F‚Äô&amp;&#x3D;\overset{n}{\underset{i&#x3D;1}{\bigcup}}(\lbrace i\rbrace\times \lbrace\text{min}(F_i)\rbrace\times \lbrace\text{min}(F_i)\rbrace)\newline<br>\end{array}$</p></blockquote><h3 id="Explained-in-Human-language"><a href="#Explained-in-Human-language" class="headerlink" title="Explained in Human language"></a>Explained in Human language</h3><p>A run of the B√ºchi automaton first simply simulates (while in states $Q$) the Muller automaton and then ‚Äúguesses‚Äù the accepting subset of the Muller automaton. The accepting subset is express by the states $(\lbrace i\rbrace\times F_i\times F_i)$, where</p><ul><li>The first component &#x3D; the <strong>index</strong> $i$ of the accepting subset,</li><li>The second component &#x3D; the <strong>currently visited state</strong> of the Muller automaton, and</li><li>The third component &#x3D; the <strong>‚Äúnext‚Äù state</strong> (according to the order on the states) we need to see in order to make progress towards accepting the input word.</li></ul><p>The purpose of the order $&lt;$ on the states is that we can ‚Äústep‚Äù through the states of the accepting subset in order to make sure that all states in the accepting subset actually occur infinitely often. In transitions $T‚Äô$, we have the transitions</p><ul><li><p>Transitions for all states $Q$ are described by $T$, same as in the original Muller Automaton,</p></li><li><p>Transitions that contains both states in $Q$ and accepting subset $(\lbrace i\rbrace\times F_i\times F_i)$, it stays in the subset,</p></li><li><p>Transitions inside the subset,</p><ul><li>the <strong>‚Äúnext‚Äù state</strong> remain unchanged until the <strong>currently visited state</strong> visits it $(p&#x3D;q)$,</li><li>if the <strong>currently visited state</strong> visits <strong>‚Äúnext‚Äù state</strong> and it is the last ‚Äústep‚Äù of the subset, it means we visited the entire subset $F_i$ and we should start from the beginning $\text{min}(F_i)$ again.</li><li>otherwise, move one step ahead ($p‚Äô &gt; p$ and $p, p‚Äô\in F_i$)</li></ul></li></ul><p><strong>The B√ºchi automaton accepts if we step through the states of the accepting subset infinitely often</strong>.<br>Recall that we used a similar trick in the construction of the B√ºchi automaton for the <code>intersection</code> of two B√ºchi-recognizable languages in <a href="../agv3-3/">Construction 3.2.</a></p><blockquote><p>$\textbf{Theorem 10.2. } \newline\textit{For every Muller automaton }\mathcal{A}\textit{ there is a B√ºchi automaton }\mathcal{A‚Äô}\textit{ such that }\mathcal{L(A)}&#x3D;\mathcal{L(A‚Äô)}.$</p></blockquote><h3 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h3><blockquote><p>$\mathcal{L(A)}\subseteq\mathcal{L(A‚Äô)}$ (all word accepted by $\mathcal{L(A)}$ must also be accepted by $\mathcal{L(A‚Äô)}$):</p></blockquote><p>Let $\alpha\in\mathcal{L(A)}$ and $r&#x3D;q_0q_1q_2\dots$ be an <strong>accepting</strong> run of $\mathcal{A}$ on $\alpha$. As $r$ is accepting, we have that:</p><ul><li><p>$\text{Inf}(r)\in\mathcal{F}$, so $r$ must be in one of the accepting subset, i.e. $\text{Inf}(r)&#x3D;F_i$ for some $1\leq i\leq n$,</p></li><li><p>Let $m$ be the first position that visit some accepting state: $q_j\in\text{Inf}(r)$ for all $j\geq m$,</p></li><li><p>Now consider some run of $\mathcal{A‚Äô}$ on $\alpha:\ r‚Äô &#x3D; q_0q_1\dots q_{m‚àí1}(i, q_m, p_0)(i, q_{m+1}, p_1)(i, q_{m+2}, p_2)\dots$</p><ul><li>it nondeterministically switches to $(i, q_m, p_0)$ at position $m$.</li></ul></li></ul><p>For the sake of contradiction, assume that $r$ is <strong>not accepting</strong>:</p><ul><li>Then there is a position $k\geq 0$ such that $p_j&#x3D;p_k$ for all $j\geq k$ ($q$ never moves to $p_k$,<strong>‚Äúnext‚Äù state</strong> got stuck).</li><li>Then also $q_{m+j}\neq p_j$ for all $j\geq k$. However, this contradicts that $p_k\in F_i$.<br>(if q can never reach $p_k$, then it is not an accepting state and thus contradicts with the definition of the subset)</li></ul><blockquote><p>$\mathcal{L(A)}\supseteq\mathcal{L(A‚Äô)}$ (all word accepted by $\mathcal{L(A‚Äô)}$ must also be accepted by $\mathcal{L(A)}$):</p></blockquote><p>Let $\alpha\in\mathcal{L(A‚Äô)}$, $r‚Äô &#x3D; q_0q_1\dots q_{m‚àí1}(i, q_m, p_0)(i, q_{m+1}, p_1)(i, q_{m+2}, p_2)\dots$ be some accepting run of $\mathcal{A‚Äô}$ on $\alpha$:</p><ul><li>At some position $m$ it switches to some $(i, q_m, p_0)$, otherwise it would not be accepting.</li><li>By construction, $q_j\in\text{Inf}(r)$ for all $j\geq m$ (it starts staying in the accepting subset), and</li><li>For each $p\in F_i$ there are infinitely many positions $k$ such that $q_k&#x3D;p_k&#x3D;p$.<ul><li>($q$ always reach every <strong>‚Äúnext‚Äù state</strong> infinitely often at some positions)</li></ul></li></ul><p>Thus, we can construct an accepting run $r&#x3D;q_0q_1q_2\dots$ of $\mathcal{A}$ on $\alpha$ by using every $q$ state in the run $r‚Äô$, because every second component in the tuple is accepting, i.e. $\text{Inf}(pr_2(r‚Äô))&#x3D;p_k&#x3D;F_i$,</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Now we have proved that we can construct an Muller automaton from B√ºchi automaton and an B√ºchi automaton from Muller automaton. Therefore they are interchangably equivalent. In the next section, we will prove that deterministic Muller automata are actually closed.</p><hr><p>Next chapter: <a href="../agv10-3/">Closure Properties of Muller Automata under Boolean Operations</a></p><p>Further Reading: <a href=""></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Previous chapter: &lt;a href=&quot;../agv10-1/&quot;&gt;The Muller Acceptance Condition&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a learning note of a course in &lt;a</summary>
      
    
    
    
    <category term="Notes" scheme="https://greenmeeple.github.io/categories/Notes/"/>
    
    <category term="UdS" scheme="https://greenmeeple.github.io/categories/Notes/UdS/"/>
    
    
    <category term="AGV" scheme="https://greenmeeple.github.io/tags/AGV/"/>
    
  </entry>
  
</feed>
