{"posts":[{"title":"Appium commands that are commonly used on Mac","text":"In this example, we will use Appium Inspector to start a seesion on your emulator on Android Studio. Start appium First, start the connection with Appium by cmd appium --allow-cors. It also gives you the remote url and the automationName that can be used in the Appium Inspector Start Session deviceName: adb devices platformName - appium driver list platformVersion - adb shell getprop ro.build.version.release Now you can start a session in your emulator, but it always begins from the home page. To directly start a session on certain App, you also need to provide the appPackage and the appActivity. Session with AppsIf your app is downloaded from the PlayStore. It is possible that the apk file name/path is hidden. However, you can You can simply open the app and check its name by adb shell dumpsys window | grep mCurrentFocus. It returns the appPackage and the current appActivity of the App, which are both necessary for our seesion to start. However, sometimes the current activity may not be directly opened. Then we need to check all the possible activities this App contans and try them out. To check the activity list, we can use adb shell dumpsys package YOUR_APP_appPackage | grep -i activity. Now, we can start our emulator, and run the command adb shell am start -n YOUR_APP_appPackage/YOUR_APP_appActivity to see whether it can start the App successfully. If it works we can use it in our inspector.","link":"/appium/"},{"title":"Why you shouldn&#39;t deploy your Hexo webpage using GitHub Desktop?","text":"Methods to Deploy Hexo to GitHub.ioAssume you’ve created a repository on GitHub called &lt;username&gt;.github.io. Here are two common method you can deploy you Hexo Blog: Hexo CommandHexo’s documentations and Tutorial has provided sufficient instructions on deploying your personal website on your GitHub repository. According to the Hexo Tutorial, we can deploy the repository by using GitHub Actions. Create and Add the following contents to .github/workflows/pages.yml: name: Pages on: push: branches: - main # default branch jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 with: token: ${{ secrets.GITHUB_TOKEN }} submodules: recursive - name: Use Node.js 20 uses: actions/setup-node@v4 with: # Examples: 20, 18.19, &gt;=16.20.2, lts/Iron, lts/Hydrogen, *, latest, current, node # Ref: https://github.com/actions/setup-node#supported-version-syntax node-version: &quot;&gt;=20&quot; - name: Cache NPM dependencies uses: actions/cache@v4 with: path: node_modules key: ${{ runner.OS }}-npm-cache restore-keys: | ${{ runner.OS }}-npm-cache - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Upload Pages artifact uses: actions/upload-pages-artifact@v3 with: path: ./public deploy: needs: build permissions: pages: write id-token: write environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 Install hexo-deployer-git. Add/Change the following configurations to _config.yml: deploy: type: git repo: https://github.com/&lt;username&gt;/&lt;project&gt; # for example, this blog is https://github.com/greenmeeple/greenmeeple.github.io branch: gh-pages After finishing your bog posts, Run hexo clean &amp;&amp; hexo deploy. GitHub DesktopMany Users installed GitHub Desktop for better visualization on changes, so do I. It provides more intuitive push and commit procedure and instruction compared to terminal. Most of the time I use it to make sure no unexpected line changes or modification. But soon I noticed that, every time after running hexo clean &amp;&amp; hexo deploy, GitHub Desktop will warn me that there’s something need to be pulled. When I pull it for merging it return Unable to merge unrelated histories in repository. Even in the image above, it shows that I should pull something. However, how would I need to pull if I’ve just push it? Security ProblemSo I inspect my repository, these two method actually deploy completely different content to the repository, even though they output the identical content on the webpage. When you deploy you webpage with Hexo command, it actually creates a folder .deploy_git, which is static HTML content without showing any configurations like your themes folder or _config.yml folder. In contrast, GitHub Desktop solely commit all folder that is not in .gitignore file and the website just rendered dynamically in the repository when someone visit. This create a huge security problem as much as it seems. All contents in your config is now visible to everyone. Since Hexo is a simple framework that depends heavily on Markdown and .yml files, there’s on where to hide all your settings and &lt;script&gt; if they just directly commit to your repository before building it statically. This may include not only your SEO and functionality of your webiste, but even some secret variable. GitTalk comment section and GitHub OAUTHFor example, the comment section below every posts in this blog are powered by GitTalk. It requires users to login through GitHub to comment. In order to handle the authorization of login, blog owners need to create an OAUTH App. Then they need to input their clientID and clientSecret initiate the plugin. For Hexo file structure, this will usually be stored in _config.yml. Therefore, if Blog Owner simply commit the whole folder using GitHub Desktop, their OAUTH App credentials are leaked to everyone. And this is how I start noticing the two deploy methods above are so different. Saving your sensitive information from Data Leak?As you may know, once you commit your issue on GitHub, it will leave a trace. This is because the version control nature of GitHub. But that also means everyone can always inspect your repositories’ history, even your newest version already removed your leaked data. Other than deleting your repository and start all over again, you may also cover and rewrite your commit history, and even rewrite the content by following this. Further Reading: Environment variable, How to push code to Github hiding the API keys?","link":"/github-desktop/"},{"title":"Using Hexo Scripts functions to create a custom Tag Plugin","text":"To color your personal Hexo Blog with more features, scripts and plugins are your powerful tools to use. Below we are trying to create our own tag plugin for the Hexo blog. Tag Plugin Be careful! Tag plugins are different from post tags. Tag plugins are special type of syntax that you may use in your Markdown file. Hexo has already provided some default Tag plugins like Block Quote and iframe. UsageFor example, the syntax of iframe tag is: {% iframe url [width] [height] %} Let say I want to embed a video from me and my friends’ YouTube video: {% iframe https://www.youtube.com/embed/XIOl6BU7s9I?si=yTYsHIXNM6o-Zl9Z 820 461%} And that’s how it looks like: ScriptLet say we want to create our own tag plugin, we can use the Hexo script function. Here’re the steps. Create a JavaScript file with function hexo.extend.tag.register(&quot;tag_name&quot;, args). You may also put your own function inside so that the second argument can also be function (args){} Here is an example of a function that create a tag named youtube, with embedding video function: hexo.extend.tag.register(&quot;youtube&quot;, function (args) { var id = args[0]; return ( '&lt;div class=&quot;video-container&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/' + id + '&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;' ); }); Put your JavaScript files in the scripts folder. If your project folder is new, you may not be able to find it. This is because scripts folder is actually under the Themes folder. You may check here to see the structure of themes and create your own one. Or you may be simply find a template on the Hexo themes community then put your .js file into the theme. It is done! Hexo will load them during initialization and you may use them in your blog post designs. Beyond ScriptsIf you are not satisfied with creating a local tag plugin, but a public one that will be seen by the community, you should consider using Hexo plugin function instead. check here to continue the journey. Further Reading: Hexo Plugins and Scripts Hexo Tag Plugins Hexo Tag Api Hexo Plugins Community","link":"/js/hexo-tagplugin-1/"},{"title":"Using Hexo Plugin functions to create a custom Tag Plugin","text":"Disclaimer: For explaination on Tag Plugin and Scripts in Hexo, you may take a look of this post. Plugin Be Careful! Don’t mix Plugin, Tag, and Tag Plugin in Hexo, even though they look extremely similar. Usually, Plugin are for complicated functions. Yet if you want to publish your custom Tag Plugin to the NPM registry or even shown on the Hexo Community Page, Plugin would be a very good choice. From Script to PluginAssume you already have a script call index.js, and you want to turn it into package, you may do the following: Navigate node_modules folder in your project folder. This is the folder where Hexo stored all the packages for your blog. Create a folder inside and the name must begin with hexo- or Hexo will ignore it. Your folder must contain at least two files: the actual JavaScript code and package.json file that describes the purpose of the plugin and sets its dependencies. . ├── index.js └── package.json In package.json, it should at least have the name, version and main entries set. { &quot;name&quot;: &quot;hexo-my-plugin&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;main&quot;: &quot;index&quot; } In the root package.json of your hexo project, you also need to list your plugin as a dependency, for Hexo to detect and load it. Please remember that if your package contain other dependencies, also install and list them for testing and dubugging. { &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot; }, &quot;hexo&quot;: { &quot;version&quot;: &quot;&quot; }, &quot;dependencies&quot;: { &quot;hexo&quot;: &quot;^7.3.0&quot;, ... &quot;hexo-my-plugin&quot;: &quot;0.0.1&quot;, &quot;my-plugin-dependency1&quot;: &quot;2.0.0&quot;, &quot;my-plugin-dependency2&quot;: &quot;2.0.0&quot; } } If you run command that check all the package after step 4, for exmaple hexo clean, it will check all the packages in node_modules and remove packages that are not publish on npm. Publish Plugin to npmTo publish your package on the NPM registry, don’t forget you have to setup your account on npm first. After creating the account, open your terminal and run npm login in the root of your package. Enter your username and password, then you should see a message like this if login is successful, Logged in as &lt;your-username&gt; on https://registry.npmjs.org/. Once you logged-in, you may simply publish your folder with npm publish command. Publish Plugin to HexoAfter publish your plugin package in npm, you can also publish it to Hexo official. Fork and CloneFirst of all, Fork hexojs/site from Github Then Clone the repository to your computer and install dependencies. $ git clone https://github.com/&lt;username&gt;/site.git $ cd site $ npm install Add your Plugin to the listCreate a new yaml file in source/_data/plugins/, use your plugin name as the file name Edit source/_data/plugins/&lt;your-plugin-name&gt;.yml and add your plugin. For example: Push the branchCreate a pull request and describe the change. Hexo official create a nice form to make sure you have included everything needed. ResultsYou may check the progress on the pull requests history.Once it is closed you can see your plugin on the Hexo Plugins Community. Example workAs you may see, I also made my Plugin “Hexo-zhruby” for Hexo and you can now see it on the community.For more details and see how it works, you may check here. Further Reading: Hexo Plugins and Scripts Hexo Tag Plugins Hexo Plugins Community npm-publish","link":"/js/hexo-tagplugin-2/"},{"title":"Railroad Diagram of version range operators","text":"This is a image version of the post here range-set: range-set ::= range ( logical-or range )* logical-or: logical-or ::= ' '* '||' ' '* referenced by: range-set range: range ::= hyphen | simple ( ' ' simple )* | '' referenced by: range-set hyphen: hyphen ::= partial ' - ' partial referenced by: range simple: simple ::= primitive | partial | tilde | caret referenced by: range primitive: primitive ::= ( '&lt;' | '&gt;' | '&gt;=' | '&lt;=' | '=' ) partial referenced by: simple partial: partial ::= xr ( '.' xr ( '.' xr qualifier? )? )? referenced by: caret hyphen primitive simple tilde xr: xr ::= 'x' | 'X' | '*' | nr referenced by: partial nr: nr ::= '0' | ['1'-'9] ['0'-'9]* referenced by: part xr tilde: tilde ::= '~' partial referenced by: simple caret: caret ::= '^' partial referenced by: simple qualifier: qualifier ::= ( '-' pre )? ( '+' build )? referenced by: partial pre: pre ::= parts referenced by: qualifier build: build ::= parts referenced by: qualifier parts: parts ::= part ( '.' part )* referenced by: build pre part: part ::= nr | [-0-9A-Za-z]+ generated by RR - Railroad Diagram Generator","link":"/js/json-dependencies-diagram/"},{"title":"Explaination of version range operators in package.json for package dependencies","text":"To see the syntax and Railroad diagram version, goto here Basic StructurePackage dependecies are a tuple of [major, minor, patch] with numeric values. { &quot;name&quot;: &quot;project name&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;description of the project&quot;, &quot;keywords&quot;: [ &quot;keyword 1&quot;, &quot;keyword 2&quot; ], &quot;author&quot;: &quot;John Doe&quot;, &quot;dependencies&quot;: { &quot;package-1&quot;: &quot;~0.6.2&quot;, &quot;package-2&quot;: &quot;&gt;=2.6.2&quot; } } Version Range operatorBasic RangeFor x in exmaple, see Advanced Range below. Operator Explaination Example = package version must be exactly matched 1.0.0 := =1.0.0(They are equivalent) &lt; package version must be less than indicated &lt;2.0.0 :=version from 0.0.1 to 1.x.x &lt;= package version must be less than or euqal to indicated &lt;=2.0.0 :=version from 0.0.1 to 2.0.0 &gt; package version must be greater than indicated &gt;2.0.0:= version from 2.0.1 to x (x &gt;= 2) &gt;= package version must be greater than or euqal to indicated &gt;=2.0.0 :=version from 2.0.0 to x (x &gt;= 2) || joined one or more operator &gt;2.0.1 || &lt;1.7.3 :=version greater than 2.0.1 or less than 1.7.3 space Intersected one or more operator &gt;=2.0.1 &lt;=1.7.3 :=version from 2.0.1 to 1.7.3 (inclusive) Advanced RangeAdvanced ranges may be combined in the same way as primitive comparators using space or ||. Operator Explaination Example X, x, * A Wildcard may be used for any values in the [major, minor, patch] tuple (missing value are consider using Wildcard x) * := (empty string) := &gt;=0.0.01.x.x := 1.x := 1 := &gt;=1.0.0 &lt;2.0.0 - Specifies an inclusive set of package version 1.2 - 2.3.4 := &gt;=1.2.0 &lt;=2.3.4 (missing pieces of first version are replaced with zeroes)1.2.3 - 2.3 := &gt;=1.2.3 &lt;2.4.x(missing pieces of second version replace with X-range) ~ Allows patch or minor level version changes, depends on specification ~1.2.3 := any version starts with 1.2 and greater than 1.2.3~1.2 := any version starts with 1.2 (same as 1.2.x) ^ Allows version changes in the [major, minor, patch] tuple without modify the left-most non-zero element. ^1.2.3 := &gt;=1.2.3 &lt;2.0.0(minor update)^0.2.3 := &gt;=0.2.3 &lt;0.3.0 (patch update)^0.0.3 := &gt;=0.0.3 &lt;0.0.4(no updates) Further Explaination on Caret Ranges ^Special interaction with Wildcard operator xWhen parsing caret ranges, minor and patch values with wildcard x desugars to the number 0 (missing values are consider as x): Example: ^1.2.x := &gt;=1.2.0 &lt;2.0.0-0 (equivalent to ^1.2.0) ^1.x := &gt;=1.0.0 &lt;2.0.0-0 (equivalent to ^1.0.0) However, when both major and minor versions are 0, Caret range allow flexibility within wildcard x: Example: ^0.0.x := &gt;=0.0.0 &lt;0.1.0-0 (NOT equivalent to ^0.0.0, but similar to ^0.1.0) Usage and Common PracticesCaret ranges usually ideally used when an author may make breaking changes. For example, between 0.2.4 and 0.3.0 releases, which is a common practice. However, it presumes that there will not be breaking changes between 0.2.4 and 0.2.5. It allows for changes that are presumed to be additive (but non-breaking), according to commonly observed practices. Further Reading: version range in npm-semver, setup-node in GitHub Actions","link":"/js/json-dependencies/"},{"title":"Automata, Games, and Verification (Portal)","text":"This is a learning note of a course in CISPA, UdS. Taught by Bernd Finkbeiner Chapter 1. Introduction Sections Exercise 1.1. Model Checking 1.2. Synthesis 1.3. The Logic-Automata Connection Chapter 2. Büchi Automata Sections Exercise 2.1. Preliminaries 2.2. Automata over Infinite Words 2.3. The Büchi Acceptance Condition Chapter 3. Büchi’s Characterization Theorem Sections Exercise 3.1. Kleene’s Theorem 3.2. $\\omega$-regular language 3.3 Closure Properties of the Büchi-recognizable languages (Intersection and Union) 3.4 Closure Properties of the Büchi-recognizable languages (Concatenations) 3.5 Büchi’s Characterization Theorem Chapter 4. Deterministic Büchi Automata Sections Exercise 4.1. Deterministic vs. Nondeterministic Büchi Automata 4.2. Complementation of deterministic Büchi Automata Chapter 5. Complementation of Büchi automata Sections Exercise 5.1. Infinite Directed Acyclic Graph (DAG) 5.2. Ranking of DAG 5.3. Complement Büchi Automaton with Odd Ranking Chapter 6. Logics over Infinite Sequences Sections Exercise 6.1. Linear-Time Temporal Logic (LTL) 6.2. Expressing Program Properties using LTL 6.3. LTL and Counting Languages 6.4. Quantified Propositional Temporal Logic (QPTL) 6.5. Monadic Second-Order Logic of One Successor (S1S) 6.6. Express QPTL using S1S 6.7. S1S$_0$ and Büchi-recognizable LanguageBüchi-recognizable Chapter 7. Alternating Büchi Automata Sections Exercise 7.1. Alternating Büchi Automata 7.2. From LTL to Alternating Büchi Automata $\\varphi=(\\Diamond p)\\ \\mathcal{U}\\ (\\square q)$ 7.3. Translating Alternating to Nondeterministic automata Chapter 8. Linear Arithmetic Sections Exercise 8.1. Linear Arithmetic (Theory) 8.2 Encoding real numbers 8.3 Translation from Linear Arithmetic to Automata 8.4 Homogenous Inequality Testing is Automatic 8.5 From Linear Arithmetic to Automata Chapter 9. LTL Model Checking Sections Exercise 9.1 Automata-based LTL Model Checking with Sequential Circuits 9.2 Nested depth-first search 9.3 The Emerson-Lei algorithm Chapter 10. McNaughton’s Theorem Sections Exercise 10.1 The Muller Acceptance Condition 10.2 From Büchi automata to Muller automata 10.3 Closure Properties of Muller Automata under Boolean Operations Further Reading:","link":"/notes/agv/"},{"title":"Leetcode SQL 50 (Portal 🚪)","text":"This is a portal for my walkthroughs of SQL 50 on Leetcode Link of Leetcode SQL 50 Select 1757. Recyclable and Low Fat Products 584. Find Customer Referee 595. Big Countries 1148. Article Views I 1683. Invalid Tweets Basic Joins 1378. Replace Employee ID With The Unique Identifier 1068. Product Sales Analysis I 1581. Customer Who Visited but Did Not Make Any Transactions 197. Rising Temperature Advanced String Functions / Regex / Clause 1667. Fix Names in a Table 1527. Patients With a Condition 196. Delete Duplicate Emails 176. Second Highest Salary 1484. Group Sold Products By The Date 1327. List the Products Ordered in a Period 1517. Find Users With Valid E-Mails","link":"/notes/sql50/"},{"title":"🍽 🥨 MensaarLecker -- A beloved tool to find out Mensa Ladies&#39; favourite menu using Selenium🥨 🍽","text":"Repository: MensaarLecker As an UdS Student,Are you tired of seeing french fries🍟 3 times a week, or wondering when I can have the best pizza 🍕 in the Mensacafe?MensaarLecker aims to collect all the data from Menu 1, 2, and Mensacafe to trace your favourite, or Mensa Ladies’, favourite menu! 🆕 Updates05.08 – Telegram Bot @Mensaar_Bot are published. (See my development blog in here! MensaarLecker Development Log 3 – Telegram Bot Deployment and Integration) 04.21 – https://mensaar.de/#/menu/htwcrb menus are now added to the statistics. 🥗 DescriptionA fully automated scraper and static website for the Saarbrücken Mensa, powered by Python, Selenium, Google Sheets, and GitHub Actions. Get a clean and daily-updated overview of meals from mensaar.de, with searchable history, meal components, and frequency stats. 🌐 Live Demo👉 View Website👉 View Data in Google Sheets 📅 Features ✅ Scrapes the Saarbrücken Mensa daily menu ✅ Publishes structured data to a connected Google Sheet ✅ Generates static HTML pages: index.html – Today’s menu with meal frequency counts menu.html – Full searchable menu with DataTables ✅ Automatically updates via GitHub Actions at 10:00 AM UTC on weekdays ✅ Beautiful card-style layout &amp; component display ✅ No server required — 100% static 🧠 Meal Frequency Display ExampleThe homepage shows how often each meal has been served based on historical data since 2025.03.20: 🍽️ Pasta mit Tomatensoße📊 Seen since 2025.03.20✅ Geriebener Käse✅ Rucola 📁 Project Structure. ├── Mensaar_scraper.py # Scrapes from mensaar.de and writes to Google Sheet ├── generate_menu.py # Reads the sheet and generates index.html and menu.html ├── credentials.json # Google service account key (excluded from repo) ├── index.html # Main website page with today's menu ├── menu.html # Full searchable table of meals ├── .github/workflows/ │ └── update_menu.yml # GitHub Actions automation ├── src/ │ └── uds_spirit.jpg # Soul of this project └── README.md 📝 Development LogMensaarLecker Development Log 1 – Web CrawlingMensaarLecker Development Log 2 – Web Developing and GitHub WorkflowMensaarLecker Development Log 3 – Telegram Bot Deployment and Integration","link":"/projects/mensaar/"},{"title":"hexo-zhruby -- Implementing HTML Ruby tag in Hexo","text":"Implement the HTML tag &lt;ruby&gt; for Hexo using Tag Plugin feature. Provide auto pronounciation indication for Jyutping (Cantonese), Zhuyin (Taiwanese Mandarin), and Pinyin (Chinese Mandarin), and the default setting for general usage. Support Traditonal and Simplified Chinese characters. Inspired by the hexo-ruby-character by jamespan. Installnpm install hexo-zhruby --save Use casesRuby (ルビ) is also known as Furigana (振り仮名). It contains two basic use cases: To clarify or indicate the pronunciation for readers Gikun, in which the characters have different pronunciations than they seem due to convention or for a specific context. For example, the pronunciation of 煙草 in Japanese is tabako (tobacco). UsageTLDR: Usage: {% tag rb|rt %}; Tag options: ruby_def, ruby_jy, ruby_py, ruby_zy. For the 1st use case (pronunciation indication):ruby_def allows any language, and the spacing in rp will expand evenly with respect to the word length in rt. {% ruby_def 基本|きほん %} → 基本 (きほん) {% ruby_def 基本|기본 %} → 基本 (기본) {% ruby_def 基本|fundamental %} → 基本 (fundamental) {% ruby_def 基本|θεμελιώδες %} → 基本 (θεμελιώδες) {% ruby_def 基本|базовый %} → 基本 (базовый) {% ruby_def 基本|základní %} → 基本 (základní) {% ruby_def fundamental|基本 %} → fundamental (基本) ruby_jy, ruby_py, ruby_zy refers to Jyutping, Pinyin, Zhuyin respectively. No need to enter the pronunciation manually in rt; the value will automatically be returned. {% ruby_zy 基本 %} → 基本 (ㄐㄧ ㄅㄣˇ) {% ruby_py 基本 %} → 基本 (jī běn) {% ruby_jy 基本 %} → 基本 (gei1 bun2) For the 2nd use case (Gikun):Same usage for ruby_def. {% ruby_def special|basic %} → special (basic) {% ruby_def 特別|基本 %} → 特別 (基本) In ruby_jy, ruby_py, ruby_zy, you can also add |rt just like ruby_def. {% ruby_zy 特別|special %} → 特別 (special) {% ruby_py 特別|special %} → 特別 (special) {% ruby_jy 特別|special %} → 特別 (special) {% ruby_zy 特別|基本 %} → 特別 (ㄐㄧ ㄅㄣˇ) {% ruby_py 特別|基本 %} → 特別 (jī běn) {% ruby_jy 特別|基本 %} → 特別 (gei1 bun2) Notice that the rt output depends on the pronunciation in rt, but not rp. This feature is only available when rt is a Chinese Character in CJK Unified Ideographs (\\U4E00-\\U9FFF). If the input of rt is not in CJK Unified Ideographs, it is considered as ruby_def. Known issuesThe Chinese language contains a lot of Homophones, which can be resolved by context most of the time. However, for long sentences (&gt;= 15 characters), or very specific names and terms, the auto-generation from 1st use case may not be very sensitive. Please use ruby_def if it happens or contribute to this project by providing a more sensitive or advanced Chinese vocabulary library. References CJK Unified Ideographs (Unicode block) Homophone Gikun (japanese only) Gikun (English version under the article Kanji) &lt;ruby&gt;: The Ruby Annotation element Unicode/Character reference Universal Character Set characters (Unicode)","link":"/projects/hexo-zhruby/"},{"title":"MensaarLecker Development Log 1 -- Web Crawling","text":"This blog post is trying to tell you: My personal experience when developing a web crawler using Selenium Explained with examples from my Repository: MensaarLecker MotivationMe and my friends hatelove the UdS Mensa so much! The infinite frozen food and french fries menus give us so much energy and motivation for the 5-hour afternoon coding marathon. However, no one actually knows how many potatoes they have exterminated throughout the week. We have a genius webpage created by some Schnitzel lover. Personally, I like its minimalistic layout and determination on Schnitzel searching. However, we want more. It’s not just Schnitzel; we want to know everything about their menu. We want to know what’s inside the mensa ladies’ brains when they design next week’s menu. The desire never ends. We need more data, more details, more, More, MORE! Developing ProcessOur Goal here is simple: Scrape the Mensa menu every weekday and store it to Google Sheets Fetch the Data Collection from Google Sheets and update the website Web ScrapingTo collect the data, we can use Python libraries to simplfied the process. But the basic idea it the same: we try to find the pattern of the HTML tag and locate the desired data. Beautiful SoupI started my journey with Beautiful Soup, one of the most popular Python web scraper packages. However, as a Uni that is well-known for its computer science program, all the menus are rendered using JavaScript. And beautiful can only scrape HTML and XML tags. So the scraper can only see an empty skeleton page: SeleniumBasically, Selenium is a Webdriver that opens a browser naturally, like a human user. Then from there we can scrape the rendered information. Things get simpler once we can see the website as we see it on the browser. We just need to find the tag that contains the information we need and save it for storage. Desired Data and Tags Data Tag menus &lt;div class=&quot;counter&quot;&gt; date &lt;div class=&quot;cursor-pointer active list-group-item&quot;&gt; main dish &lt;span class=&quot;meal-title&quot;&gt; side dish &lt;div class=&quot;component&quot;&gt; The first part of the task is to get the daily menu. We also get the date on the website to make the following work easier. By the find_element and find_elements functions in Selenium, we can create a simple scraper like this: from selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.webdriver.common.by import By driver = webdriver.Firefox() driver.get(&quot;https://mensaar.de/#/menu/sb&quot;) counters = driver.find_elements(By.CLASS_NAME, &quot;counter&quot;) for counter in counters: meal_title = meal.find_element(By.CLASS_NAME, &quot;meal-title&quot;).text.strip() However, on the webpage there is also a counter called Wahlessen. Which refers to a more pricy and unpredictable menu, and we want to exclude its data: counter_title = counter.find_element(By.CLASS_NAME, &quot;counter-title&quot;).text.strip() # Filter for specified counter titles if counter_title in [&quot;Menü 1&quot;, &quot;Menü 2&quot;, &quot;Mensacafé&quot;]: meal_title = meal.find_element(By.CLASS_NAME, &quot;meal-title&quot;).text.strip() StorageIn order to make the database easy to be accessed by other users/students, we decided to deploy the data set to Google SpreadSheets. with open(output_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: json.dump(result, f, ensure_ascii=False, indent=2) print(f&quot;Results saved to {output_file}&quot;) # Save the updated occurrence counts to the JSON file count_result = { &quot;meal_counts&quot;: dict(meal_count), &quot;component_counts&quot;: dict(component_count) } with open(count_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: json.dump(count_result, f, ensure_ascii=False, indent=2) print(f&quot;Counts saved to {count_file}&quot;) Change the time formatOnce we fetch data, you may notice that the website display the date in german format e.g. “Freitag, 21. März 2025”, which is not recognized by Google Sheets directly. So we need to make a function to convert them before uploading: GERMAN_MONTHS = { &quot;Januar&quot;: &quot;01&quot;, &quot;Februar&quot;: &quot;02&quot;, &quot;März&quot;: &quot;03&quot;, &quot;April&quot;: &quot;04&quot;, &quot;Mai&quot;: &quot;05&quot;, &quot;Juni&quot;: &quot;06&quot;, &quot;Juli&quot;: &quot;07&quot;, &quot;August&quot;: &quot;08&quot;, &quot;September&quot;: &quot;09&quot;, &quot;Oktober&quot;: &quot;10&quot;, &quot;November&quot;: &quot;11&quot;, &quot;Dezember&quot;: &quot;12&quot; } def format_date(german_date): match = re.search(r&quot;(\\d{1,2})\\. (\\w+) (\\d{4})&quot;, german_date) if match: day, month, year = match.groups() month_number = GERMAN_MONTHS.get(month, &quot;00&quot;) return f&quot;{year}-{month_number}-{int(day):02d}&quot; return &quot;0000-00-00&quot; Upload the data to Google SheetsIn order to interact with the Google Sheets, we need to use Google API. First, go to Google Cloud Console. Create a new project. Next, go to API and Services, click Enable API and Services Search Google Sheets API, select it and choose Enable。 Move Credentials from the sidebar, then choose Create credentials → Create service account In step 2, choose the role Editor Now, when you come back to the Credentials page, you should see a newly generated email under Service Accounts, click it and select the tab Keys Select Create new key, choose JSON format, the file should start downloading automatically. Important NoticeThis JSON file contains sensitive data, you should NEVER directly use it in your code, save it as an environment variable or save it as a secret on Github With this key we can login the email we just created in Service Accounts, so that it is treated as a virtual users when running the script. Same as human users, in order to access the sheet we need to add this email as an editor in Google Sheets. try: # Read and validate credentials.json before using it if not os.path.exists(&quot;credentials.json&quot;): print(&quot;❌ credentials.json not found!&quot;) return with open(&quot;credentials.json&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: raw_creds = f.read() creds_data = json.loads(raw_creds) # Save to a temp file just in case gspread needs it as a file temp_path = &quot;parsed_credentials.json&quot; with open(temp_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: json.dump(creds_data, f) creds = ServiceAccountCredentials.from_json_keyfile_name(temp_path, scope) client = gspread.authorize(creds) sheet = client.open(SHEET_NAME).sheet1 print(&quot;✅ Google Sheets Auth OK&quot;) End of ScrapingNow we all set! Next, we need to display our collected results on web interfaces. Continue Reading: MensaarLecker Development Log 2 – Web Developing and GitHub Workflow","link":"/projects/mensaarlog1/"},{"title":"MensaarLecker Development Log 2 -- Web Developing and GitHub Workflow","text":"This blog post is trying to tell you: My personal experience when developing a web crawler using Selenium Explained with examples from my Repository: MensaarLecker Fetching Data from Web DevelopmentPrevious post: MensaarLecker Development Log 1 – Web Crawling Continuing from last post, we have already implemented a script that collect the Mensa menu and stored it on Google Sheets. It is time to build our web interface to connect the database. Fetch Data from Google Sheets using PublishFirst, we need to publish our spreadsheet so that it is public to fetch the data. In the Spreadsheet, click Share → Change access to Anyone with the link. Click File → Share → Publish to the web. Select Entire Document → Comma-separated values (.csv) and click Publish. Copy the public CSV link. SCRIPT_URL = {PUBLISH_LINK} # Fetch JSON data def fetch_menu(): try: response = requests.get(SCRIPT_URL) response.raise_for_status() # Raise error if bad response return response.json() except requests.exceptions.RequestException as e: print(f&quot;❌ Error fetching menu: {e}&quot;) return [] However, the script return no data, why? Access to fetch at 'https://docs.google.com/spreadsheets/...' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled. CORS Policy and XSS Cross-origin resource sharing (CORS) is an extension of the same-origin policy. You need it for authorized resource sharing with external third parties. – Amazon Web Services This is a cyber security scheme to avoid XSS (Cross-site scripting), in a nutshell, when we run the script, the code cannot proceed because it doesn’t login to any Google account! You can imagine the request is block by a imaginary login page and our program doesn’t know how to react. Second Attempt – Google Apps ScriptGoogle doesn’t allow users to fetch their data casually, except this is executed under Google’s server. This means we need to run our fetching function using Google’s service. Apps Script provide a JavaScript editor to save your code. function doGet() { var sheet = SpreadsheetApp.openById(&quot;PUT_YOUR_SHEET_ID_HERE&quot;).getActiveSheet(); var data = sheet.getDataRange().getValues(); var headers = data[0]; var jsonData = []; for (var i = 1; i &lt; data.length; i++) { var row = {}; for (var j = 0; j &lt; headers.length; j++) { row[headers[j]] = data[i][j]; } jsonData.push(row); } var output = ContentService.createTextOutput(JSON.stringify(jsonData)); output.setMimeType(ContentService.MimeType.JSON); return output; } To get the sheet ID, we can simply open the sheet and it is part of the URL: Deploying the function and fetch the dataAfterwards, we can deploy this function and it will generate a unique URL for the function output and we can fetch the data (here we export the data in json format) and use it in our code. You can also double check the URL and make sure it does return the value correctly → link SCRIPT_URL = &quot;URL_DEPLOYED_FROM_APP_SCRIPT&quot;; # Fetch JSON data def fetch_menu(): try: response = requests.get(SCRIPT_URL) response.raise_for_status() # Raise error if bad response return response.json() except requests.exceptions.RequestException as e: print(f&quot;❌ Error fetching menu: {e}&quot;) return [] Webpage ImplementationTo simplify our automation process on GitHub, we will continue implement our HTML code using Python. Our website should have two pages: index.html contains today’s menu, and menu.html contains the history of collected menus. Static data – Tripe QuotesWe can put all the static code in strings. In Python we can store multi-line strings using triple quotes. html = f&quot;&quot;&quot;&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Mensaar Today&lt;/title&gt; &lt;style&gt; body {{ font-family: Arial, sans-serif; padding: 20px; text-align: center; background-image: url('src/uds_spirit.jpg'); }} h1 {{ background: rgba(255, 255, 255, 0.8); color: #003C71; padding: 10px 20px; display: inline-block; border-radius: 10px; box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2); }} .container {{ width: 80%; margin: auto; }} .closed-message {{ font-size: 26px; color: red; font-weight: bold; padding: 20px; background: #fff3f3; border-radius: 10px; }} .menu-card {{ background: white; padding: 15px; margin: 10px 0; border-radius: 10px; box-shadow: 2px 2px 10px rgba(0,0,0,0.1); text-align: left; }} .meal-title {{ font-size: 20px; font-weight: bold; }} .meal-components {{ font-size: 16px; color: #666; }} .meal-frequency {{ font-size: 14px; color: #888; font-style: italic; }} .button {{ padding: 12px 20px; background: #007bff; color: white; border-radius: 5px; text-decoration: none; }} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Mensaar Menu for {today}&lt;/h1&gt;&lt;/br&gt; &lt;a href=&quot;menu.html&quot; class=&quot;button&quot;&gt;📜 View Full Menu&lt;/a&gt; &lt;div class=&quot;container&quot;&gt; &quot;&quot;&quot; Enhance the design using DataTableSince we will collect the menu everyday, the table in menu.html will become too long for loading and hard to check. We can use DataTable that provide basic table layout like filtering, searching, and sorting. Also, it is very easy to implement, simply include the JavaScript and CSS link in the HTML code and you can get the basic, but decent design. Automation with GitHub WorkflowFinally, after we deployed the code to GitHub, remember our original goal: Scrape the Mensa menu every weekday and store it to Google Sheets Fetch the Data Collection from Google Sheets and update the website In fact, we can run the python script periodically using Github workflow, here are the steps: The workflow has to be implemented in .yml format, and stored in .github/workflows/{workflow_name}.yml Before running the python script, make sure python is set with all the dependencies installed: - name: 🛠 Set up Python uses: actions/setup-python@v4 with: python-version: &quot;3.x&quot; - name: 📦 Install dependencies run: | pip install requests selenium webdriver-manager gspread oauth2client - name: 🚀 Run Mensaar Scraper (update Google Sheets) run: | echo &quot;🧪 Starting Mensaar_scraper...&quot; python Mensaar_scraper.py echo &quot;✅ Scraper completed.&quot; - name: 🖼️ Run HTML Generator run: | echo &quot;🧪 Generating index.html &amp; menu.html&quot; python generate_menu.py For the full workflow, you can find the skeleton code template on GitHub or you can check here. A random summaryWith all these works, we managed to build our web crawler and a static website using only python. And Github workflow can help us with daily updates. Continue Reading: MensaarLecker Development Log 3 – Telegram Bot Deployment and Integration","link":"/projects/mensaarlog2/"},{"title":"MensaarLecker Development Log 3 -- Telegram Bot Deployment and Integration","text":"This blog post is trying to tell you: My personal experience when developing a web crawler using Selenium Explained with examples from my Repository: MensaarLecker For further details, feel free to **Try the bot: @Mensaar_Bot New FeaturesHTW menuAfter the website is published, we noticed that people now prefer to have lunch in HTW Campus Rotenbühl. Since their menu come from the same site, it is very easy to introduce new menu to our project. New website layoutBefore we used two pages to store today’s menu and the menu history. And we think in general, all menu are simple texts, so we can put all contents into the index page without any problem. We can switch the visibility using JavaScript, then for the whole HTML code again we stuffed in the python script to for our daily Github workflow to run. &lt;script&gt; function show(id) {{ document.querySelectorAll('.section').forEach(el => el.classList.remove('active')); document.getElementById(id).classList.add('active'); }} &lt;/script&gt; &lt;h1&gt;Mensaar Menu - {today}&lt;/h1&gt; &lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;button&quot; onclick=&quot;show('today-uds')&quot;&gt;📅 UDS Today&lt;/button&gt; &lt;button class=&quot;button&quot; onclick=&quot;show('today-htw')&quot;&gt;📅 HTW Today&lt;/button&gt; &lt;button class=&quot;button&quot; onclick=&quot;show('full-uds')&quot;&gt;📋 Full UDS&lt;/button&gt; &lt;button class=&quot;button&quot; onclick=&quot;show('full-htw')&quot;&gt;📋 Full HTW&lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;today-uds&quot; class=&quot;section active&quot;&gt; &lt;h2&gt;UDS – Today's Menu&lt;/h2&gt; {meal_cards(uds_data)} &lt;/div&gt; &lt;div id=&quot;today-htw&quot; class=&quot;section&quot;&gt; &lt;h2&gt;HTW – Today's Menu&lt;/h2&gt; {meal_cards(htw_data)} &lt;/div&gt; &lt;div id=&quot;full-uds&quot; class=&quot;section&quot;&gt; &lt;h2&gt;📋 Full UDS Menu&lt;/h2&gt; &lt;table id=&quot;uds-table&quot;&gt; &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Date&lt;/th&gt;&lt;th&gt;Counter&lt;/th&gt;&lt;th&gt;Meal&lt;/th&gt;&lt;th&gt;Component 1&lt;/th&gt;&lt;th&gt;Component 2&lt;/th&gt;&lt;th&gt;Component 3&lt;/th&gt;&lt;th&gt;Component 4&lt;/th&gt;&lt;th&gt;Component 5&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;{table_rows(uds_data)}&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=&quot;full-htw&quot; class=&quot;section&quot;&gt; &lt;h2&gt;📋 Full HTW Menu&lt;/h2&gt; &lt;table id=&quot;htw-table&quot;&gt; &lt;thead&gt;&lt;tr&gt;&lt;th&gt;Date&lt;/th&gt;&lt;th&gt;Counter&lt;/th&gt;&lt;th&gt;Meal&lt;/th&gt;&lt;th&gt;Component 1&lt;/th&gt;&lt;th&gt;Component 2&lt;/th&gt;&lt;th&gt;Component 3&lt;/th&gt;&lt;th&gt;Component 4&lt;/th&gt;&lt;th&gt;Component 5&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;{table_rows(htw_data)}&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; Telegram Bot – @Mensaar_BotOn top of the webiste, we can reuse the scraping code to create a telegram bot. First, we need to create a bot and get its API key using botfather. Onve you get the key, you bot is created and alive! However, it doesn’t do anything because we haven’t tell it what to do. So, we need to implement its functionalities. python-telegram-bot is a very good package that contains everything we need to control the bot. RapidFuzz – Fuzzy Text detection for bot replyOther than commands and buttons, we also want to make the bot to reply to text message for better interactions. When the bot is added to a group chat, users can interact to the bot by tagging the bot and sending messages. Any texts related to food, mensa and menu will be accpeted and perform the action. This is done under fuzzy matching. Using fuzz.partial_ratio() we can compare the similarity of users’ messages with our keyword list. Brief Walkthrough on Telegram BotWe also have another study notes for all of the telegram bot projects in here CommandHandler – /start The basic way to call a bot is to send a command. Commands are defined by CommandHandler, which we can implement each commands’ functionalites respectively. To make our bot send message to users, we can use update.message.reply_text. from telegram import Update from telegram.ext import ApplicationBuilder, CommandHandler async def start(update: Update, context: ContextTypes.DEFAULT_TYPE): await update.message.reply_text( &quot;&quot;&quot;🦉 Hoot Hoot❗ Guess we have another mortal here❗ If you have NO soul --&gt; /owl If you have NO food &amp; soul --&gt; /menu If you HAVE a soul --&gt; @Mensaar_Bot And start talking&quot;&quot;&quot;) def main(): app = ApplicationBuilder().token(os.getenv(&quot;TOKEN&quot;)).build() app.add_handler(CommandHandler(&quot;start&quot;, start)) app.run_polling() InlineKeyboardMarkup – Buttons for actions Sometimes, users may need further options to finish the command, here we used InlineKeyboardMarkup to create possible options. There is another option ReplyKeyboardMarkup that can create buttons by replacing your phone keyboard, but from user feedbacks we noticed that it may be annoying for group usage. from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup from telegram.ext import ApplicationBuilder, CommandHandler async def panel(update: Update, context: ContextTypes.DEFAULT_TYPE): # clean keyboard just in case # await update.message.reply_text(&quot;Remove unwanted reply keyboard hoot hoot...&quot;, reply_markup=ReplyKeyboardRemove()) # zero-width space keyboard = [ [InlineKeyboardButton(&quot;Button A&quot;, callback_data=&quot;Text A&quot;)], [InlineKeyboardButton(&quot;Button B&quot;, callback_data=&quot;Text B&quot;)], ] reply_markup = InlineKeyboardMarkup(keyboard) await update.message.reply_text( &quot;This is a panel&quot;, reply_markup=reply_markup ) def main(): app = ApplicationBuilder().token(os.getenv(&quot;TOKEN&quot;)).build() app.add_handler(CommandHandler(&quot;panel&quot;, panel)) app.run_polling() CallbackQueryHandler – Handle your buttons and actionsWhen a button from InlineKeyboardMarkup is pressed, the data from callback_data attribute is then passed. We can capture it by using CallbackQueryHandler. Since we are using Query here, we need to use query.edit_message_text. from telegram import Update from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE): query = update.callback_query await query.answer() user_input = query.data print(f&quot;📥 Callback query received: {base64.b64decode(user_input)}&quot;) match user_input: case &quot;Text A&quot;: # 📜 All Menu msg = &quot;This is option A&quot; case &quot;Text B&quot;: # 🍽️ UdS Menu msg = &quot;This is option B&quot; case _: msg = &quot;Error&quot; await query.edit_message_text(text=msg) def main(): app = ApplicationBuilder().token(os.getenv(&quot;TOKEN&quot;)).build() app.add_handler(CallbackQueryHandler(handle_callback)) # Now handling inline button clicks app.run_polling()","link":"/projects/mensaarlog3/"},{"title":"Mathjax prime superscript problem in Hexo theme","text":"Prime superscript problem (e.g. x’_i) in MathjaxWhen I was using Mathjax to create math formula in my blog post, I typed((q_1, q_2), a, (q'_1, q'_2)) \\in S \\times \\Sigma_{int} \\times S and it rendered as $((q_1, q_2), a, (q’_1, q’2)) \\in S \\times \\Sigma{int} \\times S$ However, when ((q_1, q_2), a, (q'_1, q'_2)) &amp; \\in S \\times \\Sigma_{int} \\times S are seperated, they rendered properly. $$((q_1, q_2), a, (q’_1, q’_2))$$ $$\\in S \\times \\Sigma_{int} \\times S$$ Maybe I should use \\left and \\right for (), just like \\lbrace and \\rbrace for {}? So I typed \\left( \\left( q_1, q_2 \\right), a, \\left( q'_1, q'_2 \\right) \\right) \\in S \\times \\Sigma_{int} \\times S, didn’t work out: $\\left( \\left( q_1, q_2 \\right), a, \\left( q’_1, q’2 \\right) \\right) \\in S \\times \\Sigma{int} \\times S$ Source of error Problem definitely comes from the first half of the formula, since second half are all variables. Turns out there may be an issue with how the prime symbol are being handled. For simple formula, q'_1 and q_1' are considered the identical.However, for more complicated formula, the only q_1' can be rendered correctly: $$((q_1, q_2), a, (q_1’, q_2’)) \\in S \\times \\Sigma_{int} \\times S$$ SolutionsAfterwards, I found people reported similar issue before. Two basic solutions: Stick to the format x_{Subscript}^{Superscript}, but for prime symbol ', use it as x_{Subscript}' Simply use {\\prime} for every situation, e.g. x_{i}^{\\prime}.","link":"/site/hexo-mathjax/"},{"title":"Hexo Plugins and Personalization of this site","text":"Here are all the plugins and niche settings that personalize this blog and the Icarus theme. Remove Uppercase DetailsThe Uppercase characters overflowed the page and affects the aesthetic. Find the css tag that contains the keyword Uppercase and remove it. {page.layout !== 'page' ? &lt;div class=&quot;article-meta is-size-7 is-uppercase level is-mobile&quot;&gt; Better Sans FontIn _config.icarus.yml, find the following section providers: providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL template of the webfont CDN provider fontcdn: https://fonts.googleapis.com/css2?family=Noto+Sans+HK:wght@100..900&amp;display=swap # Name or URL of the fontawesome icon font CDN provider iconcdn: fontawesome Choose your favorite font in Google Fonts, and paste the url of the font to fontcdn Atom or RSS feed – hexo-generator-feedIt is used for generating Atom 1.0 feed. Check Here Installationnpm install hexo-excerpt --save Configurationfeed: enable: true type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date icon: /img/avatar.png autodiscovery: true template: Automatic excerpt generator – hexo-excerptInstallationnpm install hexo-excerpt --save Configurationexcerpt: depth: 10 excerpt_excludes: [] more_excludes: [] hideWholePostExcerpts: true","link":"/site/personalize/"}],"tags":[{"name":"Appium","slug":"Appium","link":"/tags/Appium/"},{"name":"App Testing","slug":"App-Testing","link":"/tags/App-Testing/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"UdS","slug":"UdS","link":"/tags/UdS/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Scraper","slug":"Scraper","link":"/tags/Scraper/"},{"name":"Selenium","slug":"Selenium","link":"/tags/Selenium/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Cantonese","slug":"Cantonese","link":"/tags/Cantonese/"},{"name":"Telegram","slug":"Telegram","link":"/tags/Telegram/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Mathjax","slug":"Mathjax","link":"/tags/Mathjax/"}],"categories":[{"name":"Appium","slug":"Appium","link":"/categories/Appium/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Projects","slug":"Projects","link":"/categories/Projects/"},{"name":"SiteNote","slug":"SiteNote","link":"/categories/SiteNote/"}],"pages":[{"title":"About Me","text":"Personal Info Click HERE for my detailed resume. Chun Ngai Li (Alex), M.Sc. Cybersecurity in Saarland University,B.Eng Information Engineering in CUHK. Recent WorksA C/C++ programmer. Also working on Backend &amp; Python developing.Current research: Social Engineering, Large Language Models (LLM), Machine Learning ContactsEmail: alexcnli@yahoo.com","link":"/about/index.html"},{"title":"GreenMeeple cannot find what you are looking for...","text":"","link":"/404.html"},{"title":"Resume of Chun Ngai Li (Alex)","text":"For pdf version, click HERE About MeCurrently pursuing a Master’s in Cybersecurity, showcasing a strong foundation in penetration testing and AI-driven security solutions. Proficient in Python, C/C++, and JavaScript, with a proven track record of developing automation tools and secure web applications. Passionate about enhancing cybersecurity measures and risk assessment, eager to contribute to cutting-edge projects in international teams that prioritize seurity and scalability. Personal DetailsName: Chun Ngai LiPhone: +49 163-513-2617Address: 66125 Saarbrücken, GermanyDate &amp; Place of Birth: 27.09.1999, Hong Kong Links and Websites Github LinkedIn LeetCode Personal Site (Here) EducationOctober 2021 – March 2025M.Sc. Cybersecurity in Universität des Saarlandes, Saarbrücken Thesis Topic: Exploring the Cybersecurity Threats in LLM-Powered Apps: Malicious Code Generation and Regulatory Challenges Current Grade: 2.4 September 2017 – May 2021B.Eng. Information Engineering in The Chinese University of Hong Kong, Hong Kong GPA: 3.275/4 (Equivalent to 1.54 in German System) Minor study: German Exchanged in KTH Royal Institute of Technology, Sweden in 2019-2020 Work ExperienceMarch 2022 – March 2023IT Research Assistant at Universität des Saarlandes, Saarbrücken Developed a full-stack Intranet for the Faculty of Business using PHP7, JavaScript, and MySQL to maintain appointment and administrative work Developed Monte Carlo Algorithm using Microsoft Excel and VBA to create automation and user-friendly interface Enhanced Student website portal to provide resources, lending, significant and minor selection, and transcript March 2021 – May 2021Software Engineer at Hong Kong Jockey Club, Hong Kong Worked for AI for the Future Project Developed a Mobile App using React Native and Python to control 3D-printing Robots via Bluetooth Created a documentation and user manual for the App and Robots to ensure effective communications and demonstrations to clients November 2020 – February 2021Cybersecurity Undergraduate Researcher at The Chinese University of Hong Kong, Hong Kong Research Topic: Morpheus: Bringing the (pkcs) one to meet the oracle Contributed to pioneering cybersecurity research led by Dr. Sherman S. M. Chow, focusing on RSA\\PKCS1 signature verification Developed versatile black-box fuzzing tools using C++, Java, Python, and C# to investigate signature verification vulnerabilities June 2020 – September 2020Software &amp; Technology Analyst at Sharp Peak Consulting Limited , Hong Kong Developed a Booking System for Clinic using Microsoft Power Apps Engaged in on-site visits to various corporations to install and maintain IoT products Contributed to Cybersecurity consulting towards server and network services Languages★★☆☆☆ German★★★★★ English★★★★★ Cantonese★★★★★ Mandarin Skills★★★★★ C★★★★★ C++★★★★★ SQL★★★★☆ PHP★★★★☆ Python★★★★☆ HTML &amp; CSS★★★★☆ JavaScript","link":"/about/resume.html"}]}