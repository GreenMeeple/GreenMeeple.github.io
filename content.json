{"posts":[{"title":"üçΩ ü•® MensaarLecker -- A beloved tool to find out Mensa Ladies&#39; favourite menu using Seleniumü•® üçΩ","text":"Repository: MensaarLecker As an UdS Student,Are you tired of seeing french friesüçü 3 times a week, or wondering when I can have the best pizza üçï in the Mensacafe?MensaarLecker aims to collect all the data from Menu 1, 2, and Mensacafe to trace your favourite, or Mensa Ladies‚Äô, favourite menu! üÜï Updates05.08 ‚Äì Telegram Bot @Mensaar_Bot are published. (See my development blog in here! MensaarLecker Development Log 3 ‚Äì Telegram Bot Deployment and Integration) 04.21 ‚Äì HTW menus are now added to the statistics. ü•ó DescriptionA fully automated scraper and static website for the Saarbr√ºcken Mensa, powered by Python, Selenium, Google Sheets, and GitHub Actions. Get a clean and daily-updated overview of meals from mensaar.de, with searchable history, meal components, and frequency stats. üåê Live Demoüëâ View Websiteüëâ View Data in Google Sheets üìÖ Features ‚úÖ Scrapes the Saarbr√ºcken Mensa daily menu ‚úÖ Publishes structured data to a connected Google Sheet ‚úÖ Generates static HTML pages: index.html ‚Äì Today‚Äôs menu with meal frequency counts menu.html ‚Äì Full searchable menu with DataTables ‚úÖ Automatically updates via GitHub Actions at 10:00 AM UTC on weekdays ‚úÖ Beautiful card-style layout &amp; component display ‚úÖ No server required ‚Äî 100% static üß† Meal Frequency Display ExampleThe homepage shows how often each meal has been served based on historical data since 2025.03.20: üçΩÔ∏è Pasta mit Tomatenso√üeüìä Seen since 2025.03.20‚úÖ Geriebener K√§se‚úÖ Rucola üìÅ Project Structuredirectory1234567891011.‚îú‚îÄ‚îÄ Mensaar_scraper.py # Scrapes from mensaar.de and writes to Google Sheet‚îú‚îÄ‚îÄ generate_menu.py # Reads the sheet and generates index.html and menu.html‚îú‚îÄ‚îÄ credentials.json # Google service account key (excluded from repo)‚îú‚îÄ‚îÄ index.html # Main website page with today's menu‚îú‚îÄ‚îÄ menu.html # Full searchable table of meals‚îú‚îÄ‚îÄ .github/workflows/‚îÇ ‚îî‚îÄ‚îÄ update_menu.yml # GitHub Actions automation‚îú‚îÄ‚îÄ src/‚îÇ ‚îî‚îÄ‚îÄ uds_spirit.jpg # Soul of this project‚îî‚îÄ‚îÄ README.md üìù Development LogMensaarLecker Development Log 1 ‚Äì Web CrawlingMensaarLecker Development Log 2 ‚Äì Web Developing and GitHub WorkflowMensaarLecker Development Log 3 ‚Äì Telegram Bot Deployment and Integration","link":"/projects/mensaar/"},{"title":"python-telegram-bot development experience and notes","text":"This blog post is trying to tell you: My personal experience and notes when using python-telegram-bot Explained with examples from @Mensaar_Bot and @udsfahrbot Create your first telegram bot","link":"/python/tgbot/"},{"title":"UdS Fahrplan Bot","text":"A lightweight Telegram bot designed for Saarland University students ‚Äî offering fast, clear, and focused public transport information using SaarVV and HAFAS APIs. ‚Äî Try Now üîç What it isUdS Fahrplan is a minimal alternative to the full Saarfahrplan app. No clutter. No overwhelming options. Just a clean Telegram interface for: üîÑ Trip planning with /trip üïí Live departure boards with /depart üè† One-tap departures from your home station with /home Built with students and locals in mind. ‚ú® Features /trip ‚Äì Search from A to B in Saarland &amp; Luxembourg /depart ‚Äì View all upcoming buses from any station /home ‚Äì Configure your home station and check buses in both directions (e.g., City ‚Üî Dudweiler) /sethome ‚Äì Set or update your personal home station Intelligent Filtering ‚Äì Excludes school buses, allows regional/suburban focus Persistent Storage ‚Äì Remembers user settings across bot restarts Related Projectshafas-client ‚Äì JavaScript client for HAFAS public transport APIs.Mobiliteit.lu (Github Repo) ‚Äì Real-Time tracking of bus lines across LuxembourgDeutsche BahnSaarFahrplanMobiliteit.lu üìù Development LogUdS Fahrplan Bot Development Log (1) ‚Äì Fetching data from HAFAS and its APIs through POST requestsUdS Fahrplan Bot Development Log (2) ‚Äì Planning for telegram botUdS Fahrplan Bot Development Log (3) ‚Äì Implementation on /trip and /depart functionUdS Fahrplan Bot Development Log (4) ‚Äì Implementation on /sethome and /home functionUdS Fahrplan Bot Development Log (5) ‚Äì Explanations on bot sessions and requests","link":"/projects/udsfahrplan-bot/"},{"title":"MensaarLecker Development Log (3) -- Telegram Bot Deployment and Integration","text":"This blog post is trying to tell you: My personal experience when developing a web crawler using Selenium Explained with examples from my Repository: MensaarLecker For further details, feel free to **Try the bot: @Mensaar_Bot New FeaturesPrevious post: MensaarLecker Development Log (2) ‚Äì Web Developing and GitHub Workflow HTW menuAfter the website is published, we noticed that people now prefer to have lunch in HTW Campus Rotenb√ºhl. Since their menu come from the same site, it is very easy to introduce new menu to our project. New website layoutBefore we used two pages to store today‚Äôs menu and the menu history. And we think in general, all menu are simple texts, so we can put all contents into the index page without any problem. We can switch the visibility using JavaScript: switch.js1234function show(id) {document.querySelectorAll('.section').forEach(el =&gt; el.classList.remove('active'));document.getElementById(id).classList.add('active');} And for the whole HTML code again we stuffed in the python script to for our daily Github workflow to run. index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;h1&gt;Mensaar Menu - {today}&lt;/h1&gt;&lt;div class=&quot;buttons&quot;&gt; &lt;button class=&quot;button&quot; onclick=&quot;show('today-uds')&quot;&gt;üìÖ UDS Today&lt;/button&gt; &lt;button class=&quot;button&quot; onclick=&quot;show('today-htw')&quot;&gt;üìÖ HTW Today&lt;/button&gt; &lt;button class=&quot;button&quot; onclick=&quot;show('full-uds')&quot;&gt;üìã Full UDS&lt;/button&gt; &lt;button class=&quot;button&quot; onclick=&quot;show('full-htw')&quot;&gt;üìã Full HTW&lt;/button&gt;&lt;/div&gt;&lt;div id=&quot;today-uds&quot; class=&quot;section active&quot;&gt;&lt;h2&gt;UDS ‚Äì Today's Menu&lt;/h2&gt;{meal_cards(uds_data)}&lt;/div&gt;&lt;div id=&quot;today-htw&quot; class=&quot;section&quot;&gt;&lt;h2&gt;HTW ‚Äì Today's Menu&lt;/h2&gt;{meal_cards(htw_data)}&lt;/div&gt;&lt;div id=&quot;full-uds&quot; class=&quot;section&quot;&gt;&lt;h2&gt;üìã Full UDS Menu&lt;/h2&gt;&lt;table id=&quot;uds-table&quot;&gt; &lt;thead&gt;&lt;tr&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Counter&lt;/th&gt; &lt;th&gt;Meal&lt;/th&gt; &lt;th&gt;Component 1&lt;/th&gt; &lt;th&gt;Component 2&lt;/th&gt; &lt;th&gt;Component 3&lt;/th&gt; &lt;th&gt;Component 4&lt;/th&gt; &lt;th&gt;Component 5&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;{table_rows(uds_data)}&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;div id=&quot;full-htw&quot; class=&quot;section&quot;&gt;&lt;h2&gt;üìã Full HTW Menu&lt;/h2&gt;&lt;table id=&quot;htw-table&quot;&gt; &lt;thead&gt;&lt;tr&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Counter&lt;/th&gt; &lt;th&gt;Meal&lt;/th&gt; &lt;th&gt;Component 1&lt;/th&gt; &lt;th&gt;Component 2&lt;/th&gt; &lt;th&gt;Component 3&lt;/th&gt; &lt;th&gt;Component 4&lt;/th&gt; &lt;th&gt;Component 5&lt;/th&gt; &lt;/tr&gt;&lt;/thead&gt; &lt;tbody&gt;{table_rows(htw_data)}&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt; Telegram Bot ‚Äì @Mensaar_BotOn top of the webiste, we can reuse the scraping code to create a telegram bot. First, we need to create a bot and get its API key using botfather. Onve you get the key, you bot is created and alive! However, it doesn‚Äôt do anything because we haven‚Äôt tell it what to do. So, we need to implement its functionalities. python-telegram-bot is a very good package that contains everything we need to control the bot. RapidFuzz ‚Äì Fuzzy Text detection for bot replyOther than commands and buttons, we also want to make the bot to reply to text message for better interactions. When the bot is added to a group chat, users can interact to the bot by tagging the bot and sending messages. Any texts related to food, mensa and menu will be accpeted and perform the action. This is done under fuzzy matching. Using fuzz.partial_ratio() we can compare the similarity of users‚Äô messages with our keyword list. Brief Walkthrough on Telegram BotWe also have another study notes for all of the telegram bot projects in here CommandHandler ‚Äì /start The basic way to call a bot is to send a command. Commands are defined by CommandHandler, which we can implement each commands‚Äô functionalites respectively. To make our bot send message to users, we can use update.message.reply_text. bot.py1234567891011121314from telegram import Updatefrom telegram.ext import ApplicationBuilder, CommandHandlerasync def start(update: Update, context: ContextTypes.DEFAULT_TYPE): await update.message.reply_text(&quot;&quot;&quot;ü¶â Hoot Hoot‚ùó Guess we have another mortal here‚ùóIf you have NO soul --&gt; /owlIf you have NO food &amp; soul --&gt; /menuIf you HAVE a soul --&gt; @Mensaar_Bot And start talking&quot;&quot;&quot;)def main(): app = ApplicationBuilder().token(os.getenv(&quot;TOKEN&quot;)).build() app.add_handler(CommandHandler(&quot;start&quot;, start)) app.run_polling() InlineKeyboardMarkup ‚Äì Buttons for actions Sometimes, users may need further options to finish the command, here we used InlineKeyboardMarkup to create possible options. There is another option ReplyKeyboardMarkup that can create buttons by replacing your phone keyboard, but from user feedbacks we noticed that it may be annoying for group usage. bot.py1234567891011121314151617181920from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkupfrom telegram.ext import ApplicationBuilder, CommandHandlerasync def panel(update: Update, context: ContextTypes.DEFAULT_TYPE): # clean keyboard just in case # await update.message.reply_text(&quot;Remove unwanted reply keyboard hoot hoot...&quot;, reply_markup=ReplyKeyboardRemove()) # zero-width space keyboard = [ [InlineKeyboardButton(&quot;Button A&quot;, callback_data=&quot;Text A&quot;)], [InlineKeyboardButton(&quot;Button B&quot;, callback_data=&quot;Text B&quot;)], ] reply_markup = InlineKeyboardMarkup(keyboard) await update.message.reply_text( &quot;This is a panel&quot;, reply_markup=reply_markup )def main(): app = ApplicationBuilder().token(os.getenv(&quot;TOKEN&quot;)).build() app.add_handler(CommandHandler(&quot;panel&quot;, panel)) app.run_polling() CallbackQueryHandler ‚Äì Handle your buttons and actionsWhen a button from InlineKeyboardMarkup is pressed, the data from callback_data attribute is then passed. We can capture it by using CallbackQueryHandler. Since we are using Query here, we need to use query.edit_message_text. bot.py1234567891011121314151617181920212223from telegram import Updatefrom telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandlerasync def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE): query = update.callback_query await query.answer() user_input = query.data print(f&quot;üì• Callback query received: {base64.b64decode(user_input)}&quot;) match user_input: case &quot;Text A&quot;: # üìú All Menu msg = &quot;This is option A&quot; case &quot;Text B&quot;: # üçΩÔ∏è UdS Menu msg = &quot;This is option B&quot; case _: msg = &quot;Error&quot; await query.edit_message_text(text=msg)def main(): app = ApplicationBuilder().token(os.getenv(&quot;TOKEN&quot;)).build() app.add_handler(CallbackQueryHandler(handle_callback)) # Now handling inline button clicks app.run_polling()","link":"/projects/mensaar-log3/"},{"title":"UdS Fahrplan Bot Development Log (5) -- Explanations on bot sessions and requests","text":"This blog post is trying to tell you: Why session is needed when multiple command using similar workflow? The details of HTTP request Detailed explanations on the implementation of udsfahrbot Previous post: UdS Fahrplan Bot Development Log (4) ‚Äì Implementation on /sethome and /home function Brief Walkthrough on Telegram Bot (Cont.)In the previous notes, we‚Äôve already implemented all the commands we need! But there‚Äôs a question, why we need to format out query in f‚Äù{session}:{step}:{loc}‚Äù? Also, we haven‚Äôt talked about the function that connects to the SaarVV api. We also have another study notes for all of the telegram bot projects in here, it gives you the basics on how to create your own bot and further descriptions on different functions and attributes on the package python-telegram-bot. HTTP request on SaarVVIn Application layer, if we send a GET request to the URL, it returns the HTML of the URL. For example: request.py1234567import requeststry: res = requests.get(&quot;https://greenmeeple.github.io/&quot;) print(res.text)except Exception as e: print(f&quot;‚ùå Error fetching location matches: {e}&quot;) Then we are basically retriving the source code the website. Extra work is needed to perform a POST requestBut if simply change the function from GET to POST, it won‚Äôt work: Instead of getting data, a POST requestis typically used for forms, APIs, or uploading data. So we can‚Äôt simply ping a website with POST request. For example, if you are sending POST request to a website, you should locate the form and include the correct information. And for API, you should have correct header, user agent, etc. How can I construct my own POST request?TLDR: In hafas-client, there‚Äôs a lot profiles used by various public transportation networks. However, some of them are deprecated so be careful to verify before you use. Here, we introduce another approach. We go to the Saarfahrplan website, and try to investigate how a POST request is constructed and sent. $\\text{Press F12}\\Rightarrow\\text{Network tab}\\Rightarrow\\text{Select filter}\\textbf{Fetch/XHR}$ We can then inspect the details of the request. We can see the URL here is not a website, but ends with .exe, which indicates that is an API. Next, we specified the data type we are sending (JSON), and the user agent we are using (HAFAS). Another important attribute is the &quot;auth&quot;: {&quot;type&quot;: &quot;AID&quot;, &quot;aid&quot;: &quot;yCW9qZFSye1wIv3gCzm5r7d2kJ3LIF&quot;}, which are used by the api to verify the connection. Select the request we want to inspect, and then we can see attibutes like Content-Encoding and Content-Type. Also, we can see the entire request payload, which will be useful for our template when constructing the POST request. Now back to our first development log, we talked about the following function: getTrip.py123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport jsondef LocMatch(): url = &quot;https://www.saarfahrplan.de/bin/mgate.exe&quot; headers = { &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Accept-Encoding&quot;: &quot;gzip&quot;, &quot;User-Agent&quot;: &quot;HAFAS&quot; } body = { &quot;ver&quot;: &quot;1.63&quot;, &quot;lang&quot;: &quot;en&quot;, &quot;auth&quot;: {&quot;type&quot;: &quot;AID&quot;, &quot;aid&quot;: &quot;yCW9qZFSye1wIv3gCzm5r7d2kJ3LIF&quot;}, &quot;client&quot;: { &quot;id&quot;: &quot;ZPS-SAAR&quot;, &quot;type&quot;: &quot;WEB&quot;, &quot;name&quot;: &quot;webapp&quot;, &quot;l&quot;: &quot;vs_webapp&quot;, &quot;v&quot;: 10004 }, &quot;formatted&quot;: False, &quot;svcReqL&quot;: [{ &quot;meth&quot;: &quot;LocMatch&quot;, &quot;req&quot;: { &quot;input&quot;: { &quot;field&quot;: &quot;S&quot;, &quot;loc&quot;: { &quot;type&quot;: &quot;ALL&quot;, &quot;name&quot;: keyword, }, &quot;maxLoc&quot;: 5 } }, &quot;id&quot;: &quot;1|3|&quot; }] } try: res = requests.post(url, headers=headers, data=json.dumps(body)) data = res.json() return data except Exception as e: print(f&quot;‚ùå Error fetching location matches: {e}&quot;) return None Here, we basically visiting the API via Saarfahrplan by using its credentials and headers. On top of that we customized the attributes and methods so that we can fetch the customized data we want. Session in Telegram BotNow back to our bot, since we implemented our commands seperately. They works fine when users execute them safely. However, we also need to be aware of unexpected usage. For example, what if our user started with the /depart command, but instead of finishing it, he/she chooses to start another new /trip command at the same time? When a station is parsed to the context.user_data, which function should it send to? This is reason we need make sure the function is always passing data correctly. getDepart.py12345678910111213141516171819202122async def handle_depart_stations(query, context, data): trip_start = context.user_data.get(&quot;trip_session&quot;, {}).get(&quot;start&quot;) home_start = context.user_data.get(&quot;home_session&quot;, {}).get(&quot;start&quot;) spawn_start = context.user_data.get(&quot;spawn_session&quot;, {}).get(&quot;start&quot;) context.user_data[&quot;depart_session&quot;][&quot;start&quot;] = &quot;more&quot; if spawn_start == &quot;more&quot; or trip_start == &quot;more&quot; or home_start == &quot;more&quot;: await query.edit_message_text(&quot;You had a previous session, resume the search?&quot;,reply_markup=build_session_keyboard(&quot;depart&quot;)) else: await query.edit_message_text(f&quot;Please Type your keyword to search the station&quot;)async def handle_depart_session(query, context, data): if data == &quot;resume&quot;: context.user_data[&quot;depart_session&quot;] = {} await query.edit_message_text(&quot;Departure search terminated, resume the previous search.\\n Please Type your keyword to search the station&quot;) elif data == &quot;continue&quot;: context.user_data[&quot;trip_session&quot;] = {} context.user_data[&quot;spawn_session&quot;] = {} context.user_data[&quot;home_session&quot;] = {} context.user_data[&quot;depart_session&quot;][&quot;start&quot;] = &quot;more&quot; await query.edit_message_text(f&quot;Previous search terminated, continue the departure search.\\nPlease Type your keyword to search the station&quot;) Reference POST - HTTP - MDN Web Docs - Mozilla hafas-client Deutsche Bahn SaarFahrplan Mobiliteit.lu Mobiliteit.lu (Github Repo)","link":"/projects/udsfahrplan-log5/"},{"title":"HAFAS Bitmask Calculator","text":"Web Demo This is a simple web-based tool to help you decode and encode bitmasks used by the HAFAS (HaCon Fahrplan-Auskunfts-System) API.It visually maps a decimal bitmask to the transport modes it represents and vice versa. üîç What is HAFAS?HAFAS is a timetable and journey planning system widely used across European transport networks, including: Deutsche Bahn (DB) SaarVV Luxembourg Mobilit√©it Many other regional operators In HAFAS APIs, transport modes (ICE trains, buses, trams, ferries, etc.) are often encoded in a bitmask ‚Äîa single number where each bit (1, 2, 4, 8, ‚Ä¶) represents a specific type of transport. ‚ú® Features üî¢ Enter a number to decode it into selected transport modes ‚úÖ Click transport icons to encode a bitmask value üîÑ Switch between different mode sets (DB, SaarVV, Luxembourg, HAFAS client spec) ‚ö†Ô∏è Input capped to valid 11-bit range (0‚Äì2047) üí° Uses the official hafas-client mode bitmask as one profile üõ† Technology React + Vite Plain CSS for styling No external UI libraries Fully static ‚Äî can be deployed to GitHub Pages, Netlify, etc. Structuredirectory1234.‚îú‚îÄ‚îÄ assets # static scripts and assets for demo‚îú‚îÄ‚îÄ index.html # demo entry‚îî‚îÄ‚îÄ react # react source code Related Projectshafas-client ‚Äì JavaScript client for HAFAS public transport APIs.Mobiliteit.lu ‚Äì Real-Time tracking of bus lines across Luxembourg","link":"/projects/hafas-bitmask-calculator/"},{"title":"UdS Fahrplan Bot Development Log (4) -- Implementation on &#x2F;sethome and &#x2F;home function","text":"This blog post is trying to tell you: How to build your own telegram bot Detailed explanations on the implementation of udsfahrbot Previous post: UdS Fahrplan Bot Development Log (3) ‚Äì Implementation on /trip and /depart function Brief Walkthrough on Telegram Bot (Cont.)In the previous notes, we‚Äôve already implemented /trip and /depart based on this. Now, let‚Äôs start explaining them one by one. We also have another study notes for all of the telegram bot projects in here, it gives you the basics on how to create your own bot and further descriptions on different functions and attributes on the package python-telegram-bot. /sethome ‚Äì Storing users‚Äô starting stationSimilarly, our main function should have app.add_handler(CommandHandler(&quot;sethome&quot;, spawn)) and InlineKeyboardMarkup[] ready, these components are defined in previous notes and they are reusable. Next, our function has to be able to distinguish different users. Users who interact with the bot using command or tagged message will have their id stored in message.from_user.id; and query.from_user.id if users are interacting using buttons. Then, we also need to create a database or storage file to read and write users‚Äô stations. We decide the tool to use based on our use case and needs. Here, the data we need to store are user_id, station_name, and station_id. Which the columns are stable and small size. Therefore, it can be handled by a simple JSON file. Before we store the station, remember to check if the user already stored any station before to avoid creating duplicates. bot_spawn.py123456789101112131415161718192021222324252627282930313233343536373839async def handle_spawn_start(query, context, data): station = locations[data] if data in locations else data name = context.user_data.get(&quot;spawn_session&quot;, {}).get(&quot;search_s&quot;, {}).get(data, data) user_id = query.from_user.id if os.path.exists(SPAWN_DATA): with open(SPAWN_DATA, &quot;r&quot;) as file: try: data_list = json.load(file) except json.JSONDecodeError: data_list = [] else: data_list = [] # Check if user already exists user_found = False for entry in data_list: if entry[&quot;user_id&quot;] == user_id: entry[&quot;home_id&quot;] = station entry[&quot;home_name&quot;] = name user_found = True break if not user_found: # Add new user entry data_list.append({&quot;user_id&quot;: user_id, &quot;home_id&quot;: station, &quot;home_name&quot;: name}) # Save updated data with open(SPAWN_DATA, &quot;w&quot;) as file: json.dump(data_list, file, indent=2) await query.edit_message_text( f&quot;‚úÖ User {user_id}, your home is set to {name:&lt;20}&quot;)async def spawn(update: Update, context: ContextTypes.DEFAULT_TYPE): context.user_data[&quot;spawn_session&quot;] = {} await update.message.reply_text(f&quot;Hello User {update.message.from_user.id}, Set your spawn point&quot;, reply_markup=build_location_keyboard(&quot;spawn&quot;,&quot;start&quot;) ) /home ‚Äì A quick version of /trip for frequent, repetitive usageNow we are gonna implement our /home command. We have all the components need from our previous work. All we need is to recombulate them and make sure we create a new type of session, context.user_data[&quot;home_session&quot;]. Basically, /home is /trip without setting the destination, but directly retrieve it from the database created by /sethome. Also, to enhance user experience, if a user call /home without setting any destination stations in prior, jump to the /sethome workflow before moving on. bot_home.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475async def handle_home_start(query, context, data): start = locations[data] if data in locations else data context.user_data[&quot;home_session&quot;][&quot;start&quot;] = context.user_data.get(&quot;home_session&quot;, {}).get(&quot;search_s&quot;, {}).get(data, data) user_id = query.from_user.id if os.path.exists(SPAWN_DATA): with open(SPAWN_DATA, &quot;r&quot;) as file: try: data_list = json.load(file) except json.JSONDecodeError: data_list = [] else: data_list = [] # Check if user already exists user_found = False for entry in data_list: if entry[&quot;user_id&quot;] == user_id: dest = entry[&quot;home_id&quot;] context.user_data[&quot;home_session&quot;][&quot;dest&quot;] = entry[&quot;home_name&quot;] user_found = True break if not user_found: await query.edit_message_text(f&quot;Hello User {user_id}, You haven't set your home station.&quot;, reply_markup=build_location_keyboard(&quot;spawn&quot;,&quot;start&quot;)) else: await query.edit_message_text(f&quot;üîç Finding trips from {context.user_data[&quot;home_session&quot;][&quot;start&quot;]} to {context.user_data[&quot;home_session&quot;][&quot;dest&quot;]}...&quot;) context.user_data[&quot;home_session&quot;][&quot;trip&quot;] = get_trips(&quot;saarvv&quot;, start, dest, 0) trip_basic=parse_trips_basic(context.user_data[&quot;home_session&quot;][&quot;trip&quot;], context.user_data[&quot;home_session&quot;][&quot;start&quot;], context.user_data[&quot;home_session&quot;][&quot;dest&quot;]) if trip_basic is None: btn_retry = InlineKeyboardMarkup([[InlineKeyboardButton(&quot;again&quot;, callback_data=&quot;home:details:again&quot;)]]) await query.edit_message_text(&quot;‚ùå No trips found. Try again.&quot;, reply_markup=btn_retry) else: btn_details = InlineKeyboardMarkup([[InlineKeyboardButton(&quot;details&quot;, callback_data=&quot;home:details:show&quot;)]]) await query.edit_message_text(text=trip_basic, reply_markup=btn_details)async def handle_home_details(query, context, data): if data == &quot;again&quot;: context.user_data[&quot;home_session&quot;].clear() await query.edit_message_text(&quot;üöå Where do you want to start your journey?&quot;, reply_markup=build_location_keyboard(&quot;home&quot;,&quot;start&quot;)) else: trip = context.user_data[&quot;home_session&quot;].get(&quot;trip&quot;) context.user_data[&quot;home_session&quot;].clear() await query.edit_message_text(text=parse_trips_detail(trip,context.user_data[&quot;home_session&quot;][&quot;start&quot;], context.user_data[&quot;home_session&quot;][&quot;dest&quot;]))async def home(update: Update, context: ContextTypes.DEFAULT_TYPE): context.user_data[&quot;home_session&quot;] = {} user_id = update.message.from_user.id if os.path.exists(SPAWN_DATA): with open(SPAWN_DATA, &quot;r&quot;) as file: try: data_list = json.load(file) except json.JSONDecodeError: data_list = [] else: data_list = [] # Check if user already exists user_found = False for entry in data_list: if entry[&quot;user_id&quot;] == user_id: user_found = True break if not user_found: await update.message.reply_text(f&quot;Hello User {user_id}, You haven't set your home station.&quot;, reply_markup=build_location_keyboard(&quot;spawn&quot;,&quot;start&quot;)) else: await update.message.reply_text(f&quot;Hello User {user_id}, Where are you right now?&quot;, reply_markup=build_location_keyboard(&quot;home&quot;,&quot;start&quot;)) Advanced: Database EncryptionAs a Cybersecurity student, it seems to be a little be ‚Äúsus‚Äù to simply use JSON‚Ä¶ Currently our user base is within the people we know, which is totally fine becaue of trust. But if the user base has expanded beyond that, server side of the telegram bot can see everyone‚Äôs station, or more precisely, we can even know where a user live! In general, there‚Äôs no way but trust in this situation, because evey function is implemented by the server/provider (me) and we can always log the data because any operations. So even it is encrypted and no other users can check, the server holder can still retrieve at some point. Unless the data is already encrypted before sending (E2EE). Another way to guarantee the trust here, is that 1. The whole bot is opensource, and 2. A third party/person has verify the running bot is indeed same as the code in the repository online. Quick SummaryWe talked about the methodology behind /sethome and /home and the security concern when deploying our product to a larger user base. However, there are some extra work we haven‚Äôt covered yet. For example, what are the session being useful in our design, what exactly are our HTTP request and where are they come from? Continue Reading: UdS Fahrplan Bot Development Log (5) ‚Äì Explanations on bot sessions and requests Reference hafas-client Deutsche Bahn SaarFahrplan Mobiliteit.lu Mobiliteit.lu (Github Repo)","link":"/projects/udsfahrplan-log4/"},{"title":"UdS Fahrplan Bot Development Log (3) -- Implementation on &#x2F;trip and &#x2F;Depart function","text":"This blog post is trying to tell you: How to build your own telegram bot Detailed explanations on the implementation of udsfahrbot Previous post: UdS Fahrplan Bot Development Log (2) ‚Äì Planning for telegram bot Brief Walkthrough on Telegram BotIn the previous notes, we‚Äôve talked about our motivation and planned functions we wanted to implement. Now, let‚Äôs start explaining them one by one. We also have another study notes for all of the telegram bot projects in here, it gives you the basics on how to create your own bot and further descriptions on different functions and attributes on the package python-telegram-bot. /trip ‚Äì A basic Station A to Station B searchWe start with the basic trip searching function just like the original app. We used CommandHandler to create the command, InlineKeyboardMarkup to create buttons for stations, CallbackQueryHandler to handle the button actions, and update.message.reply_text to send message back to the users. bot_trip.py1234567891011121314151617181920212223def build_location_keyboard(session, step, exclude=None): buttons = [ [InlineKeyboardButton(text=loc, callback_data=f&quot;{session}:{step}:{loc}&quot;)] for loc in keyboard_flat if loc != exclude ] buttons += [[ InlineKeyboardButton(text=&quot;More Stations&quot;, callback_data=f&quot;{session}:more:{step}&quot;) ]] if exclude is not None: buttons += [[ InlineKeyboardButton(text=&quot;Back&quot;, callback_data=f&quot;{session}:{step}:back&quot;) ]] return InlineKeyboardMarkup(buttons)async def trips(update: Update, context: ContextTypes.DEFAULT_TYPE): context.user_data[&quot;trip_session&quot;] = {} await update.message.reply_text( &quot;üöå Choose Your Starting Station.&quot;, reply_markup=build_location_keyboard(&quot;trip&quot;,&quot;start&quot;) ) Buttons for stations and departure timeWhen the user called the command /trip, the bot will update the message into a list of buttons thanks to the InlineKeyboardMarkup, it passes a string of message with three components, seperated with colon. f‚Äù{session}:{step}:{loc}‚Äù, it will then pass into handle_callback() and used to indentify different command using session, then it identifies the current state using steps (since stations can be either start or destination), and eventually the station details in loc will be passed to next step. At the same time, a dict that carry the data will be initialized in context.user_data.setdefault(&quot;trip_session&quot;, {}), so that we can keep track on the data that are set by users and what is still required in order to construct the HTTP request. bot_main.py1234567891011121314151617181920212223242526272829303132333435363738import osfrom telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filtersfrom util.bot_trip import *async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE): query = update.callback_query await query.answer() try: session, step, value = query.data.split(&quot;:&quot;, 2) print(session, step, value) except Exception as e: print(f&quot;‚ö†Ô∏è Callback parse error: {e}&quot;) return # Ensure session dicts context.user_data.setdefault(&quot;trip_session&quot;, {}) if session == &quot;trip&quot;: match step: case &quot;start&quot;: await handle_trip_start(query, context, value) case &quot;more&quot;: await handle_trip_stations(query, context, value) case &quot;time&quot;: await handle_trip_time(query, context, value) case &quot;dest&quot;: await handle_trip_destination(query, context, value) case &quot;details&quot;: await handle_trip_details(query, context, value) case &quot;session&quot;: await handle_trip_session(query, context, value)if __name__ == &quot;__main__&quot;: app = ApplicationBuilder().token(os.getenv(&quot;TOKEN&quot;)).build() app.add_handler(CommandHandler(&quot;trip&quot;, trips)) app.add_handler(CallbackQueryHandler(handle_callback)) app.run_polling() Once the start station is received, it will then go to handle_trip_start(), it stores the data in context.user_data[&quot;trip_session&quot;][&quot;start&quot;], and update the bot message into time selection, defined by build_time_keyboard(). bot_trip.py12345678910111213141516def build_time_keyboard(session): buttons = [ [InlineKeyboardButton(f&quot;{t} min&quot; if t else &quot;now&quot;, callback_data=f&quot;{session}:time:{t}&quot;)] for t in inline_time_options ] buttons += [[InlineKeyboardButton(text=&quot;Back&quot;, callback_data=f&quot;{session}:time:back&quot;)]] return InlineKeyboardMarkup(buttons)async def handle_trip_start(query, context, data): context.user_data[&quot;trip_session&quot;][&quot;start&quot;] = data name = context.user_data.get(&quot;trip_session&quot;, {}).get(&quot;search_s&quot;, {}).get(data, data) await query.edit_message_text( f&quot;‚úÖ Starting station is set to {name:&lt;20} \\nChoose your departure time:&quot;, reply_markup=build_time_keyboard(&quot;trip&quot;) ) For destination, it is basically same as starting station, except we changed f‚Äù{session}:start:{loc}‚Äù into f‚Äù{session}:dest:{loc}‚Äù. Afterwards, we called get_trips() to send our HTTP request, then used parse_trips_basic() and parse_trips_detail() to construct our replying message. bot_trip.py1234567891011121314151617181920212223242526272829303132333435async def handle_trip_destination(query, context, data): if data == &quot;back&quot;: context.user_data[&quot;trip_session&quot;][&quot;time&quot;] = None await query.edit_message_text( f&quot;‚úÖ Starting station is set to {context.user_data[&quot;trip_session&quot;][&quot;start&quot;]:&lt;20} \\nChoose your departure time:&quot;, reply_markup=build_time_keyboard(&quot;trip&quot;) ) else: context.user_data[&quot;trip_session&quot;][&quot;dest&quot;] = data start_name = context.user_data.get(&quot;trip_session&quot;, {}).get(&quot;search_s&quot;, {}).get(data, context.user_data[&quot;trip_session&quot;][&quot;start&quot;]) dest_name = context.user_data.get(&quot;trip_session&quot;, {}).get(&quot;search_d&quot;, {}).get(data, data) await query.edit_message_text(f&quot;üîç Finding trips from {start_name} to {dest_name}...&quot;) context.user_data[&quot;trip_session&quot;][&quot;trip&quot;] = get_trips(&quot;saarvv&quot;, context.user_data[&quot;trip_session&quot;][&quot;start&quot;], context.user_data[&quot;trip_session&quot;][&quot;dest&quot;], context.user_data[&quot;trip_session&quot;][&quot;time&quot;]) trip_basic=parse_trips_basic(context.user_data[&quot;trip_session&quot;][&quot;trip&quot;], start_name, dest_name) if trip_basic is None: btn_retry = InlineKeyboardMarkup([[InlineKeyboardButton(&quot;again&quot;, callback_data=&quot;trip:details:again&quot;)]]) await query.edit_message_text(&quot;‚ùå No trips found. Try again.&quot;, reply_markup=btn_retry) else: btn_details = InlineKeyboardMarkup([[InlineKeyboardButton(&quot;details&quot;, callback_data=&quot;trip:details:show&quot;)]]) await query.edit_message_text(text=trip_basic, reply_markup=btn_details)async def handle_trip_details(query, context, data): if data == &quot;again&quot;: context.user_data[&quot;trip_session&quot;].clear() await query.edit_message_text(&quot;üöå Where do you want to start your journey?&quot;, reply_markup=build_location_keyboard(&quot;trip&quot;,&quot;start&quot;)) else: trip = context.user_data[&quot;trip_session&quot;].get(&quot;trip&quot;) start_name = context.user_data.get(&quot;trip_session&quot;, {}).get(&quot;search_s&quot;, {}).get(data, context.user_data[&quot;trip_session&quot;][&quot;start&quot;]) dest_name = context.user_data.get(&quot;trip_session&quot;, {}).get(&quot;search_d&quot;, {}).get(data, data) await query.edit_message_text(text=parse_trips_detail(trip,start_name, dest_name)) /Depart ‚Äì Same interface, different requestThere are two major difference between /trip and /depart: We don‚Äôt need destination Different HTTP request method So we used the same interface for buttons and data handling, and used get_departures() and parse_departures() instead to fetch the results. Quick SummaryNow, we finished the basic logic and interface for our telegram bot, and finished the setup on /trip and /depart command. In next note, we are gonna create more commands and functions on top of them. Continue Reading: UdS Fahrplan Bot Development Log (4) ‚Äì Implementation on /sethome and /home function Reference hafas-client Deutsche Bahn SaarFahrplan Mobiliteit.lu Mobiliteit.lu (Github Repo)","link":"/projects/udsfahrplan-log3/"},{"title":"UdS Fahrplan Bot Development Log (2) -- Planning for telegram bot","text":"This blog post is trying to tell you: The motivation of making my own telegram bot Is UdSfahrplan ‚ÄúReinventing the wheel‚Äù? Saarfahrplan v.s. Uni StudentsPrevious post: UdS Fahrplan Bot Development Log (1) ‚Äì Fetching data from HAFAS and its APIs through POST requests SaarFahrplan is a public transport app to provide real-time information and services related to public transportation in Saarland. Its target users are the people who live and travel in Saarland for general purpose. When it comes to a smaller group of users, for example Uni students, some functionalities might be redundant and we may optimized some common use case for better user experience. Common use cases for studentsInstead of searching different connections, Uni students‚Äô timetable are usually consistent and repetitive. There are a few places where they always go, for example: Go to the Uni Go to the Mensa Go to the Dormintory Go to the City Go to the Supermarket Another scenario will be when we are in somewhere new, we would like to know how to go back home (dormitory). Key functions on our telegram botBased on the above use case, So we create our own app/bot that only accommodate them. Specified set of stationsWe first made a set of stations that are commonly used by Uni students, that can be used without further search. On the other hand, we also provided a search function for other stations if needed. /home ‚Äì A function that saves your timeOriginally, if you want to search for a trip in Saarfahrplan, you need to: Go to the ‚ÄúTrip Planner‚Äù page Type the starting location Select the correct station in the pop up fragment Back to the ‚ÄúTrip Planner‚Äù page Type the destination Select the correct station in the pop up fragment Back to the ‚ÄúTrip Planner‚Äù page Select Departure time in the pop up (optional) Press ‚ÄúSearch Button‚Äù This is somehow annoying if you already know which station you are planning to go. Therefore, we create the following flow: Use the /home command Select the destination Select Departure time Since we‚Äôve already made a set of stations, we can save lots of time from searching. Of course, if we are in a new place where the set is not included, we can: Use the /home command Select the More Stations Type the station name Select the correct station Select Departure time All actions can be done in the same interface. /sethome ‚Äì One time setup, use foreverAs we can see, the major difference between our design and the app is that we don‚Äôt have to search or select our destination when using the command /home. This is because we already stored users‚Äô home station beforehand. Short SummaryInstead of repeating the whole workflow, we can first save the progress of some subtasks, and retrieve them in our daily workflow to save our time. $$\\text{(Task A + Task B)}\\times\\text{repetitons}\\Rightarrow\\text{Task A + (Task B}\\times\\text{repetitons)}$$ Continue Reading: UdS Fahrplan Bot Development Log (3) ‚Äì Implementation on /trip and /Depart function Reference hafas-client Deutsche Bahn SaarFahrplan Mobiliteit.lu Mobiliteit.lu (Github Repo)","link":"/projects/udsfahrplan-log2/"},{"title":"UdS Fahrplan Bot Development Log (1) -- Fetching data from HAFAS and its APIs through POST requests","text":"This blog post is trying to tell you: My personal study notes on HAFAS, a public transport management system used around europe What is HAFAS? The HaCon Timetable Information System (HAFAS) is a software for timetable information from the company HaCon (Hannover Consulting). ‚Äì Wikipedia Basically, the entire Germany, Luxembourg, and the surrounding countries/regions use HAFAS to obtain depatures and stations details. This centralized software system can be visited using APIs. Different service providers may create their own HAFAS backend endpoint that exposes a public transport API over HTTP for customized usage. For example, you can send your HTTP requests to Deutsche Bahn (DB) if you have the access of their API, which can be found in DB API Marketplace. What can we do with HAFAS?There are four basic functions that the system has provided: TripSearch ‚Äì return connections from location A to location B StationBoard ‚Äì return all arrivals and departures of a certain station LocGeoPos ‚Äì return list of stations in a give range of area LocMatch ‚Äì return list of stations based on the keyword given These includes most of the functionalities for users. For example, when we tried to plan our journey on DB navigator, the app uses TripSearch to show you connections; when we type the stations in the search box, the app LocMatch to give you related results. Methods in detailSince HAFAS is a enormous software system , there are a lot of attributes and setting provided to create a precise request. Here are some examples: departure time arrival time no. of trips/stations returned modes of transportations transfer time max. no. of transfer How to perform a HTTP requestA HTTP request can be done by POST or GET as usual. For different regions or transportation providers, they set up their own server (API endpoint) that restrict what data and their format to return. Therefore users will not be overwhelmed with unrelated results. For example, when you are searching for stations in Luxembourg using Mobiliteit.lu, you may not want to see stations that share the same name, but are located in Berlin. For each providers we need the corresponding profiles complete our request. Here is a python example to create a LocMatch request to SaarVV, the transportation provider in Saarland. getTrip.py123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport jsondef LocMatch(): url = &quot;https://www.saarfahrplan.de/bin/mgate.exe&quot; headers = { &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Accept-Encoding&quot;: &quot;gzip&quot;, &quot;User-Agent&quot;: &quot;HAFAS&quot; } body = { &quot;ver&quot;: &quot;1.63&quot;, &quot;lang&quot;: &quot;en&quot;, &quot;auth&quot;: {&quot;type&quot;: &quot;AID&quot;, &quot;aid&quot;: &quot;yCW9qZFSye1wIv3gCzm5r7d2kJ3LIF&quot;}, &quot;client&quot;: { &quot;id&quot;: &quot;ZPS-SAAR&quot;, &quot;type&quot;: &quot;WEB&quot;, &quot;name&quot;: &quot;webapp&quot;, &quot;l&quot;: &quot;vs_webapp&quot;, &quot;v&quot;: 10004 }, &quot;formatted&quot;: False, &quot;svcReqL&quot;: [{ &quot;meth&quot;: &quot;LocMatch&quot;, &quot;req&quot;: { &quot;input&quot;: { &quot;field&quot;: &quot;S&quot;, &quot;loc&quot;: { &quot;type&quot;: &quot;ALL&quot;, &quot;name&quot;: keyword, }, &quot;maxLoc&quot;: 5 } }, &quot;id&quot;: &quot;1|3|&quot; }] } try: res = requests.post(url, headers=headers, data=json.dumps(body)) data = res.json() return data except Exception as e: print(f&quot;‚ùå Error fetching location matches: {e}&quot;) return None The whole request used a JSON format (&quot;Content-Type&quot;: &quot;application/json&quot;), and the most important fields we need to connect to the API gateway/server-side application (URL) is a correct header, auth and client. With these we may establish the connection with the server and fetch the desired data. Continue Reading: UdS Fahrplan Bot Development Log (2) ‚Äì Planning for telegram bot Reference hafas-client Deutsche Bahn SaarFahrplan Mobiliteit.lu Mobiliteit.lu (Github Repo)","link":"/projects/udsfahrplan-log1/"},{"title":"Hexo Plugins and Personalization of this site","text":"Here are all the plugins and niche settings that personalize this blog and the Icarus theme. Remove Uppercase DetailsThe Uppercase characters overflowed the page and affects the aesthetic. Find the css tag that contains the keyword Uppercase and remove it. article.jsx1{page.layout !== 'page' ? &lt;div class=&quot;article-meta is-size-7 is-uppercase level is-mobile&quot;&gt;} Better Sans FontIn _config.icarus.yml, find the following section providers: _config.icarus.yml1234567providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: jsdelivr # Name or URL template of the webfont CDN provider fontcdn: https://fonts.googleapis.com/css2?family=Noto+Sans+HK:wght@100..900&amp;display=swap # Name or URL of the fontawesome icon font CDN provider iconcdn: fontawesome Choose your favorite font in Google Fonts, and paste the url of the font to fontcdn Atom or RSS feed ‚Äì hexo-generator-feedIt is used for generating Atom 1.0 feed. Check Here Installationterminal1npm install hexo-excerpt --save Configuration_config.icarus.yml12345678910111213feed: enable: true type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date icon: /img/avatar.png autodiscovery: true template: Automatic excerpt generator ‚Äì hexo-excerptInstallationterminal1npm install hexo-excerpt --save Configuration_config.icarus.yml12345excerpt: depth: 10 excerpt_excludes: [] more_excludes: [] hideWholePostExcerpts: true","link":"/site/personalize/"},{"title":"MensaarLecker Development Log (2) -- Web Developing and GitHub Workflow","text":"This blog post is trying to tell you: My personal experience when developing a web crawler using Selenium Explained with examples from my Repository: MensaarLecker Fetching Data from Web DevelopmentPrevious post: MensaarLecker Development Log (1) ‚Äì Web Crawling Continuing from last post, we have already implemented a script that collect the Mensa menu and stored it on Google Sheets. It is time to build our web interface to connect the database. Fetch Data from Google Sheets using PublishFirst, we need to publish our spreadsheet so that it is public to fetch the data. In the Spreadsheet, click Share ‚Üí Change access to Anyone with the link. Click File ‚Üí Share ‚Üí Publish to the web. Select Entire Document ‚Üí Comma-separated values (.csv) and click Publish. Copy the public CSV link. menu.py1234567891011SCRIPT_URL = {PUBLISH_LINK}# Fetch JSON datadef fetch_menu(): try: response = requests.get(SCRIPT_URL) response.raise_for_status() # Raise error if bad response return response.json() except requests.exceptions.RequestException as e: print(f&quot;‚ùå Error fetching menu: {e}&quot;) return [] However, the script return no data, why? caret.ebnf123Access to fetch at 'https://docs.google.com/spreadsheets/...' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled. CORS Policy and XSS Cross-origin resource sharing (CORS) is an extension of the same-origin policy. You need it for authorized resource sharing with external third parties. ‚Äì Amazon Web Services This is a cyber security scheme to avoid XSS (Cross-site scripting), in a nutshell, when we run the script, the code cannot proceed because it doesn‚Äôt login to any Google account! You can imagine the request is block by a imaginary login page and our program doesn‚Äôt know how to react. Second Attempt ‚Äì Google Apps ScriptGoogle doesn‚Äôt allow users to fetch their data casually, except this is executed under Google‚Äôs server. This means we need to run our fetching function using Google‚Äôs service. Apps Script provide a JavaScript editor to save your code. menu.py12345678910111213141516171819function doGet() { var sheet = SpreadsheetApp.openById(&quot;PUT_YOUR_SHEET_ID_HERE&quot;).getActiveSheet(); var data = sheet.getDataRange().getValues(); var headers = data[0]; var jsonData = []; for (var i = 1; i &lt; data.length; i++) { var row = {}; for (var j = 0; j &lt; headers.length; j++) { row[headers[j]] = data[i][j]; } jsonData.push(row); } var output = ContentService.createTextOutput(JSON.stringify(jsonData)); output.setMimeType(ContentService.MimeType.JSON); return output;} To get the sheet ID, we can simply open the sheet and it is part of the URL: Deploying the function and fetch the dataAfterwards, we can deploy this function and it will generate a unique URL for the function output and we can fetch the data (here we export the data in json format) and use it in our code. You can also double check the URL and make sure it does return the value correctly ‚Üí link menu.py12345678910SCRIPT_URL = &quot;URL_DEPLOYED_FROM_APP_SCRIPT&quot;;def fetch_menu(): try: response = requests.get(SCRIPT_URL) response.raise_for_status() # Raise error if bad response return response.json() except requests.exceptions.RequestException as e: print(f&quot;‚ùå Error fetching menu: {e}&quot;) return [] Webpage ImplementationTo simplify our automation process on GitHub, we will continue implement our HTML code using Python. Our website should have two pages: index.html contains today‚Äôs menu, and menu.html contains the history of collected menus. Static data ‚Äì Tripe QuotesWe can put all the static code in strings. In Python we can store multi-line strings using triple quotes. index.html123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Mensaar Today&lt;/title&gt; &lt;style&gt; body { font-family: Arial, sans-serif; padding: 20px; text-align: center; background-image: url('src/uds_spirit.jpg'); } h1 { background: rgba(255, 255, 255, 0.8); color: #003C71; padding: 10px 20px; display: inline-block; border-radius: 10px; box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2); } .container { width: 80%; margin: auto; } .closed-message { font-size: 26px; color: red; font-weight: bold; padding: 20px; background: #fff3f3; border-radius: 10px; } .menu-card { background: white; padding: 15px; margin: 10px 0; border-radius: 10px; box-shadow: 2px 2px 10px rgba(0,0,0,0.1); text-align: left; } .meal-title { font-size: 20px; font-weight: bold; } .meal-components { font-size: 16px; color: #666; } .meal-frequency { font-size: 14px; color: #888; font-style: italic; } .button { padding: 12px 20px; background: #007bff; color: white; border-radius: 5px; text-decoration: none; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Mensaar Menu for {today}&lt;/h1&gt;&lt;/br&gt; &lt;a href=&quot;menu.html&quot; class=&quot;button&quot;&gt;üìú View Full Menu&lt;/a&gt; &lt;div class=&quot;container&quot;&gt;&lt;/body&gt; Enhance the design using DataTableSince we will collect the menu everyday, the table in menu.html will become too long for loading and hard to check. We can use DataTable that provide basic table layout like filtering, searching, and sorting. Also, it is very easy to implement, simply include the JavaScript and CSS link in the HTML code and you can get the basic, but decent design. Automation with GitHub WorkflowFinally, after we deployed the code to GitHub, remember our original goal: Scrape the Mensa menu every weekday and store it to Google Sheets Fetch the Data Collection from Google Sheets and update the website In fact, we can run the python script periodically using Github workflow, here are the steps: The workflow has to be implemented in .yml format, and stored in .github/workflows/{workflow_name}.yml Before running the python script, make sure python is set with all the dependencies installed: .github/workflows/menu.yml12345678910111213141516171819- name: üõ† Set up Python uses: actions/setup-python@v4 with: python-version: &quot;3.x&quot;- name: üì¶ Install dependencies run: | pip install requests selenium webdriver-manager gspread oauth2client- name: üöÄ Run Mensaar Scraper (update Google Sheets) run: | echo &quot;üß™ Starting Mensaar_scraper...&quot; python Mensaar_scraper.py echo &quot;‚úÖ Scraper completed.&quot;- name: üñºÔ∏è Run HTML Generator run: | echo &quot;üß™ Generating index.html &amp; menu.html&quot; python generate_menu.py For the full workflow, you can find the skeleton code template on GitHub or you can check here. A random summaryWith all these works, we managed to build our web crawler and a static website using only python. And Github workflow can help us with daily updates. Continue Reading: MensaarLecker Development Log (3) ‚Äì Telegram Bot Deployment and Integration","link":"/projects/mensaar-log2/"},{"title":"MensaarLecker Development Log (1) -- Web Crawling","text":"This blog post is trying to tell you: My personal experience when developing a web crawler using Selenium Explained with examples from my Repository: MensaarLecker MotivationMe and my friends hatelove the UdS Mensa so much! The infinite frozen food and french fries menus give us so much energy and motivation for the 5-hour afternoon coding marathon. However, no one actually knows how many potatoes they have exterminated throughout the week. We have a genius webpage created by some Schnitzel lover. Personally, I like its minimalistic layout and determination on Schnitzel searching. However, we want more. It‚Äôs not just Schnitzel; we want to know everything about their menu. We want to know what‚Äôs inside the mensa ladies‚Äô brains when they design next week‚Äôs menu. The desire never ends. We need more data, more details, more, More, MORE! Developing ProcessOur Goal here is simple: Scrape the Mensa menu every weekday and store it to Google Sheets Fetch the Data Collection from Google Sheets and update the website Web ScrapingTo collect the data, we can use Python libraries to simplfied the process. But the basic idea it the same: we try to find the pattern of the HTML tag and locate the desired data. Beautiful SoupI started my journey with Beautiful Soup, one of the most popular Python web scraper packages. However, as a Uni that is well-known for its computer science program, all the menus are rendered using JavaScript. And beautiful can only scrape HTML and XML tags. So the scraper can only see an empty skeleton page: SeleniumBasically, Selenium is a Webdriver that opens a browser naturally, like a human user. Then from there we can scrape the rendered information. Things get simpler once we can see the website as we see it on the browser. We just need to find the tag that contains the information we need and save it for storage. Desired Data and Tags Data Tag menus &lt;div class=&quot;counter&quot;&gt; date &lt;div class=&quot;cursor-pointer active list-group-item&quot;&gt; main dish &lt;span class=&quot;meal-title&quot;&gt; side dish &lt;div class=&quot;component&quot;&gt; The first part of the task is to get the daily menu. We also get the date on the website to make the following work easier. By the find_element and find_elements functions in Selenium, we can create a simple scraper like this: scraper.py12345678910from selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.by import Bydriver = webdriver.Firefox()driver.get(&quot;https://mensaar.de/#/menu/sb&quot;)counters = driver.find_elements(By.CLASS_NAME, &quot;counter&quot;)for counter in counters: meal_title = meal.find_element(By.CLASS_NAME, &quot;meal-title&quot;).text.strip() However, on the webpage there is also a counter called Wahlessen. Which refers to a more pricy and unpredictable menu, and we want to exclude its data: scraper.py12345counter_title = counter.find_element(By.CLASS_NAME, &quot;counter-title&quot;).text.strip()# Filter for specified counter titlesif counter_title in [&quot;Men√º 1&quot;, &quot;Men√º 2&quot;, &quot;Mensacaf√©&quot;]: meal_title = meal.find_element(By.CLASS_NAME, &quot;meal-title&quot;).text.strip() StorageIn order to make the database easy to be accessed by other users/students, we decided to deploy the data set to Google SpreadSheets. scraper.py123456789101112131415with open(output_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: json.dump(result, f, ensure_ascii=False, indent=2)print(f&quot;Results saved to {output_file}&quot;)# Save the updated occurrence counts to the JSON filecount_result = { &quot;meal_counts&quot;: dict(meal_count), &quot;component_counts&quot;: dict(component_count)}with open(count_file, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: json.dump(count_result, f, ensure_ascii=False, indent=2)print(f&quot;Counts saved to {count_file}&quot;) Change the time formatOnce we fetch data, you may notice that the website display the date in german format e.g. ‚ÄúFreitag, 21. M√§rz 2025‚Äù, which is not recognized by Google Sheets directly. So we need to make a function to convert them before uploading: scraper.py12345678910111213GERMAN_MONTHS = { &quot;Januar&quot;: &quot;01&quot;, &quot;Februar&quot;: &quot;02&quot;, &quot;M√§rz&quot;: &quot;03&quot;, &quot;April&quot;: &quot;04&quot;, &quot;Mai&quot;: &quot;05&quot;, &quot;Juni&quot;: &quot;06&quot;, &quot;Juli&quot;: &quot;07&quot;, &quot;August&quot;: &quot;08&quot;, &quot;September&quot;: &quot;09&quot;, &quot;Oktober&quot;: &quot;10&quot;, &quot;November&quot;: &quot;11&quot;, &quot;Dezember&quot;: &quot;12&quot;}def format_date(german_date): match = re.search(r&quot;(\\d{1,2})\\. (\\w+) (\\d{4})&quot;, german_date) if match: day, month, year = match.groups() month_number = GERMAN_MONTHS.get(month, &quot;00&quot;) return f&quot;{year}-{month_number}-{int(day):02d}&quot; return &quot;0000-00-00&quot; Upload the data to Google SheetsIn order to interact with the Google Sheets, we need to use Google API. First, go to Google Cloud Console. Create a new project. Next, go to API and Services, click Enable API and Services Search Google Sheets API, select it and choose Enable„ÄÇ Move Credentials from the sidebar, then choose Create credentials ‚Üí Create service account In step 2, choose the role Editor Now, when you come back to the Credentials page, you should see a newly generated email under Service Accounts, click it and select the tab Keys Select Create new key, choose JSON format, the file should start downloading automatically. Important NoticeThis JSON file contains sensitive data, you should NEVER directly use it in your code, save it as an environment variable or save it as a secret on Github With this key we can login the email we just created in Service Accounts, so that it is treated as a virtual users when running the script. Same as human users, in order to access the sheet we need to add this email as an editor in Google Sheets. scraper.py12345678910111213141516171819try: # Read and validate credentials.json before using it if not os.path.exists(&quot;credentials.json&quot;): print(&quot;‚ùå credentials.json not found!&quot;) return with open(&quot;credentials.json&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: raw_creds = f.read() creds_data = json.loads(raw_creds) # Save to a temp file just in case gspread needs it as a file temp_path = &quot;parsed_credentials.json&quot; with open(temp_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: json.dump(creds_data, f) creds = ServiceAccountCredentials.from_json_keyfile_name(temp_path, scope) client = gspread.authorize(creds) sheet = client.open(SHEET_NAME).sheet1 print(&quot;‚úÖ Google Sheets Auth OK&quot;) End of ScrapingNow we all set! Next, we need to display our collected results on web interfaces. Continue Reading: MensaarLecker Development Log (2) ‚Äì Web Developing and GitHub Workflow","link":"/projects/mensaar-log1/"},{"title":"Appium commands that are commonly used on Mac","text":"This blog post is trying to tell you:Every details and attributes you may need for your first appium automation. In this example, we will use Appium Inspector to start a seesion on your emulator on Android Studio. Start appium First, start the connection with Appium by cmd appium --allow-cors. It also gives you the remote url and the automationName that can be used in the Appium Inspector Start Session deviceName: adb devices platformName - appium driver list platformVersion - adb shell getprop ro.build.version.release Now you can start a session in your emulator, but it always begins from the home page. To directly start a session on certain App, you also need to provide the appPackage and the appActivity. Session with AppsIf your app is downloaded from the PlayStore. It is possible that the apk file name/path is hidden. However, you can You can simply open the app and check its name by adb shell dumpsys window | grep mCurrentFocus. It returns the appPackage and the current appActivity of the App, which are both necessary for our seesion to start. However, sometimes the current activity may not be directly opened. Then we need to check all the possible activities this App contans and try them out. To check the activity list, we can use adb shell dumpsys package YOUR_APP_appPackage | grep -i activity. Now, we can start our emulator, and run the command adb shell am start -n YOUR_APP_appPackage/YOUR_APP_appActivity to see whether it can start the App successfully. If it works we can use it in our inspector.","link":"/appium/"},{"title":"Automata, Games, and Verification (Portal)","text":"This is a learning note of a course in CISPA, UdS. Taught by Bernd Finkbeiner Chapter 1. Introduction Sections Exercise 1.1. Model Checking 1.2. Synthesis 1.3. The Logic-Automata Connection Chapter 2. B√ºchi Automata Sections Exercise 2.1. Preliminaries 2.2. Automata over Infinite Words 2.3. The B√ºchi Acceptance Condition Chapter 3. B√ºchi‚Äôs Characterization Theorem Sections Exercise 3.1. Kleene‚Äôs Theorem 3.2. $\\omega$-regular language 3.3 Closure Properties of the B√ºchi-recognizable languages (Intersection and Union) 3.4 Closure Properties of the B√ºchi-recognizable languages (Concatenations) 3.5 B√ºchi‚Äôs Characterization Theorem Chapter 4. Deterministic B√ºchi Automata Sections Exercise 4.1. Deterministic vs. Nondeterministic B√ºchi Automata 4.2. Complementation of deterministic B√ºchi Automata Chapter 5. Complementation of B√ºchi automata Sections Exercise 5.1. Infinite Directed Acyclic Graph (DAG) 5.2. Ranking of DAG 5.3. Complement B√ºchi Automaton with Odd Ranking Chapter 6. Logics over Infinite Sequences Sections Exercise 6.1. Linear-Time Temporal Logic (LTL) 6.2. Expressing Program Properties using LTL 6.3. LTL and Counting Languages 6.4. Quantified Propositional Temporal Logic (QPTL) 6.5. Monadic Second-Order Logic of One Successor (S1S) 6.6. Express QPTL using S1S 6.7. S1S$_0$ and B√ºchi-recognizable LanguageB√ºchi-recognizable Chapter 7. Alternating B√ºchi Automata Sections Exercise 7.1. Alternating B√ºchi Automata 7.2. From LTL to Alternating B√ºchi Automata $\\varphi=(\\Diamond p)\\ \\mathcal{U}\\ (\\square q)$ 7.3. Translating Alternating to Nondeterministic automata Chapter 8. Linear Arithmetic Sections Exercise 8.1. Linear Arithmetic (Theory) 8.2 Encoding real numbers 8.3 Translation from Linear Arithmetic to Automata 8.4 Homogenous Inequality Testing is Automatic 8.5 From Linear Arithmetic to Automata Chapter 9. LTL Model Checking Sections Exercise 9.1 Automata-based LTL Model Checking with Sequential Circuits 9.2 Nested depth-first search 9.3 The Emerson-Lei algorithm Chapter 10. McNaughton‚Äôs Theorem Sections Exercise 10.1 The Muller Acceptance Condition 10.2 From B√ºchi automata to Muller automata 10.3 Closure Properties of Muller Automata under Boolean Operations Further Reading:","link":"/notes/agv/"},{"title":"Leetcode SQL 50 (Portal üö™)","text":"This is a portal for my walkthroughs of SQL 50 on Leetcode Link of Leetcode SQL 50 Select 1757. Recyclable and Low Fat Products 584. Find Customer Referee 595. Big Countries 1148. Article Views I 1683. Invalid Tweets Basic Joins 1378. Replace Employee ID With The Unique Identifier 1068. Product Sales Analysis I 1581. Customer Who Visited but Did Not Make Any Transactions 197. Rising Temperature Advanced String Functions / Regex / Clause 1667. Fix Names in a Table 1527. Patients With a Condition 196. Delete Duplicate Emails 176. Second Highest Salary 1484. Group Sold Products By The Date 1327. List the Products Ordered in a Period 1517. Find Users With Valid E-Mails","link":"/notes/sql50/"},{"title":"hexo-zhruby -- Implementing HTML Ruby tag in Hexo","text":"Implement the HTML tag &lt;ruby&gt; for Hexo using Tag Plugin feature. Provide auto pronounciation indication for Jyutping (Cantonese), Zhuyin (Taiwanese Mandarin), and Pinyin (Chinese Mandarin), and the default setting for general usage. Support Traditonal and Simplified Chinese characters. Inspired by the hexo-ruby-character by jamespan. Installterminal1npm install hexo-zhruby --save Use casesRuby („É´„Éì) is also known as Furigana (ÊåØ„Çä‰ªÆÂêç). It contains two basic use cases: To clarify or indicate the pronunciation for readers Gikun, in which the characters have different pronunciations than they seem due to convention or for a specific context. For example, the pronunciation of ÁÖôËçâ in Japanese is tabako (tobacco). UsageTLDR: Usage: {% tag rb|rt %}; Tag options: ruby_def, ruby_jy, ruby_py, ruby_zy. For the 1st use case (pronunciation indication)ruby_def allows any language, and the spacing in rp will expand evenly with respect to the word length in rt. {% ruby_def Âü∫Êú¨|„Åç„Åª„Çì %} ‚Üí Âü∫Êú¨(„Åç„Åª„Çì) {% ruby_def Âü∫Êú¨|Í∏∞Î≥∏ %} ‚Üí Âü∫Êú¨(Í∏∞Î≥∏) {% ruby_def Âü∫Êú¨|fundamental %} ‚Üí Âü∫Êú¨(fundamental) {% ruby_def Âü∫Êú¨|Œ∏ŒµŒºŒµŒªŒπœéŒ¥ŒµœÇ %} ‚Üí Âü∫Êú¨(Œ∏ŒµŒºŒµŒªŒπœéŒ¥ŒµœÇ) {% ruby_def Âü∫Êú¨|–±–∞–∑–æ–≤—ã–π %} ‚Üí Âü∫Êú¨(–±–∞–∑–æ–≤—ã–π) {% ruby_def Âü∫Êú¨|z√°kladn√≠ %} ‚Üí Âü∫Êú¨(z√°kladn√≠) {% ruby_def fundamental|Âü∫Êú¨ %} ‚Üí fundamental(Âü∫Êú¨) ruby_jy, ruby_py, ruby_zy refers to Jyutping, Pinyin, Zhuyin respectively. No need to enter the pronunciation manually in rt; the value will automatically be returned. {% ruby_zy Âü∫Êú¨ %} ‚Üí Âü∫Êú¨(„Ñê„Ñß „ÑÖ„Ñ£Àá) {% ruby_py Âü∫Êú¨ %} ‚Üí Âü∫Êú¨(jƒ´ bƒõn) {% ruby_jy Âü∫Êú¨ %} ‚Üí Âü∫Êú¨(gei1 bun2) For the 2nd use case (Gikun)Same usage for ruby_def. {% ruby_def special|basic %} ‚Üí special(basic) {% ruby_def ÁâπÂà•|Âü∫Êú¨ %} ‚Üí ÁâπÂà•(Âü∫Êú¨) In ruby_jy, ruby_py, ruby_zy, you can also add |rt just like ruby_def. {% ruby_zy ÁâπÂà•|special %} ‚Üí ÁâπÂà•(special) {% ruby_py ÁâπÂà•|special %} ‚Üí ÁâπÂà•(special) {% ruby_jy ÁâπÂà•|special %} ‚Üí ÁâπÂà•(special) {% ruby_zy ÁâπÂà•|Âü∫Êú¨ %} ‚Üí ÁâπÂà•(„Ñê„Ñß „ÑÖ„Ñ£Àá) {% ruby_py ÁâπÂà•|Âü∫Êú¨ %} ‚Üí ÁâπÂà•(jƒ´ bƒõn) {% ruby_jy ÁâπÂà•|Âü∫Êú¨ %} ‚Üí ÁâπÂà•(gei1 bun2) Notice that the rt output depends on the pronunciation in rt, but not rp. This feature is only available when rt is a Chinese Character in CJK Unified Ideographs (\\U4E00-\\U9FFF). If the input of rt is not in CJK Unified Ideographs, it is considered as ruby_def. Known issuesThe Chinese language contains a lot of Homophones, which can be resolved by context most of the time. However, for long sentences (&gt;= 15 characters), or very specific names and terms, the auto-generation from 1st use case may not be very sensitive. Please use ruby_def if it happens or contribute to this project by providing a more sensitive or advanced Chinese vocabulary library. References CJK Unified Ideographs (Unicode block) Homophone Gikun (japanese only) Gikun (English version under the article Kanji) &lt;ruby&gt;: The Ruby Annotation element Unicode/Character reference Universal Character Set characters (Unicode)","link":"/projects/hexo-zhruby/"},{"title":"Hexo Tag Plugin (2) -- Create and publish your own Hexo Tag Plugin","text":"This blog post is trying to tell you: How to use your own Tag Plugin in local environment? How to publish your Tag Plugin to npm and hexo? For explaination on Tag Plugin and Scripts in Hexo, see the previous postHexo Tag Plugin (1) ‚Äì Use ‚ÄòHexo Scripts‚Äô to create your own Tag Plugin. Plugin Be Careful! Don‚Äôt mix Plugin, Tag, and Tag Plugin in Hexo, even though they look extremely similar. Usually, Plugin are for complicated functions. Yet if you want to publish your custom Tag Plugin to the NPM registry or even shown on the Hexo Community Page, Plugin would be a very good choice. From Script to PluginAssume you already have a script call index.js, and you want to turn it into package, you may do the following: Navigate node_modules folder in your project folder. This is the folder where Hexo stored all the packages for your blog. Create a folder inside and the name must begin with hexo- or Hexo will ignore it. Your folder must contain at least two files: the actual JavaScript code and package.json file that describes the purpose of the plugin and sets its dependencies. directory123.‚îú‚îÄ‚îÄ index.js‚îî‚îÄ‚îÄ package.json In package.json, it should at least have the name, version and main entries set. package.json12345{ &quot;name&quot;: &quot;hexo-my-plugin&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;main&quot;: &quot;index&quot;} In the root package.json of your hexo project, you also need to list your plugin as a dependency, for Hexo to detect and load it. Please remember that if your package contain other dependencies, also install and list them for testing and dubugging. package.json123456789101112131415161718192021{ &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot; }, &quot;hexo&quot;: { &quot;version&quot;: &quot;&quot; }, &quot;dependencies&quot;: { &quot;hexo&quot;: &quot;^7.3.0&quot;, ... &quot;hexo-my-plugin&quot;: &quot;0.0.1&quot;, &quot;my-plugin-dependency1&quot;: &quot;2.0.0&quot;, &quot;my-plugin-dependency2&quot;: &quot;2.0.0&quot; }} If you run command that check all the package after step 4, for exmaple hexo clean, it will check all the packages in node_modules and remove packages that are not publish on npm. Publish Plugin to npmTo publish your package on the NPM registry, don‚Äôt forget you have to setup your account on npm first. After creating the account, open your terminal and run npm login in the root of your package. Enter your username and password, then you should see a message like this if login is successful, terminal1Logged in as &lt;your-username&gt; on https://registry.npmjs.org/. Once you logged-in, you may simply publish your folder with npm publish command. Publish Plugin to HexoAfter publish your plugin package in npm, you can also publish it to Hexo official. Fork and CloneFirst of all, Fork hexojs/site from Github Then Clone the repository to your computer and install dependencies. terminal123git clone https://github.com/&lt;username&gt;/site.gitcd sitenpm install Add your Plugin to the listCreate a new yaml file in source/_data/plugins/, use your plugin name as the file name Edit source/_data/plugins/&lt;your-plugin-name&gt;.yml and add your plugin. For example: Push the branchCreate a pull request and describe the change. Hexo official create a nice form to make sure you have included everything needed. ResultsYou may check the progress on the pull requests history.Once it is closed you can see your plugin on the Hexo Plugins Community. Example workAs you may see, I also made my Plugin ‚ÄúHexo-zhruby‚Äù for Hexo and you can now see it on the community.For more details and see how it works, you may check here. Further Reading: Hexo Plugins and Scripts Hexo Tag Plugins Hexo Plugins Community npm-publish","link":"/js/hexo-tagplugin-2/"},{"title":"Hexo Tag Plugin (1) -- Use &#39;Hexo Scripts&#39; to create your own Tag Plugin","text":"This blog post is trying to tell you: What is Hexo Tag and Hexo script? How to implement your own Hexo Tag Plugin using Hexo Script? To color your personal Hexo Blog with more features, scripts and plugins are your powerful tools to use. Below we are trying to create our own tag plugin for the Hexo blog. Tag Plugin Be careful! Tag plugins are different from post tags. Tag plugins are special type of syntax that you may use in your Markdown file. Hexo has already provided some default Tag plugins like Block Quote and iframe. UsageFor example, the syntax of iframe tag is: video.md1&lt;iframe src=&quot;url&quot; width=&quot;[width]&quot; height=&quot;[height]&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt; Let say I want to embed a video from me and my friends‚Äô YouTube video: video.md1&lt;iframe src=&quot;https://www.youtube.com/embed/XIOl6BU7s9I?si=yTYsHIXNM6o-Zl9Z&quot; width=&quot;720&quot; height=&quot;461&quot; frameborder=&quot;0&quot; loading=&quot;lazy&quot; allowfullscreen&gt;&lt;/iframe&gt; And that‚Äôs how it looks like: ScriptLet say we want to create our own tag plugin, we can use the Hexo script function. Here‚Äôre the steps. Create a JavaScript file with function hexo.extend.tag.register(&quot;tag_name&quot;, args). You may also put your own function inside so that the second argument can also be function (args){} Here is an example of a function that create a tag named youtube, with embedding video function: video.js12345678hexo.extend.tag.register(&quot;youtube&quot;, function (args) { var id = args[0]; return ( '&lt;div class=&quot;video-container&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;http://www.youtube.com/embed/' + id + '&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;' );}); Put your JavaScript files in the scripts folder. If your project folder is new, you may not be able to find it. This is because scripts folder is actually under the Themes folder. You may check here to see the structure of themes and create your own one. Or you may be simply find a template on the Hexo themes community then put your .js file into the theme. It is done! Hexo will load them during initialization and you may use them in your blog post designs. Beyond ScriptsIf you are not satisfied with creating a local tag plugin, but a public one that will be seen by the community, you should consider using Hexo plugin function instead. check here to continue the journey. Continue Reading: Hexo Tag Plugin (2) ‚Äì Create and publish your own Hexo Tag Plugin Reference Hexo Plugins and Scripts Hexo Tag Plugins Hexo Tag Api Hexo Plugins Community","link":"/js/hexo-tagplugin-1/"},{"title":"Railroad Diagram of version range operators","text":"This is a image version of the post here range-set: range-set.ebnf1range-set ::= range ( logical-or range )* logical-or: logical-or.ebnf1logical-or ::= ' '* '||' ' '* referenced by: range-set range: range.ebnf123range ::= hyphen | simple ( ' ' simple )* | '' referenced by: range-set hyphen: hyphen.ebnf1hyphen ::= partial ' - ' partial referenced by: range simple: simple.ebnf1234simple ::= primitive | partial | tilde | caret referenced by: range primitive: primitive.ebnf1primitive ::= ( '&lt;' | '&gt;' | '&gt;=' | '&lt;=' | '=' ) partial referenced by: simple partial: partial.ebnf1partial ::= xr ( '.' xr ( '.' xr qualifier? )? )? referenced by: caret hyphen primitive simple tilde xr: xr.ebnf1234xr ::= 'x' | 'X' | '*' | nr referenced by: partial nr: nr.ebnf12nr ::= '0' | ['1'-'9] ['0'-'9]* referenced by: part xr tilde: tilde.ebnf1tilde ::= '~' partial referenced by: simple caret: caret.ebnf1caret ::= '^' partial referenced by: simple qualifier: qualifier.ebnf1qualifier ::= ( '-' pre )? ( '+' build )? referenced by: partial pre: pre.ebnf1pre ::= parts referenced by: qualifier build: build.ebnf1build ::= parts referenced by: qualifier parts: parts.ebnf1parts ::= part ( '.' part )* referenced by: build pre part: part.ebnf1part ::= nr | [-0-9A-Za-z]+ generated by RR - Railroad Diagram Generator","link":"/js/json-dependencies-diagram/"},{"title":"Explaination of version range operators in package.json for package dependencies","text":"To see the syntax and Railroad diagram version, goto here Basic StructurePackage dependecies are a tuple of [major, minor, patch] with numeric values. package.json1234567891011121314{ &quot;name&quot;: &quot;project name&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;description of the project&quot;, &quot;keywords&quot;: [ &quot;keyword 1&quot;, &quot;keyword 2&quot; ], &quot;author&quot;: &quot;John Doe&quot;, &quot;dependencies&quot;: { &quot;package-1&quot;: &quot;~0.6.2&quot;, &quot;package-2&quot;: &quot;&gt;=2.6.2&quot; }} Version Range operatorBasic RangeFor x in exmaple, see Advanced Range below. Operator Explaination Example = package version must be exactly matched 1.0.0 := =1.0.0(They are equivalent) &lt; package version must be less than indicated &lt;2.0.0 :=version from 0.0.1 to 1.x.x &lt;= package version must be less than or euqal to indicated &lt;=2.0.0 :=version from 0.0.1 to 2.0.0 &gt; package version must be greater than indicated &gt;2.0.0:= version from 2.0.1 to x (x &gt;= 2) &gt;= package version must be greater than or euqal to indicated &gt;=2.0.0 :=version from 2.0.0 to x (x &gt;= 2) || joined one or more operator &gt;2.0.1 || &lt;1.7.3 :=version greater than 2.0.1 or less than 1.7.3 space Intersected one or more operator &gt;=2.0.1 &lt;=1.7.3 :=version from 2.0.1 to 1.7.3 (inclusive) Advanced RangeAdvanced ranges may be combined in the same way as primitive comparators using space or ||. Operator Explaination Example X, x, * A Wildcard may be used for any values in the [major, minor, patch] tuple (missing value are consider using Wildcard x) * := (empty string) := &gt;=0.0.01.x.x := 1.x := 1 := &gt;=1.0.0 &lt;2.0.0 - Specifies an inclusive set of package version 1.2 - 2.3.4 := &gt;=1.2.0 &lt;=2.3.4 (missing pieces of first version are replaced with zeroes)1.2.3 - 2.3 := &gt;=1.2.3 &lt;2.4.x(missing pieces of second version replace with X-range) ~ Allows patch or minor level version changes, depends on specification ~1.2.3 := any version starts with 1.2 and greater than 1.2.3~1.2 := any version starts with 1.2 (same as 1.2.x) ^ Allows version changes in the [major, minor, patch] tuple without modify the left-most non-zero element. ^1.2.3 := &gt;=1.2.3 &lt;2.0.0(minor update)^0.2.3 := &gt;=0.2.3 &lt;0.3.0 (patch update)^0.0.3 := &gt;=0.0.3 &lt;0.0.4(no updates) Further Explaination on Caret Ranges ^Special interaction with Wildcard operator xWhen parsing caret ranges, minor and patch values with wildcard x desugars to the number 0 (missing values are consider as x): Example: ^1.2.x := &gt;=1.2.0 &lt;2.0.0-0 (equivalent to ^1.2.0) ^1.x := &gt;=1.0.0 &lt;2.0.0-0 (equivalent to ^1.0.0) However, when both major and minor versions are 0, Caret range allow flexibility within wildcard x: Example: ^0.0.x := &gt;=0.0.0 &lt;0.1.0-0 (NOT equivalent to ^0.0.0, but similar to ^0.1.0) Usage and Common PracticesCaret ranges usually ideally used when an author may make breaking changes. For example, between 0.2.4 and 0.3.0 releases, which is a common practice. However, it presumes that there will not be breaking changes between 0.2.4 and 0.2.5. It allows for changes that are presumed to be additive (but non-breaking), according to commonly observed practices. Further Reading: version range in npm-semver, setup-node in GitHub Actions","link":"/js/json-dependencies/"},{"title":"Why you shouldn&#39;t deploy your Hexo webpage using GitHub Desktop?","text":"Methods to Deploy Hexo to GitHub.ioAssume you‚Äôve created a repository on GitHub called &lt;username&gt;.github.io. Here are two common method you can deploy you Hexo Blog: Hexo CommandHexo‚Äôs documentations and Tutorial has provided sufficient instructions on deploying your personal website on your GitHub repository. According to the Hexo Tutorial, we can deploy the repository by using GitHub Actions. Create and Add the following contents to .github/workflows/pages.yml: .github/workflows/pages.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950name: Pageson:push: branches: - main # default branchjobs:build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 with: token: $ submodules: recursive - name: Use Node.js 20 uses: actions/setup-node@v4 with: # Examples: 20, 18.19, &gt;=16.20.2, lts/Iron, lts/Hydrogen, *, latest, current, node # Ref: https://github.com/actions/setup-node#supported-version-syntax node-version: &quot;&gt;=20&quot; - name: Cache NPM dependencies uses: actions/cache@v4 with: path: node_modules key: $-npm-cache restore-keys: | $-npm-cache - name: Install Dependencies run: npm install - name: Build run: npm run build - name: Upload Pages artifact uses: actions/upload-pages-artifact@v3 with: path: ./publicdeploy: needs: build permissions: pages: write id-token: write environment: name: github-pages url: $ runs-on: ubuntu-latest steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 Install hexo-deployer-git. Add/Change the following configurations to _config.yml: _config.yml12345deploy:type: gitrepo: https://github.com/&lt;username&gt;/&lt;project&gt;# for example, this blog is https://github.com/greenmeeple/greenmeeple.github.iobranch: gh-pages After finishing your bog posts, Run hexo clean &amp;&amp; hexo deploy. GitHub DesktopMany Users installed GitHub Desktop for better visualization on changes, so do I. It provides more intuitive push and commit procedure and instruction compared to terminal. Most of the time I use it to make sure no unexpected line changes or modification. But soon I noticed that, every time after running hexo clean &amp;&amp; hexo deploy, GitHub Desktop will warn me that there‚Äôs something need to be pulled. When I pull it for merging it return Unable to merge unrelated histories in repository. Even in the image above, it shows that I should pull something. However, how would I need to pull if I‚Äôve just push it? Security ProblemSo I inspect my repository, these two method actually deploy completely different content to the repository, even though they output the identical content on the webpage. When you deploy you webpage with Hexo command, it actually creates a folder .deploy_git, which is static HTML content without showing any configurations like your themes folder or _config.yml folder. In contrast, GitHub Desktop solely commit all folder that is not in .gitignore file and the website just rendered dynamically in the repository when someone visit. This create a huge security problem as much as it seems. All contents in your config is now visible to everyone. Since Hexo is a simple framework that depends heavily on Markdown and .yml files, there‚Äôs on where to hide all your settings and &lt;script&gt; if they just directly commit to your repository before building it statically. This may include not only your SEO and functionality of your webiste, but even some secret variable. GitTalk comment section and GitHub OAUTHFor example, the comment section below every posts in this blog are powered by GitTalk. It requires users to login through GitHub to comment. In order to handle the authorization of login, blog owners need to create an OAUTH App. Then they need to input their clientID and clientSecret initiate the plugin. For Hexo file structure, this will usually be stored in _config.yml. Therefore, if Blog Owner simply commit the whole folder using GitHub Desktop, their OAUTH App credentials are leaked to everyone. And this is how I start noticing the two deploy methods above are so different. Saving your sensitive information from Data Leak?As you may know, once you commit your issue on GitHub, it will leave a trace. This is because the version control nature of GitHub. But that also means everyone can always inspect your repositories‚Äô history, even your newest version already removed your leaked data. Other than deleting your repository and start all over again, you may also cover and rewrite your commit history, and even rewrite the content by following this. Further Reading: Environment variable, How to push code to Github hiding the API keys?","link":"/github-desktop/"},{"title":"Mathjax prime superscript problem in Hexo theme","text":"Prime superscript problem (e.g. x‚Äô_i) in MathjaxWhen I was using Mathjax to create math formula in my blog post, I typed((q_1, q_2), a, (q'_1, q'_2)) \\in S \\times \\Sigma_{int} \\times S and it rendered as $((q_1, q_2), a, (q‚Äô_1, q‚Äô2)) \\in S \\times \\Sigma{int} \\times S$ However, when ((q_1, q_2), a, (q'_1, q'_2)) &amp; \\in S \\times \\Sigma_{int} \\times S are seperated, they rendered properly. $$((q_1, q_2), a, (q‚Äô_1, q‚Äô_2))$$ $$\\in S \\times \\Sigma_{int} \\times S$$ Maybe I should use \\left and \\right for (), just like \\lbrace and \\rbrace for {}? So I typed \\left( \\left( q_1, q_2 \\right), a, \\left( q'_1, q'_2 \\right) \\right) \\in S \\times \\Sigma_{int} \\times S, didn‚Äôt work out: $\\left( \\left( q_1, q_2 \\right), a, \\left( q‚Äô_1, q‚Äô2 \\right) \\right) \\in S \\times \\Sigma{int} \\times S$ Source of error Problem definitely comes from the first half of the formula, since second half are all variables. Turns out there may be an issue with how the prime symbol are being handled. For simple formula, q'_1 and q_1' are considered the identical.However, for more complicated formula, the only q_1' can be rendered correctly: $$((q_1, q_2), a, (q_1‚Äô, q_2‚Äô)) \\in S \\times \\Sigma_{int} \\times S$$ SolutionsAfterwards, I found people reported similar issue before. Two basic solutions: Stick to the format x_{Subscript}^{Superscript}, but for prime symbol ', use it as x_{Subscript}' Simply use {\\prime} for every situation, e.g. x_{i}^{\\prime}.","link":"/site/hexo-mathjax/"}],"tags":[{"name":"Appium","slug":"Appium","link":"/tags/Appium/"},{"name":"App Testing","slug":"App-Testing","link":"/tags/App-Testing/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"UdS","slug":"UdS","link":"/tags/UdS/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"hafas","slug":"hafas","link":"/tags/hafas/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Cantonese","slug":"Cantonese","link":"/tags/Cantonese/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Scraper","slug":"Scraper","link":"/tags/Scraper/"},{"name":"Selenium","slug":"Selenium","link":"/tags/Selenium/"},{"name":"Telegram","slug":"Telegram","link":"/tags/Telegram/"},{"name":"HAFAS","slug":"HAFAS","link":"/tags/HAFAS/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Mathjax","slug":"Mathjax","link":"/tags/Mathjax/"}],"categories":[{"name":"Appium","slug":"Appium","link":"/categories/Appium/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Projects","slug":"Projects","link":"/categories/Projects/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"SiteNote","slug":"SiteNote","link":"/categories/SiteNote/"}],"pages":[{"title":"GreenMeeple cannot find what you are looking for...","text":"","link":"/404.html"},{"title":"Resume of Chun Ngai Li (Alex)","text":"For pdf version, click HERE About MeCurrently pursuing a Master‚Äôs in Cybersecurity, showcasing a strong foundation in penetration testing and AI-driven security solutions. Proficient in Python, C/C++, and JavaScript, with a proven track record of developing automation tools and secure web applications. Passionate about enhancing cybersecurity measures and risk assessment, eager to contribute to cutting-edge projects in international teams that prioritize seurity and scalability. Personal DetailsName: Chun Ngai LiPhone: +49 163-513-2617Address: 66125 Saarbr√ºcken, GermanyDate &amp; Place of Birth: 27.09.1999, Hong Kong Links and Websites Github LinkedIn LeetCode Personal Site (Here) EducationOctober 2021 ‚Äì March 2025M.Sc. Cybersecurity in Universit√§t des Saarlandes, Saarbr√ºcken Thesis Topic: Exploring the Cybersecurity Threats in LLM-Powered Apps: Malicious Code Generation and Regulatory Challenges Current Grade: 2.4 September 2017 ‚Äì May 2021B.Eng. Information Engineering in The Chinese University of Hong Kong, Hong Kong GPA: 3.275/4 (Equivalent to 1.54 in German System) Minor study: German Exchanged in KTH Royal Institute of Technology, Sweden in 2019-2020 Work ExperienceMarch 2022 ‚Äì March 2023IT Research Assistant at Universit√§t des Saarlandes, Saarbr√ºcken Developed a full-stack Intranet for the Faculty of Business using PHP7, JavaScript, and MySQL to maintain appointment and administrative work Developed Monte Carlo Algorithm using Microsoft Excel and VBA to create automation and user-friendly interface Enhanced Student website portal to provide resources, lending, significant and minor selection, and transcript March 2021 ‚Äì May 2021Software Engineer at Hong Kong Jockey Club, Hong Kong Worked for AI for the Future Project Developed a Mobile App using React Native and Python to control 3D-printing Robots via Bluetooth Created a documentation and user manual for the App and Robots to ensure effective communications and demonstrations to clients November 2020 ‚Äì February 2021Cybersecurity Undergraduate Researcher at The Chinese University of Hong Kong, Hong Kong Research Topic: Morpheus: Bringing the (pkcs) one to meet the oracle Contributed to pioneering cybersecurity research led by Dr. Sherman S. M. Chow, focusing on RSA\\PKCS1 signature verification Developed versatile black-box fuzzing tools using C++, Java, Python, and C# to investigate signature verification vulnerabilities June 2020 ‚Äì September 2020Software &amp; Technology Analyst at Sharp Peak Consulting Limited , Hong Kong Developed a Booking System for Clinic using Microsoft Power Apps Engaged in on-site visits to various corporations to install and maintain IoT products Contributed to Cybersecurity consulting towards server and network services Languages‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ German‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ English‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ Cantonese‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ Mandarin Skills‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ C‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ C++‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ SQL‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ PHP‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ Python‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ HTML &amp; CSS‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ JavaScript","link":"/about/resume.html"},{"title":"About Me","text":"Personal Info Click HERE for my detailed resume. Chun Ngai Li (Alex), M.Sc. Cybersecurity in Saarland University,B.Eng Information Engineering in CUHK. Recent WorksA C/C++ programmer. Also working on Backend &amp; Python developing.Current research: Social Engineering, Large Language Models (LLM), Machine Learning ContactsEmail: alexcnli@yahoo.com","link":"/about/index.html"}]}